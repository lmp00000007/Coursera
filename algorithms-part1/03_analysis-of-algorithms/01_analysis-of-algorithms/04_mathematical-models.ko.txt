지난 섹션에서 했듯이 실행 결과를 관찰하면 성능을 예측하는 방법을 얻을 수 있지만, 이것만으론 알고리즘의 동작을 이해하는 데에는
 사실 도움이 되지 않습니다. 그래서 수학 모델들을 살펴보려고 합니다. 이 모델들은 실제로 무슨 일이 일어나는지에 대한
 더 나은 개념을 제공해줍니다. 다시 말하지만, 이 개념은 사실
 1960년대 후반에 Donald Knuth 교수에 의해 개발되고 보급되었습니다. 그 때에는 컴퓨터 시스템이 처음으로
 정말 복잡해지기 시작하였고 따라서 컴퓨터 과학자들은 컴퓨터에서 일어나는 일을 이해하는 것이
 가능한지에 대해 고민하였습니다. 이 때, Knuth 교수는 수학적 모델이 우리가
 확실하게 할 수 있는 것이라고 강하게 주장했습니다. 우리는 프로그램의 총 실행시간을 계산할 수 있는데, 기본 연산들을 모두 특정(identifying)하고 (컴퓨터나 컴파일러에 의존적인
 연산 별) 비용을 이해하고 (각 연산의) 실행 빈도를 이해한 뒤 모든 연산에 대해,
 비용과 빈도를 곱한 값을 더하면 됩니다. 따라서 분석하려는 프로그램이
 어떤 집합의 연산을 가지고 있는지, 사용하려는 컴퓨터에 따라
 어떤 비용이 발생되는지를 분석하여야 합니다. 그리고 컴퓨터 시스템의 컴퓨터 외에도,
 앞에서 말했듯이 각 연산의 실행 빈도는 수학을 필요로 하는데, 이는 실행 빈도가 알고리즘과
 입력 데이터에 의존적이기 때문입니다. Knuth 교수는 (TAOCP라 불리는)
 책 시리즈를 저술하였는데, 그 시리즈에서 특정한 컴퓨터 모델을 가정한 뒤,
 매우 자세하고 정확한 분석을 넓은 범위의 알고리즘에 대해 진행하였습니다. 따라서 Knuth를 따라, 원리적으로는 동작하는 알고리즘이나 프로그램에 대한
 정확한 수학적 모델을 얻을 수 있게 됩니다. 이제, 이 과정의 상세를 살펴봅니다. (기본 연산의 비용을 알기 위해서)
 필요하다면 여러분은 실험을 하면 됩니다.
 옛날에는 실제로 컴퓨터 매뉴얼을 보고, 아, 그 시절엔 모든 컴퓨터의 매뉴얼에는 (연산에 대응하는) 각 명령어의 실행 시간을
 정확히 명시했습니다. (즉, 매뉴얼만으로 비용을 알 수 있죠.) 지금은 꽤 많이 복잡해져서 실험을 해야 합니다. 실제로 10억번 Add 연산을 해본 뒤
 (평균을 내보면), 여러분 컴퓨터에서 Add 연산 하나가 약 2.1 나노초가 걸릴 겁니다. 또는 Sin 함수나 Arctan 함수와 같은 더 복잡한 연산을 해볼수도 있습니다. 그 함수들을 구성하는 알고리즘의
 분석 결과와 거의 같아지겠지만요. 이제 기본 연산에 대한 비용을
 결정하는 한 방법을 얻었습니다. 그리고 앞으로 대부분의 경우에 그 비용은 어떤 상수값이라고 상정할 겁니다. 또한 (앞의 방법에 따라)
 그 상수값을 구해낼 수 있겠죠. 다만, N 개의 객체로 구성된
 집합(collection)을 다루는 연산은 N에 비례할 수도 있습니다. 마찬가지로 크기가 N인 배열을 할당한다면 N에 비례한 시간이 걸릴텐데,
 이는 Java의 경우 기본적으로 배열의 원소를 0으로
 초기화하도록 되어있기 때문입니다. 다른 연산들도, 시스템 구현에 따라 달라집니다. 중요한 것을 하나 꼽으면,
 문자열 접합(concatenation)이 있는데 (문자열 접합 연산으로)
 두 문자열을 연이어 붙이면 그 실행 시간은
 문자열의 길이 N에 비례합니다. 많은 프로그래밍/Java 초보자들이 '모든 연산이 상수 실행 시간을
 갖는다'고 가정하는 실수를 범하는데 아닌 경우도 있습니다. 자, 이제까지 각 연산의 비용에 대해서 이야기했고요. 더 재미있는 주제는 (알고리즘이나
 프로그램을) 실행하는 중에 연산의 실행 빈도입니다. 여기에 3-합 문제의 간단한 변형으로
 1-합 문제의 알고리즘이 있습니다. 이 알고리즘은 배열에 0인 원소의 개수를 세고 있습니다. (역주: 원어 설명은 오류) 이 알고리즘은 단 하나의
 for 루프를 가지고 있고요. 따라가보면 특정 원소의 값이 0인지 검사해서
 count 변수를 1 증가시킴을 알 수 있습니다. 그리고 코드를 분석하면 i와 count라는 변수가 선언(declaration)이 되어있고요. (빈도: 2) 각 변수의 초기값은 0으로 할당(assignment)되어야 합니다. (빈도: 2) (for 루프를 도는 과정에서) i와 N을 비교하는
 연산 횟수가 N+1 번 있고요. (빈도: N+1) a[i]가 0과 같은지를 비교하는 연산이 N 번 있고, 이와 병행하는 N 번의
 배열 접근 연산이 발생합니다. 증가(increment) 연산의 경우, 즉, 증가 연산의 실행 빈도는 (입력에 따라) 다릅니다. 변수 i는 정확히 N 번 증가하지만,
 변수 count는 (입력에 따라) 0부터 N 사이의
 어떤 수만큼 증가할 수 있습니다. 따라서 그 실행 빈도는 입력 데이터에 의존적이며 이를 설명하기 위한 수학적 모델을 필요로 합니다. 아니면, 예를 들어 다른 연산이 매우 비싸서, (입력 데이터에
 의존적인 실행 빈도를) 신경쓸 필요가 없을 수도 있습니다. 다음으로 좀 더 복잡한 문제를 살펴봅시다. 이 프로그램에서의 명령어 실행 빈도를 살펴봅시다. 이 문제는 2-합 문제라 불립니다. 즉, 정수 배열 내에서 조합한 쌍의 합이
 0이 되는 경우의 수가 궁금합니다. 이 경우, 동작을 살펴보기 위해
 조금 수학을 해야하고 i가 0에서 N까지 증가하고,
 j가 i+1에서 N까지 증가할 때 비교 연산을 수행하는 횟수, 아, 그게 아니라 배열에의 접근은 a[i]와 a[j]를 읽기 위해 (붉은 색)
 문장이 실행될 때마다 2 번실행되고 그 문장이 실행되는 횟수는 (외곽) for 루프의 첫 번째 실행(i=0일 때)에는 N-1번이고 두 번째 실행에선 N-2이며,
 이 경향을 유지하므로 그 붉은 색 문장의 실행 횟수는
 0부터 N-1까지의 정수의 합인데 이는 합 공식으로 (1/2)*N(N-1)이고,
 따라서 이 공식에 두 배를 하면 배열에 접근한 횟수를 계산할 수
 있어서, 그 값은 N(N-1)입니다. 비슷하게 해보면 (슬라이드에 나온 것과
 같은) 정확한 횟수를 셀 수 있습니다. 하지만, 살펴보았듯, 실제
 해보려면 좀 지루하긴 합니다. 그리고, 튜링으로 돌아가 이야기해보면, 튜링은 배비지가 그러했듯이 계산 과정에서 발생하는 일의 양에 대한
 척도(measure)를 가질 필요가 있음을 알았고, 또한 그렇다고 해도 그 상세를
 완전히 알 필요는 없음 또한 알았습니다. 대략적인 추정만 가져도 꽤 도움이 된다는 거죠. 따라서, 여러분은 모든 연산이
 적용되는 횟수를 셀 수 있고, (비용에 따른) 비중을 부여해
 대략적으로 셀 수도 있겠지만, 가장 비싼 연산만 세면 될 수도 있습니다. 이것이 Turing이 1947년에 발언한 것입니다. 실질적으로 우리가 지금도 하고 있는 것이죠. 따라서 모든 세세한 디테일을
 고려하고 세는 것 대신에 기본적인 연산을 특정한 뒤에 그 중 가장 비싼 연산, 가장 자주 실행되는 연산 그리고 비용과 실행 빈도의 곱이 가장 높은 연산 등을 정확한 실행 시간에 대한 대체품으로 사용합니다. 근본적으로, 실행시간에 관한 가설을 세우기 위함이죠. '실행 시간이 그 대체품과 상수의
 곱으로 증가할 것이다'라는. 이 경우에는, 배열 접근(array access)
을 살펴봤던 것이죠. 그게 첫 번째 단순화 작업이었고요. 두 번째로 우리가 하려는 단순화 작업은 우리가 유도한 공식에서
 낮은 차수 항을 무시하는 겁니다. 이를 쉽게 하기 위해서 물결표(tilde)를 사용한 표기법을 쓸 건데요. 그 표기법의 아이디어는 가리키고 있는 식과 같이 어떤 식에서 N이 클 때, 여기 N^3 항은 N 항이나 상수항(16)보다
 훨씬 훨씬 크다는 겁니다. 사실, 낮은 차수 항이 있는지도 모를 정도로 큽니다. 따라서, 여기에 있는 모든 식들은 (1/6)*N^3에
 근사하는데, 이를 물결표로 나타냅니다. 즉, 우변은 좌변이 갖는 양의 괜찮은
 대체값(representative) 또는 근사값이 됩니다. 이런 표기법은 이와 같이 낮은 차항을 버려서 계산을 매우 단순화시킵니다. 지금까지 특정한 연산의 성능에 집중해
 물결표 표기법으로 낮은 차수 항을 버리는 걸 보았고요. 여기에 물결표에 대한 기술적 정의가 있는데 f(N) tilde g(N)은 N이 무한대로 갈 때,
 f(N) 나누기 g(N)에 대한 극한값이 1임을 의미합니다. 쉽게 앞의 상황에서 그 정의가
 들어맞음을 확인할 수 있을 겁니다. 따라서 이 표기법은 실행 빈도를
 세는 것을 매우 단순화시킵니다. 여기서 한 개 뽑아서 살펴보면 예를 들어 여기 tilde N^2를 떠올려보면 2-합 문제에서 increment 연산이 tilde N^2이죠. 따시 말하면, N이 크면 작은 차수 항들은 무시할 수 있고요. N이 충분히 작으면, 그 항들을 그냥 무시할 수는 없습니다. 하지만, 걱정할 필요는 없는 게, 우리는
 큰 N에 대해 실행 시간을 예측하려고 하고 있지, 작은 N에 대해서 실행 시간이 어떻게 될 지
 예측하려 하진 않고 있습니다. 좋습니다. 이제, 우리는 비용 모델과 물결표 표기법을 써서, 간단히 이 프로그램이 tilde N^2의 배열 접근을
 필요로 한다고 말할 수 있죠. 이는 암묵적으로 우리가 생각하는 실행 시간이
 상수 곱하기 N^2에 근사할 것이라고 가설을 세우고 있는 겁니다. 좋습니다. 그럼 3-합 문제는 어떻습니까? 이 실제적인 문제에 도전해봅시다. 여기 3 개의 for 루프가 있고요. 훨씬 복잡한 조합(combinatorial)
 문제를 풀어야 합니다. 사실 그렇게 어렵지는 않습니다만. N 개 중에 서로 다른 세 개를 고르는
 경우의 수를 생각해야 하는데 이항 정리(binomial theorem) 공식의 한 계수입니다. 다시 수학 공식을 적용하고
 물결표 표기법을 써보면 세 수에 대한 각각의 경우에 세 번의
 배열 접근을 하고, for 루프의 횟수는 (1/6)*N^3이니 정리해서 tilde (1/2)*N^3 번의 배열 접근을 합니다. 여기서 모든 연산의 비용을 더해
 계산을 하지는 않았습니다. 그 작업은 꽤나 고생이죠. 우리는 비용과 실행 빈도의 곱 중 가장 비싼 것을 골라 근사함으로써 실행 시간에 대한 좋은 모델을 얻으려고 한 겁니다. 이제, 이 수업에선 이산 수학(discrete mathematics)을
 제대로 할 생각은 없습니다만 기본적인 건 아셔야 합니다. 앞으로 사용할 것 정도는요.
 이해하기 어렵지 않습니다. 앞으로 자주 이산 합 공식의 추정값을 활용할 필요가 있는데요.
 앞에서 1+2+...+N에 대해서는 했죠. 또는 (여기엔 없지만) 제곱 수의 합이라든가,
 3-합 문제에서 나온 3 번의 for 루프의 횟수 등이 있습니다. 사실 기본 미적분학 수업을 들었다면 생각해 볼 한 방법으로는, 합 공식을
 대응하는 구간에 대한 정적분으로 바꿔볼 수 있습니다. 보통 잘 먹히고, 수학을 좀 해보면 소위 오일러-매클로린(Euler-Maclaurin) 합 공식을
 진짜 근사값을 구하기 위해 쓸 수 있습니다. 하지만 이런 식으로 생각하더라도 역시 N^2의 절반에 근사함을 앎으로써
 앞의 논의를 믿을 수 있을 겁니다. 또는, 1 + 1/2 + 1/3 + ... + 1/N은 1부터 N까지 1/x를 x에 대해 정적분한 것과
 거의 같은데, 그 결과는 자연 로그 ln N입니다. 이제 3-합에서의 세 수에 관한 루프에서는, 다중 적분(multiple integral)을 사용해보면 빠르게 (1/6) N^3임을 알 수 있습니다. 우리가 쓸 수 있는 많은, 다양한 기법들이 있습니다. 이 모두를 가르칠 수는 없지만요. 하지만 이런 종류의 결과들을
 때때로 참고할 겁니다. 좋습니다, 원리적으로 Knuth 교수는 정확한 수학적 모델이 활용가능함을 알려줬지요. 실제로는, 훨씬 복잡한 공식을 얻게 될 수 있습니다. 이론가들이 다룰만한 고급 수학을
 필요로 할 수도 있고요. 하지만 아마도 처음 알고리즘을 배우는 사람들이라면
 알고 있을 것이라 기대하진 않겠지만요. 정리하면 숙고해 만들어진 정확한 모델은
 전문가에게 남겨두는 게 최선이고요. 해야할 게 정말 많으니까요. 반면, 근사 모델은 따라해 볼 가치가
 정말로 충분합니다. 우리가 생각할 모든 알고리즘에 대해서 앞으로 실행 시간을 설명하는데 사용될 수 있는 합리적인 근사 모델에 대해 토론할 겁니다. 때때로, 수학적 증명을 다룰 수도 있고, 때로는 어떤 전문가의 결과물을
 인용해야 만 하는 경우도 있을 겁니다.