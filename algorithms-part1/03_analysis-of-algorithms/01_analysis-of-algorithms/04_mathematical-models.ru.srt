1
00:00:01,880 --> 00:00:06,015
Наблюдения за происходящим

2
00:00:06,015 --> 00:00:09,270
позволяет предсказывать производительность,

3
00:00:09,270 --> 00:00:12,880
но не помогает понять работу алгоритма.

4
00:00:12,880 --> 00:00:15,179
Разберем математическую модель,

5
00:00:15,179 --> 00:00:21,430
чтобы понять суть происходящего.

6
00:00:21,430 --> 00:00:25,785
Эта концепция была разработана

7
00:00:25,785 --> 00:00:31,705
и популяризирована
Дональдом Кнутом в конце 60-х.

8
00:00:31,705 --> 00:00:37,140
В то время компьютерные системы
стали действительно сложными,

9
00:00:37,140 --> 00:00:40,140
и специалисты в области
компьютерных технологий

10
00:00:40,140 --> 00:00:45,475
были озабочены тем,
смогут ли они понять, что происходит.

11
00:00:45,475 --> 00:00:52,860
Кнут не сомневался,
что этого можно добиться.

12
00:00:52,860 --> 00:00:56,610
Можно вычислить общее время
работы программы

13
00:00:56,610 --> 00:01:01,110
путем определения всех базовых операций,

14
00:01:01,110 --> 00:01:02,430
затрат на их выполнение,

15
00:01:02,430 --> 00:01:04,950
периодичности выполнения

16
00:01:04,950 --> 00:01:09,089
и умножения всех затрат на периодичность.

17
00:01:09,089 --> 00:01:13,530
Проанализируйте программу
для определения набора базовых операций

18
00:01:13,530 --> 00:01:15,060
и времени их выполнения

19
00:01:15,060 --> 00:01:18,820
в зависимости от компьютера,
как мы говорили ранее.

20
00:01:18,820 --> 00:01:21,360
Нужно обратиться к математике,

21
00:01:21,360 --> 00:01:25,145
т.к. повторяемость зависит от алгоритма
и входных данных.

22
00:01:25,145 --> 00:01:27,750
Кнут написал серию книг, которая дает

23
00:01:27,750 --> 00:01:31,680
подробный и точный анализ в рамках

24
00:01:31,680 --> 00:01:36,430
конкретной компьютерной модели
для широкого круга алгоритмов.

25
00:01:36,430 --> 00:01:39,000
Таким образом, от Кнута,
мы знаем, что в принципе,

26
00:01:39,000 --> 00:01:43,005
можно получить точные
математические модели производительности

27
00:01:43,005 --> 00:01:48,155
алгоритмов или программ.

28
00:01:48,155 --> 00:01:51,879
Хорошо. Как же выглядит этот процесс?

29
00:01:51,879 --> 00:01:54,490
Если хотите, можете проводить

30
00:01:54,490 --> 00:01:57,670
эксперименты. В былые времена

31
00:01:57,670 --> 00:02:01,240
мы воспользовались бы руководством.

32
00:02:01,240 --> 00:02:03,835
Каждый компьютер снабжался руководством,

33
00:02:03,835 --> 00:02:07,330
в котором было точное время
выполнения каждой инструкции.

34
00:02:07,330 --> 00:02:10,840
Сейчас с этим сложнее,
поэтому мы проводим эксперименты.

35
00:02:10,840 --> 00:02:16,090
Можно провести миллиард действий сложения
и обнаружить, что компьютер затрачивает

36
00:02:16,090 --> 00:02:18,640
на сложение 2,1 наносекунду.

37
00:02:18,640 --> 00:02:23,035
Можно выполнить более сложные функции,
вроде вычисления синуса или арктангенса,

38
00:02:23,035 --> 00:02:28,060
это подводит нас к анализу алгоритмов.

39
00:02:28,060 --> 00:02:33,390
То есть способы определения
временных затрат существуют.

40
00:02:33,390 --> 00:02:38,485
В большинстве случаев

41
00:02:38,485 --> 00:02:40,780
мы принимаем эти затраты за константу

42
00:02:40,780 --> 00:02:42,874
и можем вычислить её значение.

43
00:02:42,874 --> 00:02:48,445
Правда, когда мы работаем с набором
из N объектов,

44
00:02:48,445 --> 00:02:52,300
есть операции, которые занимают время,
пропорциональное N.

45
00:02:52,300 --> 00:02:55,644
Так, например, если вы выделяете память
для массива размером N,

46
00:02:55,644 --> 00:03:00,314
это занимает время пропорциональное N,

47
00:03:00,314 --> 00:03:06,795
потому что в Java по умолчанию
всем элементам массива присваиваются нулевые значения.

48
00:03:06,795 --> 00:03:12,190
В других операциях всё зависит
от системной реализации.

49
00:03:12,190 --> 00:03:14,920
Важным случаем является соединение строк.

50
00:03:14,920 --> 00:03:17,110
Если вы соединяете две строки,

51
00:03:17,110 --> 00:03:21,240
время работы пропорционально длине строки.

52
00:03:21,240 --> 00:03:24,459
Начинающие программисты ошибаются,

53
00:03:24,459 --> 00:03:27,755
считая, что эта операция фиксированного
времени выполнения.

54
00:03:27,755 --> 00:03:30,910
А она такой не является.

55
00:03:30,910 --> 00:03:35,180
Это временные затраты на операции.

56
00:03:35,180 --> 00:03:41,990
Более интересна повторяемость
их выполнения.

57
00:03:41,990 --> 00:03:48,445
Вот очень простой вариант
3-SUM задачи - задача 1-SUM,

58
00:03:48,445 --> 00:03:50,610
которая заключается в определении того,

59
00:03:50,610 --> 00:03:53,285
сколько чисел при сложении дают 0.

60
00:03:53,285 --> 00:03:55,209
Таким образом,
задача содержит 1 цикл for,

61
00:03:55,209 --> 00:03:59,460
мы проходим по нему, проверяем, является ли число нулем
 и увеличиваем счетчик.

62
00:03:59,460 --> 00:04:02,560
Анализируя этот код,

63
00:04:02,560 --> 00:04:07,645
видно, что i и count
должны быть объявлены

64
00:04:07,645 --> 00:04:10,555
и приравнены к 0.

65
00:04:10,555 --> 00:04:14,563
Вот сравнение значений i и N,
а вот добавление единицы [к значению i ]

66
00:04:14,563 --> 00:04:16,748
Вот сравнение a[i] c нулём,

67
00:04:16,748 --> 00:04:19,534
и этих сравнений N штук,
N обращений к массиву.

68
00:04:19,534 --> 00:04:21,730
Увеличение счетчика

69
00:04:21,730 --> 00:04:25,380
является переменной.

70
00:04:25,380 --> 00:04:27,940
i увеличивается N раз,
но счетчик может быть

71
00:04:27,940 --> 00:04:31,465
увеличен на любое число от 0 до N.

72
00:04:31,465 --> 00:04:34,960
Таким образом,
частота этого события зависит

73
00:04:34,960 --> 00:04:39,755
от входных данных.
Может понадобиться модель для описания этой зависимости,

74
00:04:39,755 --> 00:04:42,055
или, может быть,

75
00:04:42,055 --> 00:04:47,135
в алгоритме найдутся другие, более затратные операции, и мы не будем беспокоиться об этой.

76
00:04:47,135 --> 00:04:50,830
Посмотрим на более сложную задачу.

77
00:04:50,830 --> 00:04:55,030
Что с повторяемостью операций
в этой программе,

78
00:04:55,030 --> 00:04:56,775
которая представляет задачу 2-SUM?

79
00:04:56,775 --> 00:05:00,149
Сколько пар целых чисел
в сумме дают ноль?

80
00:05:00,149 --> 00:05:06,640
Потребуется проделать немного вычислений, 
чтобы обнаружить,

81
00:05:06,640 --> 00:05:10,794
что при увеличении i от 0 до n,
а j от i+1 до n,

82
00:05:10,794 --> 00:05:14,075
число производимых сравнений

83
00:05:14,075 --> 00:05:16,825
или количество обращений к массиву

84
00:05:16,825 --> 00:05:23,956
равно двум, каждый раз,
когда вычисляется ai или aj.

85
00:05:23,956 --> 00:05:27,235
И этот оператор выполняется

86
00:05:27,235 --> 00:05:30,382
n-1 раз на первом проходе цикла,

87
00:05:30,382 --> 00:05:32,740
n-2 на втором, и так далее.

88
00:05:32,740 --> 00:05:38,500
Это сумма целых чисел от нуля до n-1,

89
00:05:38,500 --> 00:05:44,530
которая является дискретной суммой,
равной половине n(n-1), так как мы вычисляем её дважды,

90
00:05:44,530 --> 00:05:48,275
то количество обращений
к массиву равно n-1.

91
00:05:48,275 --> 00:05:52,615
Таким образом, мы можем продвигаться
и получать эти действительные точные значения.

92
00:05:52,615 --> 00:05:58,105
Но уже это становится несколько
утомительным занятием.

93
00:05:58,105 --> 00:06:01,713
Обратимся к Тьюрингу,

94
00:06:01,713 --> 00:06:05,060
который, как и Бэббидж, знал,

95
00:06:05,060 --> 00:06:09,556
что необходима мера для количества работы,
выполняемой процессом,

96
00:06:09,556 --> 00:06:15,810
он осознал, что нет необходимости
проводить все расчеты.

97
00:06:15,810 --> 00:06:18,925
Полезно иметь грубую оценку.

98
00:06:18,925 --> 00:06:22,330
Таким образом, вы можете высчитывать
повторяемость каждой операции,

99
00:06:22,330 --> 00:06:27,200
давать операциям веса и так далее.

100
00:06:27,200 --> 00:06:32,045
Возможно, стоит вычислять только
самые затратные операции.

101
00:06:32,045 --> 00:06:36,000
Об этом Тьюринг говорил в 1947 году.

102
00:06:36,000 --> 00:06:40,330
Сейчас мы делаем именно так.

103
00:06:40,330 --> 00:06:46,585
Вместо того,
чтобы рассчитывать все операции,

104
00:06:46,585 --> 00:06:50,415
мы определяем базовую операцию,

105
00:06:50,415 --> 00:06:56,920
которая является самой затратной,

106
00:06:56,920 --> 00:06:59,811
либо самой повторяемой,

107
00:06:59,811 --> 00:07:02,520
и по ней определяем время выполнения.

108
00:07:02,520 --> 00:07:05,040
Мы исходим из предположения,

109
00:07:05,040 --> 00:07:09,720
что время выполнения равно произведению
этого значения на некоторую константу.

110
00:07:09,720 --> 00:07:13,425
Так, для данного случая мы выберем
доступ к элементам массива.

111
00:07:13,425 --> 00:07:15,675
Это первое упрощение.

112
00:07:15,675 --> 00:07:17,640
А вторым упрощением будет то,

113
00:07:17,640 --> 00:07:22,174
что мы игнорируем члены
низшего порядка в формулах.

114
00:07:22,174 --> 00:07:24,355
Простой способ реализации

115
00:07:24,355 --> 00:07:27,610
называемый тильда-нотацией.

116
00:07:27,610 --> 00:07:29,610
Идея состоит в том,

117
00:07:29,610 --> 00:07:33,575
что при высоком значении N,

118
00:07:33,575 --> 00:07:39,615
значение n в кубе гораздо больше,
чем само N.

119
00:07:39,615 --> 00:07:45,990
Разница настолько велика,
что члены низкого порядка не влияют на результат.

120
00:07:45,990 --> 00:07:50,570
Получаем формулу: одна шестая
от N в кубе,

121
00:07:50,570 --> 00:07:56,824
это хорошее приближение.

122
00:07:56,824 --> 00:07:59,790
Мы существенно упростили вычисления,

123
00:07:59,790 --> 00:08:03,110
отбросив члены низкого порядка.

124
00:08:03,110 --> 00:08:09,528
Свели всё к одной операции.

125
00:08:09,528 --> 00:08:12,554
Вот техническое определение тильды:

126
00:08:12,554 --> 00:08:17,795
f(N)~g(N) значит,
что предел f(N) к g(N) равен 1.

127
00:08:17,795 --> 00:08:23,720
Можете проверить,
что условие соблюдается.

128
00:08:23,720 --> 00:08:28,225
Это сильно упрощает подсчет повторяемости.

129
00:08:28,225 --> 00:08:29,940
И если мы выбираем только одну операцию,

130
00:08:29,940 --> 00:08:33,540
то просто говорим о ~N квадрат,

131
00:08:33,540 --> 00:08:39,145
как в нахождении решения sum задачи.

132
00:08:39,145 --> 00:08:42,360
Это верно для большого значения N

133
00:08:42,360 --> 00:08:45,174
и не работает при малых значениях.

134
00:08:45,174 --> 00:08:49,080
Но это неважно, потому что нас
интересует время выполнения

135
00:08:49,080 --> 00:08:55,065
при больших значениях N,
а при малых значениях это время в любом случае невелико.

136
00:08:55,065 --> 00:08:57,600
Используя 

137
00:08:57,600 --> 00:09:03,299
модель затрат и приближение,
можем сказать,

138
00:09:03,299 --> 00:09:08,010
что программа обращается
к массиву ~N в квадрате раз,

139
00:09:08,010 --> 00:09:13,225
значит общее время выполнения равно
,по нашему предположению,

140
00:09:13,225 --> 00:09:16,870
N в квадрате,
умноженное на константу.

141
00:09:16,870 --> 00:09:18,815
Хорошо, что насчет задачи 3-SUM?

142
00:09:18,815 --> 00:09:21,240
Давайте решим реальную задачу.

143
00:09:21,240 --> 00:09:24,885
Теперь у нас тройной цикл,

144
00:09:24,885 --> 00:09:30,234
и значит нам надо решить
более сложную комбинаторную задачу,

145
00:09:30,234 --> 00:09:33,105
но это не так уж сложно.

146
00:09:33,105 --> 00:09:40,855
Мы ищем несовпадающие способы
выбора трех чисел из N,

147
00:09:40,855 --> 00:09:44,950
и это биномиальный коэффициент.

148
00:09:44,950 --> 00:09:48,149
Выполняя вычисления, вносим приближение

149
00:09:48,149 --> 00:09:52,950
и получаем 1/6 от N в кубе
обращений к массиву для одного числа.

150
00:09:52,950 --> 00:09:55,865
В итоге получается
N^3/3.

151
00:09:55,865 --> 00:10:02,520
Не вычисляем затраты на все операции —

152
00:10:02,520 --> 00:10:04,060
слишком много работы.

153
00:10:04,060 --> 00:10:07,860
Мы выбрали наиболее затратную по времени

154
00:10:07,860 --> 00:10:10,920
операцию и упростили её

155
00:10:10,920 --> 00:10:15,950
в попытке получить модель
для времени выполнения.

156
00:10:15,950 --> 00:10:22,480
В курсе мы не углубляемся
в дискретную математику.

157
00:10:22,480 --> 00:10:24,600
Но есть некоторые базовые вещи,

158
00:10:24,600 --> 00:10:31,705
необходимые нам и легкие для понимания.

159
00:10:31,705 --> 00:10:32,895
Очень часто

160
00:10:32,895 --> 00:10:35,850
нужно найти приближение

161
00:10:35,850 --> 00:10:39,754
дискретной суммы,
как мы делали для суммы 1+2+...+N,

162
00:10:39,754 --> 00:10:45,380
или тройного цикла в задаче 3-SUM.

163
00:10:45,380 --> 00:10:49,395
Если вы владеете основами вычислений,

164
00:10:49,395 --> 00:10:53,750
то можете заменить сумму
интервальным интегралом.

165
00:10:53,750 --> 00:10:56,850
Этого обычно достаточно,
или можно использовать

166
00:10:56,850 --> 00:11:01,860
формулу суммирования Эйлера-Маклорена
для получения правильной аппроксимации.

167
00:11:01,860 --> 00:11:03,450
Размышляя таким образом,

168
00:11:03,450 --> 00:11:08,759
вы придете к тому, что сумма равна N^2/2.

169
00:11:08,759 --> 00:11:13,230
Или, что сумма единица плюс одна вторая,
 плюс одна треть и до единицы, деленной на N,

170
00:11:13,230 --> 00:11:18,705
которая преобразуется к интегралу в границах от единицы до N,
 от единицы деленной на x, равна натуральному логарифму от N.

171
00:11:18,705 --> 00:11:21,510
Даже тройной цикл для 3-SUM,

172
00:11:21,510 --> 00:11:24,585
если есть опыт в интегралах,

173
00:11:24,585 --> 00:11:27,965
быстро сведется к N^3/6.

174
00:11:27,965 --> 00:11:33,035
Есть множество и других способов решения.

175
00:11:33,035 --> 00:11:34,830
Все мы рассматривать не будем.

176
00:11:34,830 --> 00:11:39,860
Но иногда будем на них ссылаться.

177
00:11:39,860 --> 00:11:42,390
Хорошо, по сути,

178
00:11:42,390 --> 00:11:47,335
Кнут рассказал нам, что точные
математические модели доступны.

179
00:11:47,335 --> 00:11:51,600
На практике, получаем сложные формулы.

180
00:11:51,600 --> 00:11:57,850
Иногда может потребоваться
продвинутая математика,

181
00:11:57,850 --> 00:12:00,490
которой не владеют

182
00:12:00,490 --> 00:12:05,260
люди, впервые столкнувшиеся с алгоритмами.

183
00:12:05,260 --> 00:12:07,825
И в конце,

184
00:12:07,825 --> 00:12:13,270
аккуратные точные модели
лучше оставить экспертам.

185
00:12:13,270 --> 00:12:16,100
В них слишком много деталей.

186
00:12:16,100 --> 00:12:21,260
С другой стороны,
приближенные модели определенно полезны.

187
00:12:21,260 --> 00:12:24,434
Для всех алгоритмов,
которые рассматриваем,

188
00:12:24,434 --> 00:12:26,410
мы будем пытаться подобрать

189
00:12:26,410 --> 00:12:32,575
подходящую приближенную модель
для описания времени работы.

190
00:12:32,575 --> 00:12:36,670
Иногда мы будем давать
математические доказательства,

191
00:12:36,670 --> 00:12:41,900
а иногда просто ссылаться
на работы экспертов.