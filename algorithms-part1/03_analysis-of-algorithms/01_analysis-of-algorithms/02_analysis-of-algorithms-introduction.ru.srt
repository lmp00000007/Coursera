1
00:00:02,000 --> 00:00:07,036
Приветствую! Обратимся к математическим вычислениям. 

2
00:00:07,036 --> 00:00:11,055
Нам необходимо знать основы для понимания работы 

3
00:00:11,055 --> 00:00:15,075
алгоритмов, чтобы должным образом применять их на практике. Сегодня мы будем говорить,

4
00:00:15,275 --> 00:00:20,040
о том, как узнать характеристики производительности алгоритмов. Посмотрим,

5
00:00:20,040 --> 00:00:25,022
как построить математическую модель алгоритма, а также как классифицировать алгоритмы относительно 

6
00:00:25,022 --> 00:00:30,010
роста времени их выполнения. Немного поговорим о теории алгоритмов,

7
00:00:30,010 --> 00:00:35,790
а также об анализе количества используемой памяти.

8
00:00:35,790 --> 00:00:42,206
Мы обсудим данные проблемы с точки зрения различных персонажей.

9
00:00:42,206 --> 00:00:48,139
Первый из них - программист, которому требуется найти решение 

10
00:00:48,139 --> 00:00:54,270
и заставить его работать. Второй - клиент,

11
00:00:54,270 --> 00:01:00,167
который воспользуется любой программой, чтобы завершить работу. Третий — теоретик,

12
00:01:00,167 --> 00:01:06,424
который хочет понять, как все на самом деле работает.

13
00:01:06,424 --> 00:01:10,724
Наконец, команда с базовыми фундаментальными знаниями, которые бывают необходимы

14
00:01:10,724 --> 00:01:15,790
для всей остальной работы. И понемногу будет от каждого

15
00:01:15,790 --> 00:01:21,110
в сегодняшней лекции. Во время 
обучения вам нужно быть готовым

16
00:01:21,110 --> 00:01:26,753
однажды сыграть одну из этих ролей
или даже их все. Очень важно

17
00:01:26,753 --> 00:01:31,522
понимать различные точки зрения. Ключевой момент

18
00:01:31,522 --> 00:01:38,205
на котором мы сфокусируемся - время выполнения. На самом деле идея понимания времени выполнения

19
00:01:38,205 --> 00:01:44,017
вычислений уходит во времени к Бэббиджу и вероятно даже ранее. И вот

20
00:01:44,017 --> 00:01:48,083
цитата Бэббиджа "Как только появится Аналитическая Машина, она 

21
00:01:48,083 --> 00:01:54,076
непремено задаст будущее развитие науки. Какой бы результат не искали с ее

22
00:01:54,076 --> 00:02:00,062
помощью, возникнет вопрос как организовать вычисления, чтобы получить

23
00:02:00,062 --> 00:02:06,072
результат за кратчайшие сроки. Если вы посмотрите на машину Бэббиджа,

24
00:02:06,072 --> 00:02:12,009
называемую аналитической, у нее есть рычаг. И Бэббиджа очень

25
00:02:12,009 --> 00:02:17,060
волновало, как долго будет производиться вычисление,

26
00:02:17,060 --> 00:02:23,048
то есть сколько раз нужно повернуть рычаг. И это не сильно отличается от того, что есть сегодня.

27
00:02:23,048 --> 00:02:29,018
Рычагом может быть что-то электронное, переключающееся миллиард раз в секунду.

28
00:02:29,018 --> 00:02:34,041
Но все так же мы ищем, как много раз некоторая операция должна быть

29
00:02:34,041 --> 00:02:39,093
произведена для того, чтобы вычисление было завершено. Есть много причин

30
00:02:39,093 --> 00:02:45,032
анализировать алгоритмы. В контексте этого курса мы в основном заинтересованы

31
00:02:45,032 --> 00:02:50,051
в предсказании производительности. Также мы хотим сравнить производительность различных

32
00:02:50,051 --> 00:02:54,768
алгоритмов при решении одной и той же задачи и быть способными предоставить некоторые гарантии того,

33
00:02:54,768 --> 00:03:00,058
как они будут выполняться. Это понимание некоторых теоретических основ того,

34
00:03:00,077 --> 00:03:05,780
как алгоритмы выполняются. Но в первую очередь, необходимость

35
00:03:06,024 --> 00:03:11,098
анализировать алгоритмы и понимать их обусловлена желанием избежать низкой производительности. Мы хотим

36
00:03:11,098 --> 00:03:16,050
быть уверены, что наши алгоритмы завершат работу

37
00:03:16,050 --> 00:03:21,084
за то время, что мы ожидаем. Очень часто можно видеть

38
00:03:21,084 --> 00:03:26,080
в сегодняшних вычислениях, что клиент получает плохую

39
00:03:26,080 --> 00:03:31,026
производительность, потому что программист не понял производительные

40
00:03:31,026 --> 00:03:36,086
характеристики алгоритма. И в сегодняшней лекции мы постараемся

41
00:03:36,086 --> 00:03:42,087
избежать этого. Мы сконцентрируемся на производительности и сравнении алгоритмов.

42
00:03:42,087 --> 00:03:48,064
Есть и другие курсы в стандартном учебном плане по компьютерным наукам,

43
00:03:48,064 --> 00:03:53,093
которые содержат больше информации о теоретическом базисе алгоритмов,

44
00:03:53,093 --> 00:03:59,090
расскажу о них немного позже. Но наша цель - сфокусироваться на возможности предсказания

45
00:03:59,090 --> 00:04:07,007
производительности и сравнении алгоритмов. Существует много успешных примеров

46
00:04:07,030 --> 00:04:12,081
разработки алгоритмов с лучшей производительностью, позволяющих решать

47
00:04:12,081 --> 00:04:19,025
задачи, которые иначе не могли быть решены. Я просто приведу пару 

48
00:04:19,025 --> 00:04:25,346
примеров. Один из первых и наиболее известных — алгоритм БПФ. Этот

49
00:04:25,346 --> 00:04:32,057
алгоритм для разбиения волны от n источников сигнала в периодические

50
00:04:32,057 --> 00:04:38,431
компоненты. И это основа для DVD и JPEG и многих других приложений.

51
00:04:38,431 --> 00:04:44,296
Есть простой способ решения, который занимает время пропорциональное N^2.

52
00:04:44,296 --> 00:04:49,080
А алгоритм БПФ занимает только NlogN шагов. И разница между NlogN

53
00:04:49,080 --> 00:04:55,002
и N^2 — это разница между возможностью решить огромные задачи 

54
00:04:55,002 --> 00:04:59,078
и ее отсутствием. Множество цифровых технологий, цифровых медиа

55
00:04:59,078 --> 00:05:04,822
технологий, что мы имеет сегодня возможны благодаря быстрому алгоритму. Другой пример

56
00:05:05,051 --> 00:05:11,232
был разработан Эндрю Аппелом, нынешним главой кафедры компьютерных наук 

57
00:05:11,232 --> 00:05:16,582
в Принстоне. Он придумал его, когда работал

58
00:05:16,582 --> 00:05:22,725
над дипломом. Это алгоритм для моделирования задачи N тел. Простой

59
00:05:22,725 --> 00:05:28,548
алгоритм занимает время пропорциональное N^2, но алгоритм Аппеля был NlogN

60
00:05:28,548 --> 00:05:33,452
алгоритмом, то есть ученые могли делать моделирование N тел 

61
00:05:33,452 --> 00:05:41,478
для больших значений N. Что сделало возможным новые исследования. Итак задача, которую мы 

62
00:05:41,478 --> 00:05:47,677
обычно встречаем, это будет ли моя программа решать большие задачи.

63
00:05:47,677 --> 00:05:52,024
Программисты сталкиваются с этим все время.

64
00:05:52,024 --> 00:05:58,001
Почему моя программа работает так медленно? Почему ей не хватает памяти? И с этим

65
00:05:58,001 --> 00:06:05,000
программисты сталкиваются уже долгое время. Канут предложил

66
00:06:05,000 --> 00:06:10,030
использовать научный подход для понимания

67
00:06:10,030 --> 00:06:16,062
производительности алгоритмов в 1970 году. Мы не открыли

68
00:06:16,062 --> 00:06:23,010
новый секрет Вселенной, но стали использовать научный метод, и относиться

69
00:06:23,010 --> 00:06:29,042
к компьютерам, как к чему-то что может быть изучено и прийти к пониманию

70
00:06:29,042 --> 00:06:34,008
того, как наша программа будет исполнятся. Разберем подробнее.

71
00:06:34,209 --> 00:06:39,063
Это лишь обзор того, что мы понимаем под научным методом, который был

72
00:06:39,268 --> 00:06:44,086
успешным несколько последних сотен лет. Мы будем

73
00:06:44,086 --> 00:06:50,008
наблюдать за некоторыми особенностями окружающего мира. В нашем случае

74
00:06:50,008 --> 00:06:54,857
за временем работы компьютера. Затем разработаем гипотезу,

75
00:06:55,049 --> 00:06:59,079
модель, которая согласовывается с наблюдениями, и будем надеяться,

76
00:06:59,079 --> 00:07:04,040
что гипотеза достаточно хороша и позволит сделать предсказания.

77
00:07:04,040 --> 00:07:09,031
Обычно предсказывается время работы для задачи большого размера, или на разных компьютерах.

78
00:07:09,197 --> 00:07:13,097
И затем мы проверяем предсказания, делая еще больше наблюдений, до тех пор

79
00:07:13,097 --> 00:07:18,058
пока не удостоверимся, что наша модель и наблюдения согласованны. 

80
00:07:18,058 --> 00:07:22,077
Таким способом можно определить производительность

81
00:07:22,077 --> 00:07:28,056
программы. У научного метода есть некоторые базовые принципы:

82
00:07:28,056 --> 00:07:33,082
1) если вы проводите эксперимент, то ожидается,

83
00:07:33,082 --> 00:07:39,021
что другой человек сможет провести такой же эксперимент и получит тот же результат;

84
00:07:39,021 --> 00:07:44,067
2) гипотез должна иметь свойства того, что эксперименты могут показать 

85
00:07:44,067 --> 00:07:49,736
ее ошибочность. Она должны быть аккуратно составлена, и мы должны обязательно

86
00:07:49,736 --> 00:07:55,433
пробовать сделать это. Будущее мира природы,

87
00:07:55,433 --> 00:08:00,822
который мы изучаем, это компьютер, существующий внутри этого мира.

88
00:08:00,822 --> 00:08:07,049
Алгоритмы в таком случае от абстракции становятся физическими явлениями,

89
00:08:07,049 --> 00:08:11,083
подобно движению электронов в компьютере.