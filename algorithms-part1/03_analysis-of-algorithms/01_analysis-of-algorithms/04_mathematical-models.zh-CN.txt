像上一节中观察发生了什么让我们能够 对性能做出预测，但是并不能帮助我们理解算法做了什么 接下来，我们来看看数学模型，更利于我们把握 到底发生了什么。再提一次，这个概念是 Don Knuth在二十世纪60年代末提出并推广的。那时，计算机系统 才第一次真正变得复杂。而计算机科学家 关心的是我们是否真的能够理解到底发生了什么 Knuth很直接地回答了我们当然能 我们可以通过识别所有的基本操作计算出 程序总的运行时间，计算出操作的开销，计算出 操作执行的频率，并将所有的操作的开销乘以频率求和 你必须分析程序才能决定执行了哪些操作 以及我们之前说过的依赖于计算机和系统的开销 频率分析将我们引向数学因为它依赖于 算法和输入。Knuth写了一系列书，对很多算法 在特定的计算机模型下进行了非常细致和准确的分析 所以从Knuth的工作中可以得知，原则上我们能够获得 算法、程序或者操作的性能的精确数学模型 好，那这个过程是什么样的？额，如果你想运行实验，也是可以的 在很早的时候，我们可能真的会去查计算机手册 每个计算机都配有手册，上面准确地写着每个指令需要多长时间 现在，这个问题变得更复杂了。所以我们运行实验 你可以做十亿次加法然后可能能算出你的计算机上 一次加法需要2.1纳秒。或者你可以执行更复杂的函数 比如计算正弦或者反正切，虽然这已经和算法分析 很接近了。所以，我们办法有确定基本操作 的开销。所以绝大多是情况下我们只要 假定它是某个常数，而且你也能得知那个常数是多少 虽然当我们处理一组对象时，N个对象 有一些操作需要的时间是和N成正比的，比如你要 分配一个大小为N的数组，需要正比于N的时间，因为在Java中 默认把数组中的每个元素初始化为0。其他操作 取决于系统的实现。比如连接字符串是一个重要的操作 如果连接两个字符串，运行时间 与字符串的长度成正比。很多新手使用Java编程时 错把连接字符串当作是常数时间的操作，而实际上并不是 好，这就是每个操作的开销。更有意思的是操作的频率 操作执行的频率。这是3-SUM问题的一个简单 变体，是一个1-SUM问题。有几个数 等于0？多少单个数之和为0？所以这个问题里只有 1个for循环。for循环中我们检查数字是否为0，是的话就把count值 增加1。通过分析代码你会看到i和count必须先声明 然后赋值为0。比较i和N的操作有 N+1个。比较a[i]和0的操作有N个 有N次数组访问。count值增加的次数是可变的 i增加了N次，但是count可能增加了从0到N次之间 任意次数。所以这个次数取决于输入。或者我们需要 模型来描述这个，或者也许有其他的操作开销更大 所以我们不需要操心这个。接下来我们来看一个 更复杂的问题这个程序中执行指令的次数 现在是2-SUM问题。多少个整数对和为0？ 这个情况中，你需要做一些计算 i 从 1 变到 N，j 从 i+1 变到 N 我们做的比较的次数 每次if语句对 a[i] 和 a[j] 执行的时候 访问了两次数组 这个if语句执行了第一次循环执行了N-1次 第二次循环执行了N-2次等等。这个次数是 从0到 N-1 的整数之和，这是个简单的离散求和，N(N-1)/2 因为每个if语句访问两次数组所以需要访问 N(N-1) 次 所以我们可以算出这些精确的次数。但这么做已经有点 繁琐了。图灵早就知道了这一点 巴贝奇也知道，我们想要测量计算过程中的工作量 他发现我们并不想列出所有细节 粗略的估计依然很有用。可以对 每个才做的执行次数计数，赋以权重，并 算出精确的值，但也许只需要对开销最大的操作计数就可以了 这就是图灵在1947年提出的。实际上我们现在就是这么做的 所以与其钻到程序里，然后统计每个小细节，我们选出 开销最大的基本操作或者执行次数最多的 用开销最大频率最高的操作来代表 执行时间。一般，我们假设实际的运行时间 就是常数乘以这个操作的执行时间。所以这个例子中，我们 选择访问数组作为代表。这是第一个简化。第二个 简化是忽略推导出的式子中的低阶项 用这种波浪号可以很容易实现 这种简化的思想就是当式子中的N很大时，N^3 N这一项或者 16 要大得多。实际上，大到几乎 注意不到低阶项。所以这些式子近似为 1/6 N^3，这是对这些量很好的近似 所以丢掉这些低阶项极大地简化了计算 所以专注于一种操作，丢掉低阶项 这是波浪号的具体严格定义 F(N)近似为G(N)意味着F(N)/G(N)的极限等于1 你可以检查一下上面这些情况是满足这个定义的 这极大地简化了统计频率。刚才我们将~N^2时选了 一种操作，对2-SUM问题选择增加操作可能会得到另一个N^2近似 好，所以当N很大时，低阶项是可以忽略的 N很小时，低阶项是不能忽略的。不过我们不是很关心 因为我们想要对于大N估计运行时间，小N的运行时间本来就不长 好，我们用了开销模型和 波浪记号，使得我们能简单说这个程序需要近似N^2 次数组访问，并暗示了我们认为运行时间 将近似于常数乘以N^2的假设。好，3-SUM呢？ 我们来处理一下这个问题。我们有三重循环 我们需要解决一个更复杂的组合数学问题，但这不难 我们要求的是从N个对象中选出三个的方法 这是个二项式系数。就这样又做了计算，然后应用近似 它近似为1/6 N^3 每个三整数组访问数组三次 那么就是1/2 N^3。我们不会计算所有操作的开销 这太麻烦了。我们选出开销最大的操作乘上频率 并作出近似来试图为运行时间建立一个好模型 这门课中我们不会教完整的离散数学 但有一些我们想要用的离散数学基础知识，它们并不难理解 很多时候我们需要估计一个离散求和 像我们做过的从1到N的求和，或者平方的求和 或者其他比如三重循环这样的。实际上，如果你学过 微积分基础，可以将求和替换为积分 这通常是管用的，我们做一些计算然后应用 欧拉-麦克劳林求和公式来得到真正的近似。如果 你这么考虑就会相信这个式子近似于1/2 N^2 1 、1/2、1/3 一直到 1/N 的和类似于 x 从 1 到 N 对 1/x 积分，等于 N 的自然对数。即使3-SUM问题中的三重循环 如果你熟悉多重积分的话，我直接给出答案，就等于1/6 N^3 求解这些式子还有很多其他的技巧，但是 我们这门课不讲这些，我们有时直接使用这样的结论 好，总的来说，Knuth告诉我们实际上是能获得 精确的数学模型的，我们也确实能得到复杂的式子，我们可能需要 更高级的数学知识，这是理论家擅长的 但对于刚接触算法的人可能并不懂得这些 所以精确的模型最好还是留给那些专家 确实有很多东西值得研究。另一方面近似模型 绝对是有价值的。对于我们涉及的所有算法 我们都会试着用合适的近似模型来描述运行时间 有时我们会给出数学证明，其他时候 我们只是引用专家的工作