幸运的是，分析算法时我们不会遇到太多 各不相同的函数，这使得我们可以将算法按照性能 随问题大小变化而分类。这就是我们接下来要讲的东西。 所以好消息是，与我们感兴趣的算法 相关的只有少数几个函数。我们也可以构造一些算法 其性能表现为其他的函数，是有反例的。不过我们考虑的 算法中非常多都能被这里画出的几个函数所描述 当我们谈到增长阶数时 我们不讨论前面的常数。一般如果我们说 一个算法的运行时间和 N log N 成正比，意味着 我们提出的假设就是运行时间近似为 c N log N 其中 c 是某个常数。在这些双对数坐标图表上 可以很明白地看到：如果增长阶数是对数或者 常数的。无论问题的规模多大，这些算法都很快 如果问题规模是一千的时候运行时间是 T，对于五十万运行时间也会非常接近T 如果是线性的，也就是说增长阶数和 N 成正比，则运行时间 随着问题规模增大而线性增长。如果是 N log N 的话，差不多也是一样的。以上这些算法就是我们努力想要设计出来的 它们能够成比例适应问题的规模。当输入变大时，运行时间一样也会变长 这是合理的情形。讲并查集的时候我们谈过这个 如果增长阶数是平方阶的，运行时间增长速度 远快于输入大小，就不能将这样的算法用于庞大的 输入。立方阶的算法性能就更糟了。所以我们研究算法时首先 要确保算法不是平方阶或者立方阶的。而这些 增长阶数类型实际上就源于我们写的代码中的某些简单模式 如果代码中没有循环，增长阶数是常数 如果有某种循环，每次循环输入被 分成两半，二叉搜索算法就是一个例子 增长阶数就是对数的，一会我们来看一下它的分析 如果做之前将输入翻倍的测试，运行时间的增长几乎是线性的（教授这里口误，应该是常数）。如果输入非常大 并将输入翻倍，增加的运行时间仍然是，抱歉，不是线性的 是常数的。几乎很难注意到 log N 的存在 如果循环遍历了输入中的所有对象，运行时间是 线性的，与 N 成正比。典型的例子就是找最大值 或者统计0的个数，也就是我们的1-SUM问题 N log N 是一个很有意思的分类，线性对数阶算法 这样的时间复杂度源于一种特定的算法设计技巧叫做 分治法。比如我们几周内就会讲到的归并排序 就是非常典型的例子。如果算法中有双重for 循环，比如之前的2-SUM算法，运行时间和 N^2 成正比 我们已经见过了，是二次的。如果有我们 3-SUM 算法中的三重for循环 运行时间就是立方阶的，与 N^3 成正比。对于平方阶 算法，输入翻倍后运行时间增大到4倍 对于立方阶算法运行时间会增大到8倍 这些在等待程序运行你就能心算出来了 还有一类算法，运行时间是指数阶的 这些算法中N不会非常大，在第二部分课程的结尾我们 会讲到这类算法。这里我们来看一下增长阶数的现实意义 关于这个我们不会详细讲太多，除非是我们 非常感兴趣的算法，那些线性和线性对数阶的能够解决 巨大规模的问题的算法。因为即使 现在一般的比较快的计算机能处理的平方阶问题的规模 大约也只有几万，对于立方阶问题只有几千。而近年来 这些算法并没有什么用，因为我们获得的数据的量更大，比如上百万 十亿或者上万亿。随着时代的发展这个问题变得 越来越明显。早期时候还有一些讨论平方阶算法 是否有用，随着时间发展情况越来越严峻 所以我们需要更好的算法。为了展示 描述算法性能的数学模型的建立过程，我们来看一个 大家很熟悉的例子，二叉搜索。这个算法的目标是，给定 一个有序整数数组并给定一个值，想要知道这个值在数组中 是否存在。如果存在，它在什么位置？我们知道的能处理这个问题的 一种快速的算法是二叉搜索，我们将给定值和位于中间的条目比较 例如，我们找33，和53比较 33比53小，所以应该在数组的左半边。如果给定值更大 则知道应该在数组的右半边。如果相等，那么我们就找到了那个条目 然后递归使用同样的算法。我们来很快地看一下演示 我们要在这个数组中寻找33，将它和数组中间的条目53比较 33比53小所以往左边继续找，现在我们可以将注意力集中在数组左半边 查看这半边的中间，是25，33更大，所以我们到右边继续找 现在集中在原数组左侧的右半边 我们有了一个更小的子数组。查看中间的条目，33更小，向左边走 现在只剩下一个元素了，我们在数组中找到了33这个元素，返回 它的索引：4。如果要找的给定值不在数组中 进行的是同样的过程。比如，我们要找34，过程是一样的 先看左半边，然后看右半边，再看43的左半边。现在只剩下一个 条目了，并不是34。所以我们说34不在数组中。这就是二叉 搜索。这是二叉搜索的代码。实际上，虽然二叉搜索 是个简单的算法，却是众人皆知很难把每个细节实现正确的 实际上，有一篇文章指出，知道1962年才发表了第一个没有错误的二叉搜索算法 甚至到了2006年，依然从二叉搜索的Java实现中还找到了一个错误 这只是举例说明一下在开发算法是我们需要极其小心 尤其是上百万人要使用的库中的实现。这里是 一种实现。虽然我们能以递归的形式实现但这种实现不是递归的 这段代码直接对应我之前描述工作流程 要在一个数组中找到一个关键字，我们使用两个指针，下限 lo 和上限 hi 来表示数组中我们感兴趣的部分。只要lo 小于等于 hi 时 我们计算中间值 mid，然后将关键字与中间值比较 这其实是一个三向比较，判断是小于、大于还是等于 如果关键字与中间值相等，返回中间值。如果小于中间值，则重新设置hi 指针 如果大于中间值，重新设置 lo 指针。继续循环直到两个指针相等 如果两个指针已经相等，还没有找到关键字，则返回-1。考虑这个 这个不变式就容易理解这个算法是能行得通的： 如果数组中存在要寻找关键字，则它在 lo 和 hi 之间的子数组中 好的，这个程序你可能已经熟悉了 我们来看它的数学分析。下面这个定理很容易证明 这门课中我们不会做非常多的证明，但这个值得证一下 那么这个定理是在大小为N的有序数组中完成一次二叉搜索 最多需要 1 + lg N 次比较。我们首先将问题明确一下，定义 变量T(N)，表示对于大小为N的数组进行二叉搜素所需要的比较次数 然后根据代码写出对应的递推关系式 程序将问题一分为二，那么 如果T(N)小于等于T(N/2)加上，这一项取决于你怎么对比较计数 我们把它看作是二向比较，分成两半需要进行一次比较 只要N大于1，这个递推关系就是成立的。当N为1时 T(1)等于1。这就是描述这个计算过程的递推关系 我们通过将递推关系代入 右边第一项来求解，这叫裂项求和 所以如果这个式子成立，我们就能对T(N/2)用这个式子，提出另一个1 对T(N/4)继续使用这个式子，又提出一个1 如此操作，直到N=1，这时我们提出了lg N个1 这是一个证明提纲，你可能注意到了，这个证明 只在N是2的幂时才成立。因为我们并没有在这个递推关系中明确 如果N是奇数这个式子是什么意思。但是继续推导，将奇数的情形 考虑进来也是可以的，并且能够证明二叉搜索的运行时间 总是对数阶的。好，基于这个事实，我们可以为3-SUM问题设计一个 更快的算法，一种基于搜索的算法 将输入中的数进行排序 下周我们讨论排序算法。排序需要正比于 N lg N的时间完成，不过这不是计算的主要部分。主要部分是 数字完成排序之后，查看每对数字 a[i]和a[j]。对-(a[i]+a[j])进行二叉搜索。如果找得到 则我们有了一组三整数其和为0。我们对数字排序，并检查 每一对数，检查是否存在其和的负数。-40，0 取反是40，二叉搜索，找到了，那么就得到了3-SUM问题 其中一个解。对每一对数如此操作。简单分析一下 运行时间增长阶数，是N^2 lg N。并不需要 非常好的搜索算法，可以用最基本的插入排序，我们会讲到的第一个排序算法 但是对于每一对数进行二叉搜索的运行时间 对N^2或者N^2/2对进行二叉搜索 得到N^2 lg N的运行时间。下面简单举例如何改进性能 N很大时，N^2 lg N 比 N^3 小得多 我们同时也提出了假设，如果按照这个基于排序的 算法处理并使用二叉搜索，我们将有一个更快的程序 当然我们可以做一些实验，可以发现 为了求解8000个数的问题，之前的算法需要50s 现在已经不到1s了。50s我们可以求解大到64000的问题了 所以一般我们期望更好的增长阶数意味着程序在实际运行中更快 不过当检验具体的算法时，我们可以 通过测试发现哪个算法更快。当然 增长阶数由N^3变为N^2 lg N，我们期望算法比之前 好得多了