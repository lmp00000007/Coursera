欢迎回来。今天我们将要做一些
数学和科学。不是很多，但是我们· 需要有一个科学的基础
来理解我们算法的性能 从而合理地在实战中使用它们。
所以今天我们要讲 关于如何观察算法的性能特点 我们将会看一下怎样建立数学模型
以及 如何根据算法的运行时间的增长阶数来对其分类
我们会探讨到关于算法理论 和如何分析内存使用的一点知识
总的来说， 我们将要从多种不同的角色来思考这些问题 第一个角色是程序员, 他需要解决一个问题 让算法能够工作，并部署它。第二个角色是用户，他想要 完成某项工作，但不关心程序做了什么。第三个角色是理论家 他真的想要理解发生的事情。最后一个角色 是一个团队，团队中的基本工作有时需要 完成以上所有的工作。所以，今天的课程中每一种角色的工作 都会出现一些。实际上，你还是个学生时，你必须想到 某一天你将会扮演这里任何一种甚至所有的角色。所以 理解不同的观点是相当重要的。那么，我们将要集中考虑的关键 就是运行时间。实际上要理解计算时间的想法可以 追溯到巴贝奇，甚至更早 巴贝奇说过：“一旦分析机被造出来，它必然将 指导科学的未来行程。无论用它帮忙寻找什么结果 都一定会面临使用什么计算方法才能让这个机器 在最短的时间内算出结果的问题。”如果你仔细看看巴贝奇 的分析机，会发现它有一个把手。巴贝奇事实上所关心 的计算时间，就是必须转动把手的次数 当今世界并没有太大的不同 把手变成了某个电子器件，每秒钟工作十亿次。但 我们依然想知道为了完成一项计算我们需要进行 多少次操作。所以有各种原因要求我们分析算法 这门课的内容中我们主要关心 预测算法的性能，我们还想要比较完成同一任务不同 算法的性能，并能得知在最坏情况下算法性能的底线 同时，我们需要理解关于算法如何运行的一些理论基础 但是首先，我们想要分析并理解算法的很实际的原因是 为了避免性能错误。我们想 对我们的算法在一定时间内完成任务有一些自信 在今天的计算基础设施中常常能看到 因为程序员没有理解算法的性能特征导致 客户端的性能很差 今天这堂课就是要避免这种情况出现 这门课中我们将会重点关注性能和比较不同的算法 在典型计算机科学课程安排中后续会有 更多关于算法理论基础的内容 一会我会稍微提一下。但是我们重点放在获得预测 和比较算法性能的能力。现在我们能列出很多通过 设计更优性能的算法以解决原先不能解决的问题 的成功案例。我这里只给出几个例子 第一个也是最著名的就是FFT（快速傅立叶变换）算法 这个算法将信号的N个采样波形分为若干周期分量 这是DVD和JPEG以及很多其他应用的基础 有一个简单的方法需要正比于N^2的时间 但是FFT算法只需要N log N 步。N log N 和 N^2的区别就是能否求解大型问题 这个快速算法使得我们今天 很多数字媒体技术成为可能。另一个例子 实际上是Andrew Appel开发的，他现在是普林斯顿的计算机科学 系主任。他还是本科生时做毕业论文的时候设计了这个算法 这个算法能够快速求解N体仿真问题 简单算法需要正比于N^2的时间，而Appel的算法是 N log N 级别的算法。这意味着科学家能够运行巨大N值的N体仿真 这个算法催生了新的研究。所以，我们常常面临的挑战是 我的程序能否求解实际中大型输入？而实际上 在工作中程序员时刻都在面临着这个挑战 为什么我的程序运行得这么慢？为什么它耗尽了内存？ 为了处理这些问题程序员花费了大量时间，绞尽脑汁 Knuth在1970年代的工作显示我们确实可以使用科学方法 来理解运行中算法的性能。也许我们没有在破解 宇宙新的奥秘，但是我们可以使用科学方法 来研究计算机，并理解 我们的程序是如何运行的。接下来我们详细讲一下 这只是我们提到的科学方法的一个简短的概括 到现在科学方法已经被成功使用了几个世纪。
所以我们要做的是 从自然界中观察某些特征。对我们来说，就是 程序在计算机上的运行时间。然后我们要提出假设 一些与观察到的现象相一致的模型，而且我们希望 假设是合理的并且能够让我们做一些预测 一般用来预测更大问题规模或者另一台计算机上的运行时间 接下来我们会做更多的观察来验证预测，直到 我们的模型假设和观察都吻合，
证实我们的模型假设是正确的 这是一种理解程序性能的方法 使用科学方法，有一些基本原则 第一，如果要做实验，你应该期望 别人做同样的实验也能有相同的结果 而假设必须具有某个特殊的性质，它能被实验 证伪。所以提出假设必须小心谨慎 我们一定会尽力完成。又说到了
我们研究的自然界的特征 是自然界中存在的某些特定的计算机 它将算法从抽象的事物变成类似计算机中奔腾的电子 的某种实际的物理对象