Hasta ahora, hemos estado habando de tiempos de proceso. Ahora debemos hablar también acerca de los requerimientos de memoria de nuestros programas. Bien, basicamente queremos saber cuántos bits, o cuantos bytes (grupos de 8 bits) usa el programa. Y realmente estaremos hablando en términos de millones o billones de bits y sorprendentemente hay una controversia aún sobre estas definiciones básicas. Los científicos de la computación piensan que un millón de bits es 2 a la 20 y que un billón de bits es 2 a la 30 porque esa es la cantidad de cosas posibles que se pueden incluir en 30 bits, y todo es consistente con nuestros cálculos. Otros científicos suscriben la idea de un millón o un billón por muchas razones usualmente vamos a utilizar 2 a la 20, quiero decir, un megabyte. Ahora y en viejas computadoras que utilizamos por muchos años, utilizamos máquinas de 32 bits, de modo que los punteros eran de cuatro bytes. Recién en los últimos años hemos migrado mayoritariamente a un modelo en el cual las máquinas son de 64 bits y los punteros son de 8 bytes. Esto nos permite direccionar mucha más memoria pero los punteros usan mucho más espacio y efectivamente esta transición causó muchos problemas inicialmente porque los programas usaban mucho más espacio de lo que la gente pensaba que deberían. Ustedes no tendrán que atravesar esta clase de transición del modo que nosotros lo hicimos porque 64 bits son definitivamente suficientes para direccionar cualquier cosa que ustedes pudieran necesitar direccionar, 2 a la 64 es realmente un número inmenso. De modo que en términos de bytes tenemos que comenzar con un uso de memoria típico. Ahora nuevamente, esto es muy dependiente de la máquina y de la implementación, pero estos números son razonables y se encuentran en las implementaciones típicas. Así, un campo lógico o booleano, sería bueno que tomara sólo un bit porque es sólo verdadero o falso, pero realmente usualmente necesitamos un byte para un booleano. Todo byte ocupa un byte. Un caracter hoy en día ocupa dos bytes, es decir caracteres de 16 bits. No hace mucho utilizábamos 8 bits para los caracteres. Los enteros comunes ocupan cuatro bytes o 32 bits y un flotante también ocupa cuatro bytes; un entero de tipo largo (long int) ocupa ocho y un doble (doble precisión) ocupa ocho. Usualmente utilizamos los tipo doble (double) para punto flotante y los tipo int para los enteros en la mayoría de las aplicaciones. Así que, esto es para los tipos primitivos. Y luego para los arreglos hay una cierta cantidad de sobrecarga para crear un arreglo y entonces si hay n items, es n veces el costo que tenga el tipo primitivo, de modo que un arreglo de tipos doble va a ocupar digamos 8n + 24. Y un arreglo de dos dimensiones bien, podemos avanzar y calcular la cosa exacta pero ahora, ahora es tiempo de usar la notación con tilde. Y entonces para arreglos podríamos decir que un doble es tilde 8n para uni-dimensional. Para bi-dimensional, un arreglo bi-dimensional de dobles ocupa tilde 8mn. Y hay términos adicionales para el desperdicio pero m y n van a ser por mucho suficientemente precisos. Así que esa es nuestra ocupación básica para los tipos primitivos y los arreglos en una implementación típica de Java. Ahora, un montón de nuestros programas y objetos como listas encadenadas y cosas así. Entonces tenemos también que considerar en la sobrecarga de objetos a las referencias cruzadas y también hay relleno incluído en las implementaciones típicas para lograr que cada objeto use múltiplos de ocho bytes. De modo que, por ejemplo si tienes un objeto fecha que tiene tres variables enteras (tipo int) instanciadas, entonces ese objeto podría tomar un total de 32 bytes. Cada entero toma cuatro bytes, el desperdicio del objeto es de dieciseis bytes. Necesita cuatro bytes de relleno de modo que son un total de 32 bytes. Lo otro que a menudo aparece son las cadenas (strings) y las cadenas son un poquito más complicadas que los arreglos pero la implementación típica de una cadena en Java tiene una referencia a un arreglo de caracteres y entonces, tiene valores enteros para el valor del desplazamiento en un valor de hash y también algo de relleno y sumando todo [tos] el costo de una cadena es aproximadamente 2n + 64 bytes. De modo que esto es lo básico que necesitamos para analizar el uso de memoria para un programa de Java típico. Así para los tipos de dato primitivos, si es un tipo primitivo son cuatro para un entero, y ocho para un doble, y así. Si es un referencia, van a ser ocho bytes y el puntero al arreglo requiere 24 bytes más la memoria para cada entrada, en un objeto dieciseis bytes más la memoria para las variables instanciadas más, si hay una clase interna,  son otros ocho bytes como dijimos para los nodos de las listas encadenadas. Y tambien hay relleno. Entonces tenemos que pensar quién es responsable por los objetos referenciados, saben, en algunos casos. Y vamos a ocuparnos de eso cuando lleguemos a estas situaciones. Así, como un ejemplo, un ejemplo simple de análisis de uso de memoria, echemos una mirada a cuánta memoria está estimada la función UF de unión rápida de hace algunas clases, que usa en función de n. Y hay sólo un par de elementos de memoria y cada uno de ellos es facilmente analizado utilizando lo básico que vimos recién, es un objeto asi que dieciseis bytes de sobrecarga, hay dos arreglos de enteros. Cada uno de ellos tiene un sobrecarga del arreglo de 24 más y luego 4n por las n entradas. Y vn entradas toman cuatro bytes y hay 4 bytes para la cantidad y hay cuatro bytes de relleno y si suman todo resulta 8n + 88 lo cual es tilde 8n y otra vez, todo lo que decimos es que cuando n es grande, lo único que nos importa en términos de analizar la memoria es que tenemos [tos] 2n enteros, dos arreglos de tamaño n cada uno de los cuales ocupan cuatro bytes para un total general de 8n bytes. Ok. Entonces, en resumen realmente podemos figurarnos cuantas veces tenemos que girar la manivela en las computadoras modernas. Podemos hacerlo con un análisis empírico donde realmente ejecutamos el programa, podemos hacer experimentos y usar [inaudible] ley exponencial, formular hipótesis y hacer predicciones. Pero podemos hacer más, podemos hacer un análisis matemático donde podemos identificar las operaciones más costosas, analizar la frecuencia de ejecución de esas operaciones y utilizar la notación de tilde para simplificar el análisis. Podemos realmente explicar el comportamiento, no solamente predecirlo. Y este es un buen ejemplo del uso del método científico para entender los artefactos que estamos estudiando, los algoritmos. Nuestros modelos matemáticos usualmente son independientes de un sistema de computación particular, e incluso implican también a máquinas que aún no fueron construídas. Pero siempre validamos nuestros modelos matemáticos corriendo experimentos en máquinas reales de modo que podemos tener confianza donde estamos haciendo predicciones y analizando algoritmos.