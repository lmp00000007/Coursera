実際のところ、計算量増加量の分類は
とても重要なもので、 近年膨大な量の研究につながっています。
ここでは、それらについて簡単にお話しします。 最後の例で示されたものより、
人生はもう少し複雑なものです。 １つの問題は、入力によってアルゴリズムの性能が
大きく変わってきてしまうことが あることです。そこで、しばしば入力に依存した
アルゴリズム解析とは異なる 考え方をする必要があります。つまり、実行時間は最善の場合と 最悪の場合との間のどこかになるでしょう。
最善の場合は、アルゴリズムのコストの 下限値です。アルゴリズムはいつでも、最善の場合より実行時間が大きいか、 それを下回ることはありません。そして、最悪の場合もあり、これは 最も難しい入力です。最悪値を分析すると、アルゴリズムの実行時間が この値より大きくなることはないと保証できます。
そして、多くの状況では、 入力はランダムであると考えるでしょう。
ですので、何らかのモデルが必要で、 解いている問題についてランダム値が入った時の
モデルが必要なのですが、モデル化することのできる状況は たくさんあり、そのため、入力が広範囲に
ばらけていたとしても性能予測が できるわけです。ですので、例えば
３つの数字の和の場合、いつでも同じ種類になります。 チルダ記法を用いていますが、このアルゴリズムが変動する要因は カウンタ値を何回加算するかだけですので、
その意味で小さな違いしかなく、 分析で深く追求する必要はありません。 ２分探索では、すぐに一定時間となる場合を見つけられるでしょうし、
平均および最悪の場合は どちらもlog2Nだと分かります。
他の場合では、分布が 対等になる場合もあります。
このように、入力に従って、 異なる分析方法があります。
しかし、問題なのは、実際に顧客が解こうとしている 問題ではどうかということです。ですので、
アルゴリズムの性能を理解するためには このことも理解する必要があります。この点については、 成功している２つの方針があります。
１つは最悪の場合を想定したデザインです。 皆さんのアルゴリズムが常に高速に動き、間違いなく
理想的であることを保証する、ということです。 もう１つは、理想を追えないならランダム値を使い、 何か確率的に保証できるものを頼りにするやり方です。
私たちはこれから、両方の例について、コースを進めながら見ていきます。 さて、考えるべきことなのですが、 計算量の増加の考え方を知っていますが、このことからいわゆる、
私がこう呼んでいるのですが、「アルゴリズムの理論」の 議論ができます。ここでの目標は、3値の足し算のような
解きたい問題があるとして、 それがどのくらい困難な問題かを知りたいと
いうことです。その問題を解くのに 最善なアルゴリズムを見つけたいのです。
計算機科学の研究者が使う手法は 詳細な部分は、分析の際には極力省略する、というやり方です。 単に実行時間を定数倍にまで落として分析するのです。
ここで計算量というものが出てきます。 それから、入力モデルをまったく心配しないようにしたいのです。 ですので、最悪の場合について焦点を当てます。 これで、私たちは計算量の増加だけでアルゴリズムの性能に
ついて語ることができます。 非常に厳密な方法でこれを行うことが実際できます。 このやり方によって、問題を解く難しさについて
たくさんのことを学べます。 私たちの目標は最適なアルゴリズムを見つけることです。
任意の入力に対して、定数倍の範囲で実行できる保証のあるものです。 最悪の場合が分かっているので。
しかし、 より良い性能を保証するアルゴリズムが分からないものも
あることは認める必要があります。これについては、 いくつか簡単な例を出そうと思います。
さて、この分析を行うためには、一般的に使われている記法があります。 大文字のセータ、大文字O、大文字オメガ表記と呼ばれるものです。 定義はこのように与えられています。大文字セータ表記は単に 計算量の増加を表す方法だということです。
セータNの２乗とは、Nの２乗の倍数を短く表記したものです。 この値はNの２乗の上限と下限で抑えられます。
これを用いて実際に アルゴリズムを分類します。大文字O表記もあり、こちらは実行時間の 最大値を表します。私たちがOのN２乗と言ったら、
実行時間はNが増えたとき、Nの２乗のある定数倍よりは 少ない時間だということです。大文字オメガ表記は、下限値を表すのに使います。
つまり、実行時間はNが増えたとき Nの２乗の定数倍より大きい時間だということです。
これら３つの表記を用いて アルゴリズムを分類できます。次に例を示します。 １値、２値、３値の合計の例を挙げるとはっきりわかりやすいでしょう。 我々の目標は問題の難易度をはっきりさせ、
最適なアルゴリズムを開発することです。 １値の和の問題では、配列に00が入っているとします。
この問題の難易度の上限は ある特定のアルゴリズムです。例えば、総当たりアルゴリズムでは 配列要素をすべて見ますが、これなどがそのアルゴリズムです。 O(N)時間かかります。定数Nの定数倍より小さい値です。 ですので、最適なアルゴリズムの実行時間は
O(N)である必要があります。 なぜなら、特定のアルゴリズムが最適なアルゴリズムの
実行時間の上限を与えているからです。 しかし、この例の場合、下限を求めるのも容易であり、 総当たりより優れたアルゴリズムが
ないことの証明になります。 1値の和問題では、配列の全要素を
検査する必要があります。１つ見落とすと、 それが０であるかもしれません。このことにより
最適なアルゴリズムでは 実行時間は少なくともNの定数倍になり、
実行時間はオメガNとなります。 この例では上限値、下限値が一致します。 ですので、定数倍を使えば、１値の和問題では
総当たりアルゴリズムが最適という証明になります。 実行時間はセータNで、オメガNで、O(N)でもあります。 簡単な問題でしたら、最適なアルゴリズムを
得るのは大丈夫なのですが、より複雑な問題ですと 上限値と下限値のバランスを得るのが
より困難になります。 特に上限と下限値が一致するものを得るのは困難です。
例えば、３値の和問題を見てみましょう。 ３値の和問題では、上限値は例えば
総当たりアルゴリズムですが、これが 最適なアルゴリズムの実行時間を保証しますが、O(N)の３乗です。 しかし、私たちはより良いアルゴリズムを見つけていて、
この実行時間はO(N)の２乗のlogNです。これがより良い上限値ですね。 下限値ですが、すべての要素を
検査しなくてはなりません。再度になりますが、 １つ読み飛ばすと、それが３値の和を0にする
構成要素かもしれないからです。 ですので、最適なアルゴリズムの実行時間はO(N)と
いう証明になりますが、3値の和については、 これより大きな下限値を誰も知りません。
ですので、上限値と下限値に差があり、未だに解かれていません。 3値の和問題の最適なアルゴリズムは
存在しているのでしょうか？分かりません。 私たちは、実行時間がO(N)の2乗未満のアルゴリズムが あるのかどうかさえ分からないのです。
より高い下限値があるのかも分かりません。 これが「アルゴリズムの理論」における
未解決の問題の例であり、3値の和問題を 解く難しさがどの程度か分かっていません。
ともあれ、この考え方は、ここ数十年間で非常に成功しています。 新しい問題を生み出し、あるアルゴリズムを開発し、
ある下限値の証明ができています。 上限下限の間に隔たりがあれば、
上限値を下げる新しいアルゴリズムを探すか、 あるいは下限値を切り上げる方法を見つけようとします。
通常、自明ではない下限値を証明するのはとても困難です。 すべての入力値を見るというような自明な下限値であれば それほど難しくありません。たとえばですが、 Union-find問題で話している証明はとても難しいですね。 最近の数十年で、問題に対する計算の難しさに
ついて人々は学んできており、 着実に上限値を切り下げられないか試しています。 とても多数の重要な問題について、最悪の場合でも
より良いアルゴリズムが出てきています。 同時に最適なアルゴリズムと上限下限の差の
問題が多く残されています。 たくさんの人々が研究しているとても魅力的な領域です。
ここで、いくつか本コースでの 意味における注意事項があります。１つ目は、最悪の場合について オーバーに悲観的に見ているかもしれないことです。
データがそこにあり、解かなくてはならない問題があるとします。 そのデータは最悪の場合ではなく、工学や科学の分野で
たくさんあるものかもしれません。 最悪の場合など注目していないものです。
本コースでは最悪の場合とは、 雷に打たれたようなもので、オーバーであって、
対処する想定をしていないものでしょう。 同様に、アルゴリズムについても当てはまります。
入力値の属性を理解して、 それに対して十分なアルゴリズムを
発見することに注目すべきかもしれません。 もう１つは、実際に性能を予測して
アルゴリズムを比較するために、 定数倍以内よりも小さい差の分析をする必要があります。 そこで、アルゴリズムの理論で使われる
大文字セータや大文字O、オメガ表記内の チルダ記述について話します。実際に、
アルゴリズム理論の研究著書で 多くの人が大文字O記述の結果解釈を間違えています。 本来は問題の困難度について改善された
上限値を与えるべきところを 実行時間の近似モデルとして与えてしまっています。
これは全くの間違いです。 そこで、本コースでは、近似モデルに焦点を当てます。 チルダ記述を確実に使うようにして、
注目しているデータ量と 実行時にはっきりと決まらない任意の定数、 マシンやシステムの属性に依存する定数について
具体的な結果を与えるようにしてみます。 それによって、性能やアルゴリズムの比較が できるようにします。