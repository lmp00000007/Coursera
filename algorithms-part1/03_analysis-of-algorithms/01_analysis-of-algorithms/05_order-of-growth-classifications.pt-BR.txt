Agora, felizmente, quando analisamos algoritmos, na verdade, não muitos diferentes funções surgem e, na verdade, que a propriedade nos permite realmente classificar algoritmos de acordo com o seu desempenho como o tamanho do problema cresce. Então é isso que vamos falar em seguida. Então, a boa notícia é que há apenas estas funções poucos transformar-se sobre os algoritmos que estamos interessados ​​Nós podemos criar coisas que têm outras funções e há exemplos contrários a isso. Mas realmente um grande número de algoritmos que consideramos são descritos por essas funções e poucos que são representados aqui. E [tosse] a quando estamos a falar sobre a ordem de crescimento, nós não estamos falando sobre a constante liderança. Normalmente nós vamos dizer que o tempo de execução do algoritmo é proporcional a N log N. Isso significa que que pensamos que nossa hipótese é de que o tempo de execução é til C lg N, N lg N, onde C é uma constante. E nestas parcelas, estes são lg, lg parcelas que não realmente dar uma boa idéia do que está acontecendo. Se uma ordem de crescimento é logarítmica ou constante, não importa quão grande a coisa é. Vai ser rápido da corrida tempo para T é para dizer um mil, e para meio milhão que será muito perto de T. Se é linear, se for o crescimento automático é proporcional a N, em seguida, como a execução tempo, como o tamanho aumenta o tempo de funcionamento aumenta correspondentemente. E a mesmo é verdade, quase, se é N log N. Então esses são os algoritmos que nos esforçamos para. Eles escala com o tamanho de entrada. À medida que a entrada aumenta, também aumenta o funcionamento tempo. E isso é, uma situação razoável para estar dentro Como falamos quando falou sobre União de encontrar. Se é quadrática, o tempo de execução cresce muito mais rápido do que o tamanho de entrada. E não é possível usar esse algoritmo para grandes entradas. E Qubic é ainda pior. Então, o que vemos é que muitos algoritmos nossa primeira tarefa é, na verdade, simplesmente, certifique-se que não é quadrática ou qubit. E estes ordem de classificação de crescimento, na verdade, vêm de tipo de padrões simples em termos do código que escrevemos. Então, se o nosso código não tem laços nela, então a ordem de crescimento vai ser constante. Se o nosso código tem algum tipo de circuito onde a entrada é dividida ao meio, e algoritmo de busca para binário é um exemplo disso. Então, o nosso crescimento ordem será logarítmica e vamos dar uma olhada no que a análise e mas se você fizer o teste de duplicação, que cresce quase linearmente, se você tem um enorme contributo e você o dobro do tamanho que é, ela ainda vai ser Eu sinto muito, não linear, constante assim como se é constante. Você notará que a LG N. Se tem um loop onde você tocar em tudo na sua entrada. Do que o tempo de execução é linear, proporcional ao fim para que um exemplo típico de que seria encontrar o máximo, ou para contar o número de zeros. Nosso um algum problema. Uma categoria muito interessante é um chamado N algoritmos LG n lineares ou algoritmos rítmicos. E esses são os aquelas que surgem a partir de uma técnica particular de algoritmos projeto chamado dividir e conquistar. E o algoritmo Mergesort, que vamos falar em um par de semanas, é um excelente exemplo disso. E então, se você tem o dobro quatro loops como o nosso algoritmo de soma dois, que vai ser um tempo proporcional a N ^ 2. Como vimos, que é quadrática, ou triplo loop de quatro como o nosso algoritmo de soma-3, que é vai ser cúbica ou o tempo proporcional a N ^ 3. Para um algoritmo quadrático ou cúbico algoritmo, o fator de duplicação é de quatro ou oito o dobro do tamanho de entrada para cúbico algoritmo, o tempo de execução passa por um fator de oito anos, e que é o tipo de cálculo que você pode fazer em sua cabeça enquanto espera por um programa terminar. Há também uma categoria de algoritmos que está correndo o tempo é exponencial e, em esses algoritmos n não ficar muito grande e em nós vamos falar sobre aqueles que estão no fim segunda parte do curso. Então, essas são algumas implicações práticas, da ordem crescimento. E nós realmente me debruçar sobre isso muito, exceto para voltar ao ponto que os algoritmos que estamos realmente interessados, que podem resolver grande problemas, são as lineares e N algoritmos lg n. Porque até agora atic um Quadr algoritmo em um computador típico rápido só poderia resolver os problemas e dizer que dezenas de milhares em um algoritmo cúbico apenas no tamanho dos milhares. E hoje em dia os não são apenas úteis porque a quantidade de dados que temos é mais como o milhões ou bilhões ou trilhões. Esse fato está se tornando mais e mais evidente que tempo desgasta sobre os tempos antigos teriam alguma discussão sobre se quadrática algoritmo pode ser útil, mas a situação piora à medida que o tempo passa, por isso precisamos de melhores algoritmos. Para ilustrar o processo de desenvolvimento de um modelo matemático para descrever um desempenho através de um algoritmo, vamos olhada em um algoritmo de busca binária familiar chamou. É, o objetivo é que você tem um array ordenado de inteiros, dizer e você está dado uma chave. E você quer saber, é que chave na matriz? E se é, o que, o que é seu índice? E um algoritmo rápido para fazendo isso é conhecido como busca binária, onde se compara a chave contra o entrada do meio. Neste caso, se nós estamos olhando para 33, que compará-la com 53. Se sua menor sabemos que a sua na metade esquerda da matriz, se for maior que conhecemos está na metade direita da matriz, se é igual, nós o encontramos. E, então, aplicar algoritmo o mesmo recursivamente. Então, vamos olhar rapidamente uma demo. Então, estamos procurando para 33 nesta matriz, compará-la com a entrada do meio na matriz. 53 e é menos que vá para a esquerda, então agora podemos nos concentrar apenas na metade esquerda do matriz, agora vamos procurar no meio do semestre, que é 25, 33 é maior assim que nós vamos direita. E agora vamos nos concentrar na metade direita ou metade esquerda e temos um menor matriz sub. Olhe para o meio, 33 é menos que vá para a esquerda e agora só temos um elemento para olhar e encontramos o nosso 33 chave na matriz e voltamos que índice quatro. Se nós estamos procurando por algo que não está na matriz, podemos fazer o mesmo processo. Assim, por exemplo, nós estamos olhando para 34. Vai ser o mesmo. Olhe-se no meia esquerda, procure na meia direita. Olhar para a esquerda do 43. Agora, só há um chave para olhar. A nd não é 34, então dizemos, não é lá. Então, isso é binário pesquisa. Então, aqui está o código para pesquisa binária. Na verdade Pesquisa, Binário embora é um algoritmo simples, o seu notoriamente difícil de obter todos os detalhes direito. Na verdade papel um reclamado, que o primeiro bug de busca binária livre não foi publicado até 1962, e até mesmo em 2006, um bug foi encontrado na implementação do Java de busca binária, apenas uma indicação dos cuidados que temos que levar em algoritmos de desenvolvimento especialmente para bibliotecas que vão ser usados ​​por milhões de pessoas. Então aqui está uma implementação. Não é recursiva embora muitas vezes podemos implementar esta uma implementação. Não é recursiva embora muitas vezes podemos implementar esta encontrar. Uma chave, se a chave está em uma matriz. E usamos dois ponteiros, baixa e alta, para, indicar a parte da matriz que nos interessa, desde que seja baixo e menos igual a alta, calculamos a média. E, então, comparar a nossa chave contra o meio, na verdade, o seu caminho de três comparar, ver a sua maior ou menor ou se o seu igual, nós, nós retornar que o índice médio. Se seu menos que reiniciar o ponteiro alto, se a sua maior, que reiniciar o ponteiro baixo, e seguir em frente até que os ponteiros são iguais. Se eles são iguais e não tê-lo encontrado, então voltamos um. E é fácil nos convencer de que este programa funciona como anunciado por pensar sobre isso invariante, se as chaves na matriz, então é entre baixa e alta na matriz. Tudo bem, de modo que é um programa que, provavelmente você está familiarizado. Vamos olhar para o análise matemática desse programa. E esse um, um teorema que vamos comprovar facilmente. Queremos um monte de provas, mas isso é uma pena. Portanto, a sua dizer que busca binária usa no máximo um + lg base dois eventos compara, para completar um pesquisa, em um array ordenado de f tamanho. Então nós fazemos que, para configurar o problema, definindo, uma variável T (N), que é o número de pesquisa binária que compara necessária para a sua tamanho da matriz e. E, então, escrever uma relação de recorrência que é o reflexo código. E o que o código faz é, divide-se o tamanho do problema no meio de modo que. Se o evento for menor ou igual ao evento mais de dois mais dependendo de como você conta o que comparar é pensar nisso como uma maneira comparar dois tão dividida ao meio por fazer uma comparação e isso é verdade, desde que N é maior do que um. Se for igual a um solução a é um. Então, é uma relação recorrente descrevendo o cálculo. E por isso, podemos ir em frente e, para resolver essa recorrência, aplicando a recorrência si, para o primeiro termo à direita. Agora que é chamado telescópica. Portanto, se esse é verdade e podemos aplicar a mesma coisa para T (N / 2). E jogar fora um outro e se que é, isso é verdade, aplicar a mesma coisa para N mais de quatro, e jogar fora outra e assim por diante até chegarmos para apenas um. Caso em que temos os LG n esquerda. Agora este é um esboço verdade que você deve ter notado que, na verdade, que esta prova prende somente se N é uma potência de dois. Porque nós quase especificar em que esta recorrência queremos dizer, se n é ímpar. Mas é possível ir em frente e muito, possível avançar e cuidar desse detalhe tão bem e mostram que o tempo de execução é de busca binária logarítmica sempre. Tudo bem, então dado o fato que podemos desenvolver mais rápido algoritmo para um ménage à trois. É um algoritmo de classificação baseado. E então o que nós vamos fazer é que vamos tomar os números que temos como entrada e classificá-los. Nós vamos falar sobre algoritmos de ordenação na próxima semana. E nós temos que o tempo em tempo proporcional para N lg N, mas isso não é a parte principal da computação. A parte principal do computação é para depois dos números são classificados, nós vamos passar e para cada par de números ai e aj. Nós vamos fazer uma busca binária para-ai + ij. Se encontrá-lo, em seguida, teremos três números que somam zero. Então, se nós [tosse] classificar nossos números e depois passar para cada par fazer uma busca binária para ver se ele está lá, assim -40, zero. Minus que é de 40, nós fazemos uma busca binária que está lá por isso temos uma solução para problema do 3-soma. E fazer isso para todos os pares de números. Em seguida, uma análise rápida diz que a ordem de crescimento do tempo de execução vai ser N ^ 2 lg N. Em seguida, você precisa de um tipo bom, bem, você pode usar o tipo de inserção elementar o primeiro que falar, mas o tempo de execução da pesquisa binária para cada um dos pares, cada do N ^ 2 pares ou N ^ 2/2 pares que vamos fazer a busca binária, então nós temos um N ^ 2 N lg tempo de corrida. Então, um rápido exemplo de como podemos melhorar o desempenho, poderíamos encontrar um algoritmo imroved para resolver um problema. N ^ 2 lg N é muito menos de N ^ 3 para N. grande e assim, estamos implicitamente fazendo a hipótese de que se fazemos isso, fazer a coisa de base tipo e usar busca binária, nós vamos ter um programa mais rápido. E, com certeza, podemos ir em frente e executar alguns experimentos e encontrar que, enquanto que nos levou 50 segundos para resolver o problema para 8000 números antes. É tendo menos de um segundo. Em 50 segundos, podemos resolver até 64000. Então, normalmente, esperamos que melhor ordem de meios de crescimento. Mais rápido nos treinos e mas quando se trata de examinar os algoritmos em detalhes que podemos, nós podemos ir frente e fazer os testes e descobrir qual algoritmo é mais rápido. E, certamente, indo de N ^ 3 a N ^ 2 lg N vamos esperar que nós vamos ter um grande melhor algoritmo.