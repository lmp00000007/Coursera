1
00:00:02,200 --> 00:00:04,426
지금까지는 러닝 타임에 대해 얘기했는데요

2
00:00:04,426 --> 00:00:08,070
이제 프로그램의 메모리 요구사항에 대해 얘기해볼게요

3
00:00:09,710 --> 00:00:14,162
기본적으로 프로그램에 한번에 필요한 비트 혹은 바이트 수를

4
00:00:14,162 --> 00:00:16,070
알고싶습니다.

5
00:00:16,070 --> 00:00:21,440
실제 얘기하는 규모는 수백만 혹은 수십억 바이트입니다.

6
00:00:21,440 --> 00:00:26,060
이런 가장 기본사항 조차도 

7
00:00:26,060 --> 00:00:27,570
논쟁이 있습니다.

8
00:00:27,570 --> 00:00:31,809
컴퓨터 공학자는 백만비트가 2^20 , 십억 비트는 2^30이라고

9
00:00:31,809 --> 00:00:37,225
생각하는데, 이것이 30비트에 집어넣을 수 있는

10
00:00:37,225 --> 00:00:42,586
가능량이기 때문입니다. 또한 계산 과정이 일관적입니다.

11
00:00:42,586 --> 00:00:49,352
다른 과학자들은 백만 / 십억이라는 표현을 고집하는데요

12
00:00:49,352 --> 00:00:52,649
저는 보통 메가바이트를 표현할때 2^20을 씁니다

13
00:00:52,649 --> 00:00:58,479
오래된 컴퓨터는 수년동안 32비트 머신을 써왔습니다.

14
00:00:58,479 --> 00:01:01,449
그로인해 포인터는 4바이트가 되죠.

15
00:01:02,720 --> 00:01:07,562
최근에는, 64비트 머신으로 대부분 교체가 되었는데요. 

16
00:01:07,562 --> 00:01:10,477
그로인해 포인터는 8바이트입니다.

17
00:01:10,477 --> 00:01:16,650
이로인해 훨씬 많은 메모리를 어드레스할 수 있지만, 포인터가 더 많은 공간을 사용합니다.

18
00:01:16,650 --> 00:01:22,260
이런 교체로 초기에는 많은 문제점이 있었습니다.

19
00:01:22,260 --> 00:01:26,460
사람들이 생각했던것보다 프로그램의 메모리 사용량이 더 많아서였죠.

20
00:01:26,460 --> 00:01:30,929
여러분은 그 당시 겪었던 이런 교체를 다시 거쳐갈 필요는 없는데요

21
00:01:30,929 --> 00:01:35,762
64비트는 여러분에게 충분한 메모리 주소를

22
00:01:35,762 --> 00:01:36,862
제공하기 때문입니다.

23
00:01:36,862 --> 00:01:39,040
2^64은 굉장히 큰 수입니다.

24
00:01:41,040 --> 00:01:47,210
이제 바이트 견지에서, 전형적인 메모리 사용부터 시작해봅시다.

25
00:01:47,210 --> 00:01:51,200
이건 머신과 구현에 따라 다를수있지만

26
00:01:51,200 --> 00:01:56,950
여기 숫자는 꽤 합리적이고, 전형적인 구현에 기반합니다.

27
00:01:56,950 --> 00:02:01,053
불리언의 경우에는 참 혹은 거짓이니 1비트면 충분하겠지만

28
00:02:01,053 --> 00:02:05,447
실제로는 불리언 계산을 위해서는 1바이트를 씁니다.

29
00:02:05,447 --> 00:02:10,440
당연히 1바이트는 1바이트를 쓰고, 캐릭터는 2바이트, 즉 16비트를 씁니다.

30
00:02:10,440 --> 00:02:14,290
캐릭터로 8비트를 썻던 적은 그렇게 오래되지는 않았습니다.

31
00:02:14,290 --> 00:02:18,000
정수, 보통 정수는 4바이트, 즉 32비트를 씁니다.

32
00:02:18,000 --> 00:02:25,780
플로트는 4바이트를 쓰고, 롱(long) 정수는 8바이트, 더블은 8바이트를 씁니다.

33
00:02:25,780 --> 00:02:29,830
보통 대부분의 어플리케이션에서는  부동소수점에는 더블을 쓰고, 

34
00:02:29,830 --> 00:02:33,710
정수로 int를 씁니다.

35
00:02:33,710 --> 00:02:36,180
여기까지 원시타입이였습니다.

36
00:02:36,180 --> 00:02:42,300
배열에 관해서 보면, 배열을 만드는데 상당한 오버헤드가 있습니다.

37
00:02:42,300 --> 00:02:48,436
배열에 N아이템이 있으면, 해당 원시타입의 바이트 * N만큼 비용이 들죠.

38
00:02:48,436 --> 00:02:52,678
더블형 배열의 경우 8N+24입니다.

39
00:02:52,678 --> 00:02:56,750
이차원 배열을 봅니다.

40
00:02:56,750 --> 00:03:01,900
정확히 계산해볼수도 있지만,

41
00:03:01,900 --> 00:03:05,250
지금은 틸드 표기법을 쓸 때입니다.

42
00:03:05,250 --> 00:03:09,837
더블형 배열일경우, 일차원일때는 ~8N이라고 쓸 수 있습니다.

43
00:03:09,837 --> 00:03:15,102
이차원일 경우에는, ~8MN입니다.

44
00:03:15,102 --> 00:03:18,695
오버헤드를 처리할 추가 항이 있지만, 큰 M,N에 대해서는

45
00:03:18,695 --> 00:03:22,203
틸드 표기법은 꽤 정확할 겁니다.

46
00:03:22,203 --> 00:03:25,081
여기까지 전형적인 구현에 있어서 원시타입과

47
00:03:25,081 --> 00:03:27,490
배열의 기본적인 사용이였습니다.

48
00:03:29,360 --> 00:03:33,720
요즘 많은 프로그램들이 linkList등의 객체를 쓰는데요,

49
00:03:33,720 --> 00:03:37,080
이 경우 객체 오버헤드도 계산에 넣어야합니다.

50
00:03:38,150 --> 00:03:43,640
참조에 드는 비용과 전형적인 구현에 있어서 내장된 패딩이 있는데요

51
00:03:43,640 --> 00:03:49,430
이로인해 개별 객체가 8바이트를 여러번 쓰게 됩니다.

52
00:03:50,620 --> 00:03:57,650
예를들면 데이트 객체는 세 개의 정수형 인스턴스 변수를 가지는데요,

53
00:03:57,650 --> 00:04:04,340
그로인해 데이트 객체는 32바이트를 쓰는데, 개별 정수형이 4바이트씩,

54
00:04:04,340 --> 00:04:06,684
객체 오버헤드가 16바이트,

55
00:04:06,684 --> 00:04:09,590
또한 패딩때문에 4바이트가 필요해서, 총 32바이트가 됩니다.

56
00:04:11,830 --> 00:04:16,420
또 잘 쓰는게 스트링(문자열)인데요.

57
00:04:16,420 --> 00:04:22,234
스트링은 배열보다는 조금  복잡한데

58
00:04:22,234 --> 00:04:28,162
자바에서 스트링의 전형적인 구현은

59
00:04:28,162 --> 00:04:33,976
문자열 배열을 참조하는데, 

60
00:04:33,976 --> 00:04:39,110
오프셋,카운트,해쉬 값으로 정수형과  기타 패딩을 

61
00:04:39,110 --> 00:04:41,260
다 더하면

62
00:04:41,260 --> 00:04:46,710
문자열의 비용은 2N+64바이트가 됩니다.

63
00:04:48,700 --> 00:04:53,133
여기까지가 전형적인 자바구현에 있어서

64
00:04:53,133 --> 00:04:57,574
메모리 사용을 분석하는데 필요한 사항이였습니다.

65
00:04:57,574 --> 00:05:02,413
데이터 타입의 값의 경우에는, 원시타입으로 정수는 4바이트

66
00:05:02,413 --> 00:05:04,425
더블로는 8바이트를 씁니다.

67
00:05:04,425 --> 00:05:07,984
참조형이라면 8바이트가 포인터가 취하는 값이됩니다.

68
00:05:07,984 --> 00:05:15,100
배열의 경우 24바이트 + 개별 엔트리의 메모리가 되고, 객체의 경우 16바이트 +

69
00:05:15,100 --> 00:05:20,115
인스턴스 변수의 메모리 + 이너클래스가 있을 경우 다시 

70
00:05:20,115 --> 00:05:24,340
노드나 linkedLIst를 말할때 8바이트가 추가됩니다. 또한

71
00:05:24,340 --> 00:05:25,460
패딩까지 있습니다.

72
00:05:27,290 --> 00:05:33,310
이제 일부 케이스에서 참조된 객체에 있어 

73
00:05:33,310 --> 00:05:36,640
책임문제를 다뤄야 합니다.

74
00:05:36,640 --> 00:05:40,799
해당 상황이 발생하면, 그 때 다루겠습니다.

75
00:05:40,799 --> 00:05:45,175
간단한 메모리 사용 분석을 예로들면, 

76
00:05:45,175 --> 00:05:49,813
얼마전 강의에 나왔던 WeightedQuickUnionUF(N)이 메모리를

77
00:05:49,813 --> 00:05:53,943
얼마나 차지하는지 보겠습니다.

78
00:05:53,943 --> 00:05:58,856
몇개의 메모리 요소가 있는데요, 각각의 것들은

79
00:05:58,856 --> 00:06:06,420
방금 전 내용으로 쉽게 분석이 가능합니다.

80
00:06:06,420 --> 00:06:09,571
객체니깐 객체 오버헤드 때문에 16바이트,

81
00:06:09,571 --> 00:06:12,240
두 개의 정수형 배열의 경우

82
00:06:12,240 --> 00:06:17,106
각각 배열 오버헤드로 24바이트 + N 엔트리의 경우 4N

83
00:06:17,106 --> 00:06:21,527
입니다. N 엔트리 각각마다

84
00:06:21,527 --> 00:06:24,547
4바이트를 씁니다.

85
00:06:24,547 --> 00:06:29,086
카운트로 4바이트, 패딩으로 4바이트

86
00:06:29,086 --> 00:06:30,768
다 합치면

87
00:06:30,768 --> 00:06:35,820
8N+88인데 틸드 표기법으로는 8N이 됩니다.

88
00:06:35,820 --> 00:06:41,976
다시 설명하면, N이 충분히 큰 상황에서는 메모리 분석에 있어 

89
00:06:41,976 --> 00:06:48,469
우리가 신경쓸 부분은,  N개의 정수 두 번입니다.

90
00:06:49,820 --> 00:06:53,750
사이즈가 N인 두개의 배열을 말하는데요, 각각 엔트리가 4바이트를 차지하니깐

91
00:06:53,750 --> 00:06:55,840
다합치면 N바이트가 되는겁니다.

92
00:06:57,310 --> 00:07:02,880
요약하면, 우리는 현대 컴퓨터의 크랭크를 얼마나

93
00:07:02,880 --> 00:07:05,750
돌려야하는지 정확하게 말할 수는 없습니다.

94
00:07:06,780 --> 00:07:11,836
대신 경험적 분석으로 하는데요, 실제로 프로그램을 구동해보고

95
00:07:11,836 --> 00:07:17,278
멱법칙을 가정하고, 가설을 만들어서 예상을 해보는겁니다.

96
00:07:17,278 --> 00:07:23,331
여기서 더나가서, 가장 비용이 많이 드는 작업을 수학적으로 분석해서

97
00:07:23,331 --> 00:07:29,790
해당 작업 처리에 드는 주파수를 분석할 수 있습니다.

98
00:07:29,790 --> 00:07:33,310
분석을 간단화하기 위해 틸드 표기법을 쓰고

99
00:07:33,310 --> 00:07:37,020
실제로 예상을 넘어서서 설명을 할 수 있습니다.

100
00:07:37,020 --> 00:07:40,935
이것이 과학적 분석을 

101
00:07:40,935 --> 00:07:44,795
공부하고 있는 유물, 즉 알고리즘을 분석합니다.

102
00:07:44,795 --> 00:07:48,555
수리적 분석은 보통 특정한 컴퓨터 시스템과는 독립적인 편이고,

103
00:07:48,555 --> 00:07:53,000
심지어는 아직 구현되지 못한 머신에도 적용됩니다.

104
00:07:53,000 --> 00:07:58,082
그러나 실제 머신에 실제로 실험을 해봄으로써 수리적 모델을 입증하는데,

105
00:07:58,082 --> 00:08:02,856
그로인해 예측을 하거나 알고리즘을 분석하는데

106
00:08:02,856 --> 00:08:04,477
자신감을 가지게됩니다.