1
00:00:03,064 --> 00:00:08,071
幸运的是，分析算法时我们不会遇到太多

2
00:00:08,071 --> 00:00:14,746
各不相同的函数，这使得我们可以将算法按照性能

3
00:00:14,746 --> 00:00:20,978
随问题大小变化而分类。这就是我们接下来要讲的东西。

4
00:00:20,978 --> 00:00:27,173
所以好消息是，与我们感兴趣的算法

5
00:00:27,173 --> 00:00:31,915
相关的只有少数几个函数。我们也可以构造一些算法

6
00:00:31,915 --> 00:00:37,479
其性能表现为其他的函数，是有反例的。不过我们考虑的

7
00:00:37,479 --> 00:00:43,394
算法中非常多都能被这里画出的几个函数所描述

8
00:00:43,394 --> 00:00:50,362
当我们谈到增长阶数时

9
00:00:50,362 --> 00:00:55,793
我们不讨论前面的常数。一般如果我们说

10
00:00:55,793 --> 00:01:00,971
一个算法的运行时间和 N log N 成正比，意味着

11
00:01:00,971 --> 00:01:06,686
我们提出的假设就是运行时间近似为 c N log N

12
00:01:06,686 --> 00:01:12,671
其中 c 是某个常数。在这些双对数坐标图表上

13
00:01:12,671 --> 00:01:18,801
可以很明白地看到：如果增长阶数是对数或者

14
00:01:18,801 --> 00:01:25,026
常数的。无论问题的规模多大，这些算法都很快

15
00:01:25,026 --> 00:01:32,082
如果问题规模是一千的时候运行时间是 T，对于五十万运行时间也会非常接近T

16
00:01:32,082 --> 00:01:38,674
如果是线性的，也就是说增长阶数和 N 成正比，则运行时间

17
00:01:38,674 --> 00:01:44,945
随着问题规模增大而线性增长。如果是

18
00:01:44,945 --> 00:01:51,031
N log N 的话，差不多也是一样的。以上这些算法就是我们努力想要设计出来的

19
00:01:51,031 --> 00:01:56,755
它们能够成比例适应问题的规模。当输入变大时，运行时间一样也会变长

20
00:01:56,755 --> 00:02:02,647
这是合理的情形。讲并查集的时候我们谈过这个

21
00:02:02,647 --> 00:02:07,843
如果增长阶数是平方阶的，运行时间增长速度

22
00:02:07,843 --> 00:02:13,469
远快于输入大小，就不能将这样的算法用于庞大的

23
00:02:13,469 --> 00:02:21,397
输入。立方阶的算法性能就更糟了。所以我们研究算法时首先

24
00:02:21,397 --> 00:02:28,515
要确保算法不是平方阶或者立方阶的。而这些

25
00:02:28,515 --> 00:02:35,708
增长阶数类型实际上就源于我们写的代码中的某些简单模式

26
00:02:35,708 --> 00:02:41,918
如果代码中没有循环，增长阶数是常数

27
00:02:41,918 --> 00:02:49,033
如果有某种循环，每次循环输入被

28
00:02:49,033 --> 00:02:54,276
分成两半，二叉搜索算法就是一个例子

29
00:02:54,276 --> 00:03:00,676
增长阶数就是对数的，一会我们来看一下它的分析

30
00:03:00,676 --> 00:03:06,879
如果做之前将输入翻倍的测试，运行时间的增长几乎是线性的（教授这里口误，应该是常数）。如果输入非常大

31
00:03:06,879 --> 00:03:12,633
并将输入翻倍，增加的运行时间仍然是，抱歉，不是线性的

32
00:03:12,633 --> 00:03:18,252
是常数的。几乎很难注意到 log N 的存在

33
00:03:18,252 --> 00:03:25,070
如果循环遍历了输入中的所有对象，运行时间是

34
00:03:25,070 --> 00:03:31,592
线性的，与 N 成正比。典型的例子就是找最大值

35
00:03:31,592 --> 00:03:38,205
或者统计0的个数，也就是我们的1-SUM问题

36
00:03:38,205 --> 00:03:44,681
N log N 是一个很有意思的分类，线性对数阶算法

37
00:03:44,681 --> 00:03:50,143
这样的时间复杂度源于一种特定的算法设计技巧叫做

38
00:03:50,143 --> 00:03:55,573
分治法。比如我们几周内就会讲到的归并排序

39
00:03:55,573 --> 00:04:01,012
就是非常典型的例子。如果算法中有双重for

40
00:04:01,012 --> 00:04:07,543
循环，比如之前的2-SUM算法，运行时间和 N^2 成正比

41
00:04:07,543 --> 00:04:13,530
我们已经见过了，是二次的。如果有我们 3-SUM 算法中的三重for循环

42
00:04:13,530 --> 00:04:19,369
运行时间就是立方阶的，与 N^3 成正比。对于平方阶

43
00:04:19,369 --> 00:04:25,312
算法，输入翻倍后运行时间增大到4倍

44
00:04:25,312 --> 00:04:30,331
对于立方阶算法运行时间会增大到8倍

45
00:04:30,331 --> 00:04:35,952
这些在等待程序运行你就能心算出来了

46
00:04:35,952 --> 00:04:41,645
还有一类算法，运行时间是指数阶的

47
00:04:41,645 --> 00:04:47,059
这些算法中N不会非常大，在第二部分课程的结尾我们

48
00:04:47,059 --> 00:04:53,150
会讲到这类算法。这里我们来看一下增长阶数的现实意义

49
00:04:53,150 --> 00:04:59,352
关于这个我们不会详细讲太多，除非是我们

50
00:04:59,352 --> 00:05:04,723
非常感兴趣的算法，那些线性和线性对数阶的能够解决

51
00:05:04,723 --> 00:05:11,633
巨大规模的问题的算法。因为即使

52
00:05:11,635 --> 00:05:17,913
现在一般的比较快的计算机能处理的平方阶问题的规模

53
00:05:17,913 --> 00:05:23,246
大约也只有几万，对于立方阶问题只有几千。而近年来

54
00:05:23,246 --> 00:05:28,567
这些算法并没有什么用，因为我们获得的数据的量更大，比如上百万

55
00:05:28,567 --> 00:05:34,689
十亿或者上万亿。随着时代的发展这个问题变得

56
00:05:34,689 --> 00:05:41,269
越来越明显。早期时候还有一些讨论平方阶算法

57
00:05:41,269 --> 00:05:47,154
是否有用，随着时间发展情况越来越严峻

58
00:05:47,154 --> 00:05:52,593
所以我们需要更好的算法。为了展示

59
00:05:52,593 --> 00:05:57,756
描述算法性能的数学模型的建立过程，我们来看一个

60
00:05:57,756 --> 00:06:03,037
大家很熟悉的例子，二叉搜索。这个算法的目标是，给定

61
00:06:03,037 --> 00:06:08,323
一个有序整数数组并给定一个值，想要知道这个值在数组中

62
00:06:08,323 --> 00:06:13,321
是否存在。如果存在，它在什么位置？我们知道的能处理这个问题的

63
00:06:13,321 --> 00:06:18,178
一种快速的算法是二叉搜索，我们将给定值和位于中间的条目比较

64
00:06:18,178 --> 00:06:22,941
例如，我们找33，和53比较

65
00:06:22,941 --> 00:06:27,737
33比53小，所以应该在数组的左半边。如果给定值更大

66
00:06:27,737 --> 00:06:32,819
则知道应该在数组的右半边。如果相等，那么我们就找到了那个条目

67
00:06:32,819 --> 00:06:39,680
然后递归使用同样的算法。我们来很快地看一下演示

68
00:06:39,680 --> 00:06:45,777
我们要在这个数组中寻找33，将它和数组中间的条目53比较

69
00:06:45,777 --> 00:06:51,160
33比53小所以往左边继续找，现在我们可以将注意力集中在数组左半边

70
00:06:51,160 --> 00:06:56,788
查看这半边的中间，是25，33更大，所以我们到右边继续找

71
00:06:56,788 --> 00:07:02,399
现在集中在原数组左侧的右半边

72
00:07:02,399 --> 00:07:08,690
我们有了一个更小的子数组。查看中间的条目，33更小，向左边走

73
00:07:08,690 --> 00:07:15,019
现在只剩下一个元素了，我们在数组中找到了33这个元素，返回

74
00:07:15,019 --> 00:07:21,234
它的索引：4。如果要找的给定值不在数组中

75
00:07:21,234 --> 00:07:26,874
进行的是同样的过程。比如，我们要找34，过程是一样的

76
00:07:26,874 --> 00:07:32,923
先看左半边，然后看右半边，再看43的左半边。现在只剩下一个

77
00:07:32,923 --> 00:07:39,478
条目了，并不是34。所以我们说34不在数组中。这就是二叉

78
00:07:39,478 --> 00:07:47,488
搜索。这是二叉搜索的代码。实际上，虽然二叉搜索

79
00:07:47,488 --> 00:07:53,391
是个简单的算法，却是众人皆知很难把每个细节实现正确的

80
00:07:53,391 --> 00:07:58,827
实际上，有一篇文章指出，知道1962年才发表了第一个没有错误的二叉搜索算法

81
00:07:58,827 --> 00:08:04,430
甚至到了2006年，依然从二叉搜索的Java实现中还找到了一个错误

82
00:08:04,430 --> 00:08:09,417
这只是举例说明一下在开发算法是我们需要极其小心

83
00:08:09,417 --> 00:08:15,847
尤其是上百万人要使用的库中的实现。这里是

84
00:08:15,847 --> 00:08:24,048
一种实现。虽然我们能以递归的形式实现但这种实现不是递归的

85
00:08:24,048 --> 00:08:32,050
这段代码直接对应我之前描述工作流程

86
00:08:32,050 --> 00:08:41,029
要在一个数组中找到一个关键字，我们使用两个指针，下限 lo 和上限 hi

87
00:08:41,029 --> 00:08:46,051
来表示数组中我们感兴趣的部分。只要lo 小于等于 hi 时

88
00:08:46,051 --> 00:08:51,053
我们计算中间值 mid，然后将关键字与中间值比较

89
00:08:51,053 --> 00:08:56,082
这其实是一个三向比较，判断是小于、大于还是等于

90
00:08:56,082 --> 00:09:02,011
如果关键字与中间值相等，返回中间值。如果小于中间值，则重新设置hi 指针

91
00:09:02,011 --> 00:09:07,026
如果大于中间值，重新设置 lo 指针。继续循环直到两个指针相等

92
00:09:07,026 --> 00:09:12,034
如果两个指针已经相等，还没有找到关键字，则返回-1。考虑这个

93
00:09:12,034 --> 00:09:18,023
这个不变式就容易理解这个算法是能行得通的：

94
00:09:18,023 --> 00:09:24,025
如果数组中存在要寻找关键字，则它在 lo 和 hi 之间的子数组中

95
00:09:24,025 --> 00:09:30,036
好的，这个程序你可能已经熟悉了

96
00:09:30,036 --> 00:09:36,039
我们来看它的数学分析。下面这个定理很容易证明

97
00:09:36,039 --> 00:09:42,049
这门课中我们不会做非常多的证明，但这个值得证一下

98
00:09:42,049 --> 00:09:48,045
那么这个定理是在大小为N的有序数组中完成一次二叉搜索

99
00:09:48,045 --> 00:09:55,032
最多需要 1 + lg N 次比较。我们首先将问题明确一下，定义

100
00:09:55,032 --> 00:10:02,089
变量T(N)，表示对于大小为N的数组进行二叉搜素所需要的比较次数

101
00:10:02,089 --> 00:10:10,001
然后根据代码写出对应的递推关系式

102
00:10:10,001 --> 00:10:16,076
程序将问题一分为二，那么

103
00:10:16,076 --> 00:10:23,000
如果T(N)小于等于T(N/2)加上，这一项取决于你怎么对比较计数

104
00:10:23,000 --> 00:10:29,045
我们把它看作是二向比较，分成两半需要进行一次比较

105
00:10:29,045 --> 00:10:35,046
只要N大于1，这个递推关系就是成立的。当N为1时

106
00:10:35,046 --> 00:10:42,039
T(1)等于1。这就是描述这个计算过程的递推关系

107
00:10:42,039 --> 00:10:48,094
我们通过将递推关系代入

108
00:10:48,094 --> 00:10:55,882
右边第一项来求解，这叫裂项求和

109
00:10:55,882 --> 00:11:03,378
所以如果这个式子成立，我们就能对T(N/2)用这个式子，提出另一个1

110
00:11:03,378 --> 00:11:09,096
对T(N/4)继续使用这个式子，又提出一个1

111
00:11:09,096 --> 00:11:15,340
如此操作，直到N=1，这时我们提出了lg N个1

112
00:11:15,340 --> 00:11:21,794
这是一个证明提纲，你可能注意到了，这个证明

113
00:11:21,794 --> 00:11:29,118
只在N是2的幂时才成立。因为我们并没有在这个递推关系中明确

114
00:11:29,118 --> 00:11:36,985
如果N是奇数这个式子是什么意思。但是继续推导，将奇数的情形

115
00:11:36,985 --> 00:11:45,649
考虑进来也是可以的，并且能够证明二叉搜索的运行时间

116
00:11:45,649 --> 00:11:52,779
总是对数阶的。好，基于这个事实，我们可以为3-SUM问题设计一个

117
00:11:52,779 --> 00:11:58,548
更快的算法，一种基于搜索的算法

118
00:11:58,548 --> 00:12:04,638
将输入中的数进行排序

119
00:12:04,638 --> 00:12:11,553
下周我们讨论排序算法。排序需要正比于

120
00:12:11,553 --> 00:12:18,416
N lg N的时间完成，不过这不是计算的主要部分。主要部分是

121
00:12:18,416 --> 00:12:25,682
数字完成排序之后，查看每对数字

122
00:12:25,682 --> 00:12:32,452
a[i]和a[j]。对-(a[i]+a[j])进行二叉搜索。如果找得到

123
00:12:32,452 --> 00:12:41,319
则我们有了一组三整数其和为0。我们对数字排序，并检查

124
00:12:41,319 --> 00:12:48,610
每一对数，检查是否存在其和的负数。-40，0

125
00:12:48,611 --> 00:12:55,631
取反是40，二叉搜索，找到了，那么就得到了3-SUM问题

126
00:12:55,631 --> 00:13:02,081
其中一个解。对每一对数如此操作。简单分析一下

127
00:13:02,081 --> 00:13:08,243
运行时间增长阶数，是N^2 lg N。并不需要

128
00:13:08,243 --> 00:13:14,064
非常好的搜索算法，可以用最基本的插入排序，我们会讲到的第一个排序算法

129
00:13:14,064 --> 00:13:20,678
但是对于每一对数进行二叉搜索的运行时间

130
00:13:20,678 --> 00:13:26,712
对N^2或者N^2/2对进行二叉搜索

131
00:13:26,712 --> 00:13:32,997
得到N^2 lg N的运行时间。下面简单举例如何改进性能

132
00:13:32,997 --> 00:13:39,970
N很大时，N^2 lg N 比 N^3 小得多

133
00:13:39,970 --> 00:13:46,462
我们同时也提出了假设，如果按照这个基于排序的

134
00:13:46,462 --> 00:13:51,872
算法处理并使用二叉搜索，我们将有一个更快的程序

135
00:13:51,872 --> 00:13:58,257
当然我们可以做一些实验，可以发现

136
00:13:58,257 --> 00:14:03,498
为了求解8000个数的问题，之前的算法需要50s

137
00:14:03,498 --> 00:14:08,858
现在已经不到1s了。50s我们可以求解大到64000的问题了

138
00:14:08,858 --> 00:14:15,118
所以一般我们期望更好的增长阶数意味着程序在实际运行中更快

139
00:14:15,118 --> 00:14:21,051
不过当检验具体的算法时，我们可以

140
00:14:21,051 --> 00:14:26,731
通过测试发现哪个算法更快。当然

141
00:14:26,731 --> 00:14:31,893
增长阶数由N^3变为N^2 lg N，我们期望算法比之前

142
00:14:31,893 --> 00:14:33,003
好得多了