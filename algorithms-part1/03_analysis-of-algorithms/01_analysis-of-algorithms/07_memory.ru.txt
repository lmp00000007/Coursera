До сих пор мы говорили
о времени выполнения, нужно поговорить и о потребностях
программ в памяти. Необходимо знать, сколько байт памяти использует программа. Обычно речь будет идти о миллионах
или миллиардах байт. И, как ни странно, существует полемика
по поводу даже этих базовых определений. Миллион бит для программистов —
это 2 в 20-й степени, а миллиард — 2 в 30-й степени,
потому что именно столько комбинаций есть у 30 бит.
Всё согласуется с нашими расчетами. Другие ученые придерживаются терминологии 1 миллион
 и 1 миллиард по множеству причин. Я обычно буду говорить 2 в 20,
подразумевая мегабайт. Много лет компьютеры были 32-битными, указатели там занимали 4 байта. В последние годы мы перешли
на 64-битные системы, и указатели в них 8-байтные. Это позволяет нам формировать адреса для гораздо большей памяти,
но и указатели занимают гораздо больше места. Этот переход поначалу вызвал
много проблем: программы стали занимать больше места,
чем ожидали пользователи. Больше подобных переходов
совершать не придется, потому что 64-бита точно хватит
 для адресации всего, что необходимо. 2 в 64й степени — огромное число. Итак, в терминах байтов будем говорить
о типовом использовании памяти. Это сильно зависит
от компьютера и реализации, но числа адекватные
и соответствуют типичной реализации. Итак, логический (булевский) тип.
Булевские переменные — это просто истина или ложь,
но на них тратится байт. Символ занимает 2 байта — 16 бит. Недавно мы использовали
8 бит для символа. Целое число (int) занимает 4 байта или 32 бита. Число с плавающей точкой — 4 байта,
длинное целое и двойное целое — 8. Двойное целое (double) используется
для плавающей точки, а int для целых. Это то, что касается примитивных типов. Для массивов существуют определенные
затраты памяти на их объявление, а далее затраты на каждый элемент,
умноженные на их количество. Для массива двойных целых это 8N+24. Для двумерного массива. Можно вычислить точное значение, а можно использовать тильда нотацию. Для одномерных массивов
двойных целых чисел ~8N, для двумерных массивов
двойных целых чисел ~8M*N. Есть слагаемые, которые увеличивают
расходы памяти, но для больших значений M и N
оценки будут вполне точными. Это расходы памяти для примитивов и массивов в типичной java реализации. Многие программы используют объекты,
вроде LinkedList и так далее. Нужно учесть затраты
памяти на заголовок объекта, затраты на ссылки, а также отступы, нужные для выравнивания
 размера каждого объекта на значение, кратное 8 байтам. Например, есть объект Date
с тремя переменными типа int, такой объект займет в целом 32 байта:
каждый int займет 4 байта, на заголовок потребуется 16 байт, 4 байта на отступ — всего 32 байта. Другим часто используемым типом
является строка. Строка устроена чуть сложнее, чем массив. Но типичные реализации строк в java содержат ссылку на массив символов. Кроме того, в них содержатся целые значения для хранения текущего смещения,
 счетчика, хеша строки и отступа. Складывая все вместе, получаем затраты памяти
около 2N + 64 байт. Это основы, необходимые нам для анализа использования памяти
типичной java программой. Итак, для примитивов:
4 байта для int, 8 для double и так далее. Ссылка будет занимать 8 байт,
т.к. столько занимает указатель. Массив - 24 байта плюс память для каждого элемента.
 Для объекта - 16 байт плюс память для инцидентной переменной,
плюс, если есть вложенный класс, то еще дополнительные 8 байт,
 как в примере с узлами связанного списка. Ещё отступ. Придется определить, кто отвечает за ссылочные объекты в некоторых ситуациях, и мы обратим на это внимание,
когда доберемся до таких ситуаций. Для примера рассмотрим анализ
использования памяти функцией WeightedQuickUnionUF,
с которой мы познакомились несколько лекций назад. Здесь всего пара элементов,
работающих с памятью, которые легко анализируется
с помощью данных нами основ. Это объект, поэтому учитываем
16 байт на заголовок. Здесь два целочисленных массива, у каждого из них есть заголовок на 24 + 4*N,
где N - число элементов массива. Каждый из N элементов
занимает четыре байта, далее у нас 4 байта для переменной count
и 4 байта на отступ. Если сложить всё вместе, получаем 8*N + 88, то есть ~8*N. То есть при большом N, нас интересует только 2*N целых чисел,
если говорить об анализе памяти. Два массива целых чисел размера N,
каждое из которых занимает 4 байта, с общей суммой 8N байт. Резюмируем: мы действительно
можем вычислять быстродействие программ
на современных компьютерах. Можно делать это эмпирически,
запуская программу и проводя эксперименты, формулировать гипотезы
и делать предположения. А можно производить математический анализ,
определяя самые затратные операции и то,
как часто они выполняются. А используя тильда нотацию
для упрощения анализа, мы можем объяснить поведение,
 а не просто предсказывать его. Это хороший пример использования
научного метода для понимания изучаемых нами алгоритмов. Наши математические модели
обычно не зависят от конкретной системы
и даже применимы к ещё несозданным компьютерам. Но мы всегда проверяем модели,
выполняя эксперименты, чтобы быть уверенными в предположениях и результатах анализа алгоритмов.