지금까지는 러닝 타임에 대해 얘기했는데요 이제 프로그램의 메모리 요구사항에 대해 얘기해볼게요 기본적으로 프로그램에 한번에 필요한 비트 혹은 바이트 수를 알고싶습니다. 실제 얘기하는 규모는 수백만 혹은 수십억 바이트입니다. 이런 가장 기본사항 조차도 논쟁이 있습니다. 컴퓨터 공학자는 백만비트가 2^20 , 십억 비트는 2^30이라고 생각하는데, 이것이 30비트에 집어넣을 수 있는 가능량이기 때문입니다. 또한 계산 과정이 일관적입니다. 다른 과학자들은 백만 / 십억이라는 표현을 고집하는데요 저는 보통 메가바이트를 표현할때 2^20을 씁니다 오래된 컴퓨터는 수년동안 32비트 머신을 써왔습니다. 그로인해 포인터는 4바이트가 되죠. 최근에는, 64비트 머신으로 대부분 교체가 되었는데요. 그로인해 포인터는 8바이트입니다. 이로인해 훨씬 많은 메모리를 어드레스할 수 있지만, 포인터가 더 많은 공간을 사용합니다. 이런 교체로 초기에는 많은 문제점이 있었습니다. 사람들이 생각했던것보다 프로그램의 메모리 사용량이 더 많아서였죠. 여러분은 그 당시 겪었던 이런 교체를 다시 거쳐갈 필요는 없는데요 64비트는 여러분에게 충분한 메모리 주소를 제공하기 때문입니다. 2^64은 굉장히 큰 수입니다. 이제 바이트 견지에서, 전형적인 메모리 사용부터 시작해봅시다. 이건 머신과 구현에 따라 다를수있지만 여기 숫자는 꽤 합리적이고, 전형적인 구현에 기반합니다. 불리언의 경우에는 참 혹은 거짓이니 1비트면 충분하겠지만 실제로는 불리언 계산을 위해서는 1바이트를 씁니다. 당연히 1바이트는 1바이트를 쓰고, 캐릭터는 2바이트, 즉 16비트를 씁니다. 캐릭터로 8비트를 썻던 적은 그렇게 오래되지는 않았습니다. 정수, 보통 정수는 4바이트, 즉 32비트를 씁니다. 플로트는 4바이트를 쓰고, 롱(long) 정수는 8바이트, 더블은 8바이트를 씁니다. 보통 대부분의 어플리케이션에서는  부동소수점에는 더블을 쓰고, 정수로 int를 씁니다. 여기까지 원시타입이였습니다. 배열에 관해서 보면, 배열을 만드는데 상당한 오버헤드가 있습니다. 배열에 N아이템이 있으면, 해당 원시타입의 바이트 * N만큼 비용이 들죠. 더블형 배열의 경우 8N+24입니다. 이차원 배열을 봅니다. 정확히 계산해볼수도 있지만, 지금은 틸드 표기법을 쓸 때입니다. 더블형 배열일경우, 일차원일때는 ~8N이라고 쓸 수 있습니다. 이차원일 경우에는, ~8MN입니다. 오버헤드를 처리할 추가 항이 있지만, 큰 M,N에 대해서는 틸드 표기법은 꽤 정확할 겁니다. 여기까지 전형적인 구현에 있어서 원시타입과 배열의 기본적인 사용이였습니다. 요즘 많은 프로그램들이 linkList등의 객체를 쓰는데요, 이 경우 객체 오버헤드도 계산에 넣어야합니다. 참조에 드는 비용과 전형적인 구현에 있어서 내장된 패딩이 있는데요 이로인해 개별 객체가 8바이트를 여러번 쓰게 됩니다. 예를들면 데이트 객체는 세 개의 정수형 인스턴스 변수를 가지는데요, 그로인해 데이트 객체는 32바이트를 쓰는데, 개별 정수형이 4바이트씩, 객체 오버헤드가 16바이트, 또한 패딩때문에 4바이트가 필요해서, 총 32바이트가 됩니다. 또 잘 쓰는게 스트링(문자열)인데요. 스트링은 배열보다는 조금  복잡한데 자바에서 스트링의 전형적인 구현은 문자열 배열을 참조하는데, 오프셋,카운트,해쉬 값으로 정수형과  기타 패딩을 다 더하면 문자열의 비용은 2N+64바이트가 됩니다. 여기까지가 전형적인 자바구현에 있어서 메모리 사용을 분석하는데 필요한 사항이였습니다. 데이터 타입의 값의 경우에는, 원시타입으로 정수는 4바이트 더블로는 8바이트를 씁니다. 참조형이라면 8바이트가 포인터가 취하는 값이됩니다. 배열의 경우 24바이트 + 개별 엔트리의 메모리가 되고, 객체의 경우 16바이트 + 인스턴스 변수의 메모리 + 이너클래스가 있을 경우 다시 노드나 linkedLIst를 말할때 8바이트가 추가됩니다. 또한 패딩까지 있습니다. 이제 일부 케이스에서 참조된 객체에 있어 책임문제를 다뤄야 합니다. 해당 상황이 발생하면, 그 때 다루겠습니다. 간단한 메모리 사용 분석을 예로들면, 얼마전 강의에 나왔던 WeightedQuickUnionUF(N)이 메모리를 얼마나 차지하는지 보겠습니다. 몇개의 메모리 요소가 있는데요, 각각의 것들은 방금 전 내용으로 쉽게 분석이 가능합니다. 객체니깐 객체 오버헤드 때문에 16바이트, 두 개의 정수형 배열의 경우 각각 배열 오버헤드로 24바이트 + N 엔트리의 경우 4N 입니다. N 엔트리 각각마다 4바이트를 씁니다. 카운트로 4바이트, 패딩으로 4바이트 다 합치면 8N+88인데 틸드 표기법으로는 8N이 됩니다. 다시 설명하면, N이 충분히 큰 상황에서는 메모리 분석에 있어 우리가 신경쓸 부분은,  N개의 정수 두 번입니다. 사이즈가 N인 두개의 배열을 말하는데요, 각각 엔트리가 4바이트를 차지하니깐 다합치면 N바이트가 되는겁니다. 요약하면, 우리는 현대 컴퓨터의 크랭크를 얼마나 돌려야하는지 정확하게 말할 수는 없습니다. 대신 경험적 분석으로 하는데요, 실제로 프로그램을 구동해보고 멱법칙을 가정하고, 가설을 만들어서 예상을 해보는겁니다. 여기서 더나가서, 가장 비용이 많이 드는 작업을 수학적으로 분석해서 해당 작업 처리에 드는 주파수를 분석할 수 있습니다. 분석을 간단화하기 위해 틸드 표기법을 쓰고 실제로 예상을 넘어서서 설명을 할 수 있습니다. 이것이 과학적 분석을 공부하고 있는 유물, 즉 알고리즘을 분석합니다. 수리적 분석은 보통 특정한 컴퓨터 시스템과는 독립적인 편이고, 심지어는 아직 구현되지 못한 머신에도 적용됩니다. 그러나 실제 머신에 실제로 실험을 해봄으로써 수리적 모델을 입증하는데, 그로인해 예측을 하거나 알고리즘을 분석하는데 자신감을 가지게됩니다.