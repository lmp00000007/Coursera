1
00:00:09,035 --> 00:00:15,063
В первую очередь необходимо сделать некоторые наблюдения о времени

2
00:00:15,063 --> 00:00:22,004
работы. Для анализа алгоритмов это легче, чем для многих

3
00:00:22,026 --> 00:00:27,096
научных дисциплин, как мы увидим. Для примера мы будем использовать

4
00:00:27,096 --> 00:00:34,016
задачу о сумме 3 чисел. У этой задачи простая постановка. Если у вас есть

5
00:00:34,016 --> 00:00:40,254
N целых чисел, как много троек в сумме дают ноль? Для примера в файле 8ints.txt

6
00:00:40,254 --> 00:00:48,096
текст который содержит 8 целых чисел. Среди них есть три тройки в сумме дающие 0. 30

7
00:00:48,096 --> 00:00:56,832
-40, 10. 30, -20, -10 и так далее. Наша цель написать программу,

8
00:00:56,832 --> 00:01:03,554
которая вычисляет это число для любого входного файла, любого набора N целых чисел.

9
00:01:03,554 --> 00:01:09,796
Это очень важные вычисления, которые глубоко связаны со многими

10
00:01:09,796 --> 00:01:16,446
задачами в вычислительной геометрии — разделом в компьютерных науках,

11
00:01:16,446 --> 00:01:24,536
который занимается алгоритмами и лежит в основе графики, фильмов

12
00:01:24,536 --> 00:01:32,040
и геометрических моделей любого рода. Т.е. это важная практическая задача.

13
00:01:32,040 --> 00:01:40,459
Но для нее просто написать код. Вы могли бы написать эту программу

14
00:01:40,759 --> 00:01:49,583
без больших усилий. Это статический метод count, который принимает

15
00:01:49,583 --> 00:01:56,317
массив целых чисел. N — это целое число,

16
00:01:56,317 --> 00:02:02,660
длина массива. Мы начинаем с переменной count равной 0,

17
00:02:02,660 --> 00:02:09,363
и затем тройной цикл, который проверяет тройку i,j,k мы проходим i от 1 до n

18
00:02:09,363 --> 00:02:15,181
j от i+1 до n, и k от j+1 до n, так мы проверяем каждую тройку только раз.

19
00:02:15,181 --> 00:02:19,818
когда a[i]+a[j]+a[k] = 0, мы увеличиваем count на 1. И после

20
00:02:19,818 --> 00:02:25,093
этого тройного цикла count. И затем метод main, в этом 

21
00:02:25,093 --> 00:02:30,769
простом классе просто читает все целые числа и выводит count. 

22
00:02:30,769 --> 00:02:35,696
Это грубый алгоритм для решения задачи суммы трех чисел.

23
00:02:35,696 --> 00:02:41,615
Сейчас нас интересует, как долго займет вычисление

24
00:02:41,615 --> 00:02:47,808
функции от n. Одни способ замерить время нашей программы это просто посмотреть на часы, если у вас

25
00:02:47,808 --> 00:02:54,925
есть секундомер, или часы в телефоне, или что-нибудь для измерения времени,

26
00:02:54,925 --> 00:03:02,164
можете использовать их если хотите. В Java есть библиотека

27
00:03:02,164 --> 00:03:09,024
класс stopwatch который вычисляет промежутки времени.

28
00:03:09,024 --> 00:03:15,968
Каждый раз когда вы запускаете программу, если она настроена на ввод

29
00:03:15,968 --> 00:03:23,990
разного размера, естественным будет просто запустить ее для больших задач. Для 8

30
00:03:23,990 --> 00:03:32,381
целых эта программа занимает не много времени, для 1000 занимает пол секунды. Для

31
00:03:32,381 --> 00:03:42,303
2000 занимает больше времени, 3.7 секунды. Запустим еще раз, все равно 3.7.

32
00:03:42,303 --> 00:03:50,231
Для 4000, мы каждый раз удваиваем размер входных данных и это определенно

33
00:03:50,231 --> 00:03:58,930
занимает больше времени каждый раз. Есть программисты,

34
00:03:58,930 --> 00:04:05,490
которые тестируют время своих программ

35
00:04:05,490 --> 00:04:13,038
и могут достаточно просто и быстро оценить, когда они должны завершиться.

36
00:04:13,038 --> 00:04:20,010
Вместо того, чтобы каждый раз ждать, можно вычислить.

37
00:04:20,010 --> 00:04:27,000
Для 4000 выполнение занимает 30 секунд. Можно вычислить,

38
00:04:27,000 --> 00:04:33,047
сколько времени потребуется для 8000, сейчас покажу как.

39
00:04:33,047 --> 00:04:40,037
Я не буду ждать сейчас

40
00:04:40,037 --> 00:04:45,203
Это эмпирический анализ, запущенный для разного входного размера 

41
00:04:45,203 --> 00:04:51,869
и замеренного времени запуска. Если бы это была некоторая научная проблема,

42
00:04:51,869 --> 00:04:57,320
когда мы считаем что-то происходящее в окружающем мире — число муравьев в муравейнике

43
00:04:57,320 --> 00:05:03,255
то у нас было бы всего несколько точек данных,

44
00:05:03,255 --> 00:05:08,837
по которым мы бы пытались построить график.

45
00:05:08,837 --> 00:05:15,240
Получаем кривую подобную этой.

46
00:05:15,240 --> 00:05:21,767
Много научных задач попадает

47
00:05:21,767 --> 00:05:29,001
под этот класс и изображаются графиком.

48
00:05:29,001 --> 00:05:36,320
Очень часто получаем прямую линию. И наклон этой прямой, это ключ к тому,

49
00:05:36,320 --> 00:05:41,582
что происходит. В данном случае наклон прямой это 3.

50
00:05:41,582 --> 00:05:49,272
Можно произвести регрессию и получить прямую

51
00:05:49,272 --> 00:05:55,078
через точки данных. И затем сделать расчеты чтобы показать что если вы

52
00:05:55,078 --> 00:06:01,409
получили прямую линию  с наклоном B, то ваша функция пропорциональна aN^b. 

53
00:06:01,409 --> 00:06:06,799
Это называется степенной зависимостью. И это верно для многих и многих научных 

54
00:06:06,799 --> 00:06:13,633
задач включая большинство алгоритмов. Немного математики.

55
00:06:13,633 --> 00:06:22,794
Прямая линия, т.к. мы делали график log-log по основанию 3, означает что

56
00:06:22,794 --> 00:06:29,850
lg(T(N)) = BlgN+C. И у нас есть наши эмпирические значения B и C и если затем

57
00:06:29,850 --> 00:06:37,950
возведем обе части этого уравнения в степень 2 и получим: T(N) = aN^b.

58
00:06:37,950 --> 00:06:44,422
Т.е. прямо из наблюдений у нас есть довольно хорошая

59
00:06:44,422 --> 00:06:50,512
модель времени работы нашей программы.  Мы можем вывести и сделать расчеты,

60
00:06:50,512 --> 00:06:59,028
как мы и думали время работы примерно 10^-10N^3 секунд.

61
00:06:59,028 --> 00:07:05,053
Мы можем использовать эту гипотезу, чтобы сделать предсказание. Подставляем различные

62
00:07:05,053 --> 00:07:11,067
значения N. Для 16000 получается 400с.

63
00:07:11,067 --> 00:07:16,059
Довольно много времени, но теперь мы можем пойти дальше и запустить этот 

64
00:07:16,059 --> 00:07:22,611
эксперимент и удостовериться, что мы достаточно близко к этим 408 секундам.

65
00:07:22,611 --> 00:07:27,109
Можем сделать предсказание для 32000 или любого другого значения.

66
00:07:27,109 --> 00:07:32,219
Эта модель помогает делать предсказания

67
00:07:32,219 --> 00:07:38,927
без необходимости запускать эксперимент. В большинстве компьютерных

68
00:07:38,927 --> 00:07:45,689
алгоритмов присутствует степенная зависимость.

69
00:07:45,689 --> 00:07:51,812
имеет зависимость от степени. Что мы можем сделать это просто удвоить время размер водных данных каждый раз

70
00:07:51,812 --> 00:07:58,009
как делали и взять отношение времени запуска для N и 2^N. И если вы сделаете 

71
00:07:58,009 --> 00:08:04,713
это, то соотношение будет сходиться к константе. Действительно, log от отношения

72
00:08:04,713 --> 00:08:10,258
будет сходиться константе.

73
00:08:10,258 --> 00:08:16,342
Небольшими вычислениями можно это проверить.

74
00:08:16,342 --> 00:08:21,460
Это очень простой способ проверить время работы.

75
00:08:21,460 --> 00:08:26,756
У нас есть быстрый способ оценить b,

76
00:08:26,767 --> 00:08:33,342
как оценить a? Мы можем запустить и решить это. Как только мы решили

77
00:08:33,342 --> 00:08:41,138
что это экспонента трех, запустим это для больших N и  получим достаточно

78
00:08:41,138 --> 00:08:48,197
точную модель, сравнимую с графиком. Это практически та же самая

79
00:08:48,197 --> 00:08:56,197
гипотеза и мы просто получаем результат запуская программу удваивая N каждый раз.

80
00:08:56,522 --> 00:09:04,905
Много факторов влияют на время работы программы

81
00:09:04,905 --> 00:09:10,182
на компьютере. Ключевой эффект независим от того, что за компьютер используется.

82
00:09:10,182 --> 00:09:15,004
Это алгоритм и данные. Они определяют 

83
00:09:15,004 --> 00:09:20,269
показатель степенной зависимости. И есть много 

84
00:09:20,269 --> 00:09:25,632
системнозависимых эффектов. Что за оборудование вы используете. Быстрый ли у вас

85
00:09:25,632 --> 00:09:30,056
 компьютер или медленный. Что за ПО. Что запущено

86
00:09:30,056 --> 00:09:35,095
на компьютере. Все эти факторы определяют константу a.

87
00:09:35,095 --> 00:09:40,894
В настоящее время влияние оборудования и обеспечения

88
00:09:40,894 --> 00:09:46,288
сложно оценить точно. Но с другой стороны

89
00:09:46,288 --> 00:09:52,050
не нужно ставить опыты над животными или лететь на другую планету,

90
00:09:52,050 --> 00:09:57,304
мы просто запускаем много экспериментов,

91
00:09:57,304 --> 00:10:00,032
чтобы разобраться с этими эффектами.