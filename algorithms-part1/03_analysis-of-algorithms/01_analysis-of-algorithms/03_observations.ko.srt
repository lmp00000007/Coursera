1
00:00:09,035 --> 00:00:15,063
좋습니다. 이제 첫 단계는 프로그램의
 실행 시간을 관찰할 수 있도록 하는 겁니다.

2
00:00:15,063 --> 00:00:22,004
곧 보게 되겠지만, 알고리즘의 분석은
 다른 과학 학문분야들에 비해 쉽습니다.

3
00:00:22,026 --> 00:00:27,096
실례로 소위 3-합 문제
(3-sum problem)를 다루어봅시다.

4
00:00:27,096 --> 00:00:34,016
문제는 간단합니다.
 N 개의 서로 다른 정수가 있는데,

5
00:00:34,016 --> 00:00:40,254
이 중 3개를 뽑았을 때 합이 0이 되도록 하는
 경우의 수는 몇 가지인가요? 8ints.txt 파일에선

6
00:00:40,254 --> 00:00:48,096
8개의 데이터가 들어가있습니다만,
 네 가지 경우가 0을 이룹니다.

7
00:00:48,096 --> 00:00:56,832
(30, -40, 10), (30, -20, -10) 등이 있죠.
 따라서 우리 목적은 어떤 입력 파일이 주어지면

8
00:00:56,832 --> 00:01:03,554
그 파일이 N개의 정수의 집합을 가질 때,
 이 3-합을 계산하는 프로그램을 작성하는 겁니다.

9
00:01:03,554 --> 00:01:09,796
이 문제는 사실 매우 중요한 계산이고,
 계산기하학에서의 여러 문제와 깊이 관련되어 있습니다.

10
00:01:09,796 --> 00:01:16,446
계산기하학(computational geometry)는
 컴퓨터 과학의 한 분과로, 그래픽, 영화,

11
00:01:16,446 --> 00:01:24,536
그리고 모든 종류의 기하 모델과
 관련된 알고리즘과 기저 과학을 다룹니다.

12
00:01:24,536 --> 00:01:32,040
그래서 이는 매우 중요한 실전 문제죠.

13
00:01:32,040 --> 00:01:40,459
하지만 다른 관점에선 코드를 작성하기 쉬운 문제라,
 여러분은 별 노력 없이 이 프로그램을

14
00:01:40,759 --> 00:01:49,583
작성할 수 있을 겁니다. 여기 우리가 살펴보려는,
 count라는 정적 메소드(static method)가 있고,

15
00:01:49,583 --> 00:01:56,317
이 메소드는 정수 배열 a를 인자로 받습니다.
 그리고 N은 정수인데요.

16
00:01:56,317 --> 00:02:02,660
배열의 길이입니다. 메소드의 시작에서
 변수 count는 0으로 초기화하고요.

17
00:02:02,660 --> 00:02:09,363
세 개의 for 루프가 있는데,
 각각의 가능한 세 수 (i, j, k)를 체크합니다. i는 0에서 N까지,

18
00:02:09,363 --> 00:02:15,181
j는 i+1부터 N까지, k는 j+1부터 N까지의 값을 갖기에,
 가능한 모든 세 수 각각을 한 번씩 확인합니다.

19
00:02:15,181 --> 00:02:19,818
따라서 만약 a[i] + a[j] + a[k]가 0과 같으면,
 count 변수를 1 증가시킵니다. 됐네요.

20
00:02:19,818 --> 00:02:25,093
이 세 for 루프가 끝나면, count 변수를 리턴합니다.
 그리고 이 간단한 클래스에서 main 메소드는

21
00:02:25,093 --> 00:02:30,769
단순히 모든 정수를 In.readInts를 통해 읽어들입니다.
 그리고 count 메소드의 리턴값을 출력하죠.

22
00:02:30,769 --> 00:02:35,696
이 알고리즘은 무식하게 푸는(brute force) 알고리즘으로,
 3-합 문제를 풀기엔 나쁘지 않은 방법입니다.

23
00:02:35,696 --> 00:02:41,615
이제, 우리가 관심 있는 것은, N의 함수로써
 count 메소드가 얼마만큼의 시간을 쓰느냐입니다.

24
00:02:41,615 --> 00:02:47,808
이 프로그램을 동작시간을 재는 한 방법은,
 시계를 그냥 보는 겁니다. 스톱워치가 있다면

25
00:02:47,808 --> 00:02:54,925
또는 시계나 스마트폰을 보거나,
 또 여러분이 원하는 다른 방법으로든,

26
00:02:54,925 --> 00:03:02,164
그저 실행시키고(go ahead) 원한다면
 시간을 재는거죠. 또는, JAVA를 쓰면,

27
00:03:02,164 --> 00:03:09,024
표준 라이브러리에 포함되어 있는,
 지난 시간을 계산하는 Stopwatch 클래스가 있습니다.

28
00:03:09,024 --> 00:03:15,968
그래서 프로그램을 실행 시킬 때,
 만약 다른 크기 입력을 쉽게 넣을 수 있다면

29
00:03:15,968 --> 00:03:23,990
꽤 큰 크기의 정수를 넣어 프로그램을
 실행하는 게 자연스럽겠죠.

30
00:03:23,990 --> 00:03:32,381
8 개의 정수를 담은 8ints.txt 파일은 별로 시간이 안 걸리지만,
 1,000 개의 정수는 약 0.5 초 정도 걸립니다.

31
00:03:32,381 --> 00:03:42,303
2,000 개의 정수는 시간이 더 걸리네요.
 약 3.7초입니다. 다시 실행시켜도 약 3.7초네요.

32
00:03:42,303 --> 00:03:50,231
4,000 개의 경우도 그렇겠죠. 입력 크기가
 2배가 될 때마다, 시간이 훨씬 더 걸립니다.

33
00:03:50,231 --> 00:03:58,930
사실 앞으로 보겠지만,
 프로그램의 실행시간을 테스팅하는 버릇이

34
00:03:58,930 --> 00:04:05,490
있는 프로그래머는
 이런 방법으로

35
00:04:05,490 --> 00:04:13,038
쉽고 빠르게 종료 시점을
 평가할 수 있습니다.

36
00:04:13,038 --> 00:04:20,010
사실, 끝낼 때까지 기다리는 동안,
 예상할 수 있어야 합니다.

37
00:04:20,010 --> 00:04:27,000
4,000 개의 경우 한 번에
 30초가 걸리네요.
 따라서 8,000개가 걸리는 데

38
00:04:27,000 --> 00:04:33,047
얼마나 걸릴지를 실행이 끝나기 전에
 예상할 수 있는데, 몇 초나 걸릴지 답해보세요.

39
00:04:33,047 --> 00:04:40,037
이젠 기다리질 못하겠네요.
 여러분이 생각한 방법에 대해 고민해 봅시다. 자,

40
00:04:40,037 --> 00:04:45,203
방금 본 건 실증적인 분석(empirical analysis)이죠.
 여러 크기의 입력을 넣어 실행하고

41
00:04:45,203 --> 00:04:51,869
그 실행 시간을 측정한 거죠.
 이제 이를 하나의 과학적인 문제로 생각해보면,

42
00:04:51,869 --> 00:04:57,320
자연계에서 벌어지는 무언가를 세는 상황인 겁니다.
 개미 무덤 (개미 집 출구)에 있는 개미의 수나

43
00:04:57,320 --> 00:05:03,255
또는 무엇이든 간에, 몇 개의 데이터 포인트만이 있으므로,
 동작 과정을 이해하기 위해

44
00:05:03,255 --> 00:05:08,837
실행 시간에 관한 그래프(plot)를 그려볼 수 있을 건데,
 우리가 관심이 있는 실행 시간을

45
00:05:08,837 --> 00:05:15,240
Y축에 나타내고, 문제의 크기 N을 X축에 나타냅니다.
 다음과 같은 곡선을 얻었네요.

46
00:05:15,240 --> 00:05:21,767
이런게 과학이 보통 하는 겁니다.
 왜나면 우리가 다루는 것과 같은 부류의 문제들 다수가

47
00:05:21,767 --> 00:05:29,001
그래프를 그릴 때 log-log 그래프를 그립니다.
 log-log 그래프로 그리면,

48
00:05:29,001 --> 00:05:36,320
보통 직선을 얻게 될 겁니다.
 그 직선의 기울기는

49
00:05:36,320 --> 00:05:41,582
동작 과정을 이해하는 핵심입니다.
 여기서는, 직선의 기울기가 3이고, 따라서

50
00:05:41,582 --> 00:05:49,272
데이터에 맞추기 위한 회귀(regression)으로 불리는 것을
 한 겁니다. 데이터 포인트를 지나는 직선을 구한거죠.

51
00:05:49,272 --> 00:05:55,078
이제, 수학을 해보면 어렵지 않게 보일 수 있지만,
 이 log-log 그래프에서 직선을 얻었고

52
00:05:55,078 --> 00:06:01,409
기울기가 b였다면,
 그 함수는 a*N^b에 비례합니다.

53
00:06:01,409 --> 00:06:06,799
이를 멱법칙(power law)이라 합니다.
이 법칙은 대부분의 알고리즘을 포함한 많은

54
00:06:06,799 --> 00:06:13,633
과학적 문제에서 참입니다.
 따라서 여기서 간단히 수학을 해봅시다.

55
00:06:13,633 --> 00:06:22,794
직선이 의미하는 바는, 우리가
 log-log 그래프를 2를 지수로 하여 그렸으므로,

56
00:06:22,794 --> 00:06:29,850
log(T(N)) = b log(N) + c입니다.
 따라서 실증 값(empirical value)들로 b와 c를 찾고,

57
00:06:29,850 --> 00:06:37,950
각 변을 밑이 2인 지수로 설정해 얻은 등식으로
 T(N)을 풀면 T(N) = a*N^b를 얻습니다.

58
00:06:37,950 --> 00:06:44,422
이를 통해 관찰로부터 프로그램의
 실행 시간에 대한 꽤 좋은 모델을 갖게 되었습니다.

59
00:06:44,422 --> 00:06:50,512
우리가 살펴보고 수학을 해본 결과,

60
00:06:50,512 --> 00:06:59,028
실행 시간은 약 ( 10^(-10) ) * N^3
 초인 것으로 보임을 알게 되었습니다.

61
00:06:59,028 --> 00:07:05,053
이제부터 이 가설을 활용해서
 예측을 해봅시다.

62
00:07:05,053 --> 00:07:11,067
N에다가 여러 값을 대입해보면,
 N=16,000일 때 400초가 걸림을 알 수 있습니다.

63
00:07:11,067 --> 00:07:16,059
400초는 꽤 오랜 시간이지만
 시간을 투자해 실험을 해보면

64
00:07:16,059 --> 00:07:22,611
실행 시간이 확실히 408 초 정도로
 꽤 근접함을 알 수 있습니다.

65
00:07:22,611 --> 00:07:27,109
이제 N=32,000인 경우 또는
 그 외의 관심있는 입력에 대해

66
00:07:27,109 --> 00:07:32,219
실행시간의 예측을 할 수 있습니다.
 이 모델은 우리가 실험을 하느라 비용을

67
00:07:32,219 --> 00:07:38,927
투자하는 일 없이 실행시간을
 예측할 수 있게 해줍니다. 사실 이 상황에서는

68
00:07:38,927 --> 00:07:45,689
멱법칙이 성립하는 경우 - 강조하면
 매우 많은 컴퓨터 알고리즘이 멱법칙을 따르는데 -

69
00:07:45,689 --> 00:07:51,812
우리는 입력을 두 배 늘려서
 실행해볼 수 있는데

70
00:07:51,812 --> 00:07:58,009
N일 때와 2N일 때의 실행 시간
 간의 비율을 계산해보세요.

71
00:07:58,009 --> 00:08:04,713
여러분이 해보면, 그 비율이 어떤 상수로
 수렴함을 알 것입니다. 사실은 그 비율의 로그값이

72
00:08:04,713 --> 00:08:10,258
어떤 상수로 수렴하는데, 이 상수는
 실행시간 모델에서 N의 지수 b에 해당합니다.

73
00:08:10,258 --> 00:08:16,342
이를 확인하기 위해선 약간 수학을 해야하는데,
 이를 통해 실행시간을 예측하는 것은

74
00:08:16,342 --> 00:08:21,460
매우 쉽고 자연스러운 방법입니다.
 방금 말한 것을 정리하면,

75
00:08:21,460 --> 00:08:26,756
이제 우리는 멱법칙 관계에서
 b를 예측하는 쉬운 방법을 가지게 된 겁니다.

76
00:08:26,767 --> 00:08:33,342
이제 어떻게 a를 예측할까요?
 음, 그냥 실행시킨 결과로 구한 a에 대한 방정식을 풉니다.

77
00:08:33,342 --> 00:08:41,138
즉 지수 b가 3임을 결정한 뒤에
 프로그램을 어떤 큰 N에 대해 실행하면

78
00:08:41,138 --> 00:08:48,197
우리가 여러 실험 결과로 그린
 그래프들과 거의 유사한 모델을 얻게 됩니다.

79
00:08:48,197 --> 00:08:56,197
이는 (a의 값에 다소의 차이가 있지만)
 거의 동등한 가설이고, N을 두 배로 늘려 프로그램을 실행해서 얻은 겁니다.

80
00:08:56,522 --> 00:09:04,905
그래서, 여러분의 컴퓨터에서 프로그램의
 실행시간을 이해할 때 다양한 효과들이 작용합니다.

81
00:09:04,905 --> 00:09:10,182
그리고 중요한 효과들은
 어떤 컴퓨터인지와는 독립적으로 작용합니다.

82
00:09:10,182 --> 00:09:15,004
그 효과란 여러분이 사용하는
 알고리즘과, 여러분의 입력 데이터입니다.

83
00:09:15,004 --> 00:09:20,269
이들은 멱법칙의 지수를
 결정하는 데 매우 중요합니다.

84
00:09:20,269 --> 00:09:25,632
물론 다양한 시스템 의존적 효과들도
 작용합니다. 어떤 하드웨어를 가지고 있는지,

85
00:09:25,632 --> 00:09:30,056
컴퓨터가 빠른 것인지 느린 것인지,
 어떤 종류의 소프트웨어인지, 컴퓨터에서

86
00:09:30,056 --> 00:09:35,095
어떻게 실행되는지 등, 이 모든 것들이
 멱법칙에서 상수 a를 결정합니다.

87
00:09:35,095 --> 00:09:40,894
그래서, 현대 시스템에서는, 하드웨어와
 소프트웨어에서 많은 일들이 일어나다보니

88
00:09:40,894 --> 00:09:46,288
때때로 매우 정확한 측정결과를
 얻는 게 매우 어렵습니다. 하지만 한 편으론

89
00:09:46,288 --> 00:09:52,050
다른 과학에서 하는 동물을 희생하거나,
 타 행성으로 비행하는 등의 행위를 할 필요가 없습니다.

90
00:09:52,050 --> 00:09:57,304
우린 그저 많은 실험을 수행해보고,
 보통 앞에서 소개한 것 같은 효과를

91
00:09:57,304 --> 00:10:00,032
신경쓰기만 하면 됩니다.