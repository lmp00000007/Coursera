1
00:00:02,200 --> 00:00:04,426
До сих пор мы говорили
о времени выполнения,

2
00:00:04,426 --> 00:00:08,070
нужно поговорить и о потребностях
программ в памяти.

3
00:00:09,710 --> 00:00:14,162
Необходимо знать, сколько байт памяти

4
00:00:14,162 --> 00:00:16,070
использует программа.

5
00:00:16,070 --> 00:00:21,440
Обычно речь будет идти о миллионах
или миллиардах байт.

6
00:00:21,440 --> 00:00:26,060
И, как ни странно, существует полемика
по поводу даже этих

7
00:00:26,060 --> 00:00:27,570
базовых определений.

8
00:00:27,570 --> 00:00:31,809
Миллион бит для программистов —
это 2 в 20-й степени,

9
00:00:31,809 --> 00:00:37,225
а миллиард — 2 в 30-й степени,
потому что именно столько

10
00:00:37,225 --> 00:00:42,586
комбинаций есть у 30 бит.
Всё согласуется с нашими расчетами.

11
00:00:42,586 --> 00:00:49,352
Другие ученые придерживаются терминологии 1 миллион
 и 1 миллиард по множеству причин.

12
00:00:49,352 --> 00:00:52,649
Я обычно буду говорить 2 в 20,
подразумевая мегабайт.

13
00:00:52,649 --> 00:00:58,479
Много лет компьютеры были 32-битными,

14
00:00:58,479 --> 00:01:01,449
указатели там занимали 4 байта.

15
00:01:02,720 --> 00:01:07,562
В последние годы мы перешли
на 64-битные системы,

16
00:01:07,562 --> 00:01:10,477
и указатели в них 8-байтные.

17
00:01:10,477 --> 00:01:16,650
Это позволяет нам формировать адреса для гораздо большей памяти,
но и указатели занимают гораздо больше места.

18
00:01:16,650 --> 00:01:22,260
Этот переход поначалу вызвал
много проблем:

19
00:01:22,260 --> 00:01:26,460
программы стали занимать больше места,
чем ожидали пользователи.

20
00:01:26,460 --> 00:01:30,929
Больше подобных переходов
совершать не придется,

21
00:01:30,929 --> 00:01:35,762
потому что 64-бита точно хватит
 для адресации всего,

22
00:01:35,762 --> 00:01:36,862
что необходимо.

23
00:01:36,862 --> 00:01:39,040
2 в 64й степени — огромное число.

24
00:01:41,040 --> 00:01:47,210
Итак, в терминах байтов будем говорить
о типовом использовании памяти.

25
00:01:47,210 --> 00:01:51,200
Это сильно зависит
от компьютера и реализации,

26
00:01:51,200 --> 00:01:56,950
но числа адекватные
и соответствуют типичной реализации.

27
00:01:56,950 --> 00:02:01,053
Итак, логический (булевский) тип.
Булевские переменные —

28
00:02:01,053 --> 00:02:05,447
это просто истина или ложь,
но на них тратится байт.

29
00:02:05,447 --> 00:02:10,440
Символ занимает 2 байта — 16 бит.

30
00:02:10,440 --> 00:02:14,290
Недавно мы использовали
8 бит для символа.

31
00:02:14,290 --> 00:02:18,000
Целое число (int) занимает 4 байта

32
00:02:18,000 --> 00:02:25,780
или 32 бита. Число с плавающей точкой — 4 байта,
длинное целое и двойное целое — 8.

33
00:02:25,780 --> 00:02:29,830
Двойное целое (double) используется
для плавающей точки,

34
00:02:29,830 --> 00:02:33,710
а int для целых.

35
00:02:33,710 --> 00:02:36,180
Это то, что касается примитивных типов.

36
00:02:36,180 --> 00:02:42,300
Для массивов существуют определенные
затраты памяти на их объявление,

37
00:02:42,300 --> 00:02:48,436
а далее затраты на каждый элемент,
умноженные на их количество.

38
00:02:48,436 --> 00:02:52,678
Для массива двойных целых это 8N+24.

39
00:02:52,678 --> 00:02:56,750
Для двумерного массива.

40
00:02:56,750 --> 00:03:01,900
Можно вычислить точное значение,

41
00:03:01,900 --> 00:03:05,250
а можно использовать тильда нотацию.

42
00:03:05,250 --> 00:03:09,837
Для одномерных массивов
двойных целых чисел ~8N,

43
00:03:09,837 --> 00:03:15,102
для двумерных массивов
двойных целых чисел ~8M*N.

44
00:03:15,102 --> 00:03:18,695
Есть слагаемые, которые увеличивают
расходы памяти,

45
00:03:18,695 --> 00:03:22,203
но для больших значений M и N
оценки будут вполне точными.

46
00:03:22,203 --> 00:03:25,081
Это расходы памяти для примитивов

47
00:03:25,081 --> 00:03:27,490
и массивов в типичной java реализации.

48
00:03:29,360 --> 00:03:33,720
Многие программы используют объекты,
вроде LinkedList и так далее.

49
00:03:33,720 --> 00:03:37,080
Нужно учесть затраты
памяти на заголовок объекта,

50
00:03:38,150 --> 00:03:43,640
затраты на ссылки, а также отступы,

51
00:03:43,640 --> 00:03:49,430
нужные для выравнивания
 размера каждого объекта на значение, кратное 8 байтам.

52
00:03:50,620 --> 00:03:57,650
Например, есть объект Date
с тремя переменными типа int,

53
00:03:57,650 --> 00:04:04,340
такой объект займет в целом 32 байта:
каждый int займет 4 байта,

54
00:04:04,340 --> 00:04:06,684
на заголовок потребуется 16 байт,

55
00:04:06,684 --> 00:04:09,590
4 байта на отступ — всего 32 байта.

56
00:04:11,830 --> 00:04:16,420
Другим часто используемым типом
является строка.

57
00:04:16,420 --> 00:04:22,234
Строка устроена чуть сложнее, чем массив.

58
00:04:22,234 --> 00:04:28,162
Но типичные реализации строк в java

59
00:04:28,162 --> 00:04:33,976
содержат ссылку на массив символов. Кроме того, в них содержатся

60
00:04:33,976 --> 00:04:39,110
целые значения для хранения текущего смещения,
 счетчика, хеша строки и отступа.

61
00:04:39,110 --> 00:04:41,260
Складывая все вместе,

62
00:04:41,260 --> 00:04:46,710
получаем затраты памяти
около 2N + 64 байт.

63
00:04:48,700 --> 00:04:53,133
Это основы, необходимые нам для анализа

64
00:04:53,133 --> 00:04:57,574
использования памяти
типичной java программой.

65
00:04:57,574 --> 00:05:02,413
Итак, для примитивов:
4 байта для int,

66
00:05:02,413 --> 00:05:04,425
8 для double и так далее.

67
00:05:04,425 --> 00:05:07,984
Ссылка будет занимать 8 байт,
т.к. столько занимает указатель.

68
00:05:07,984 --> 00:05:15,100
Массив - 24 байта плюс память для каждого элемента.
 Для объекта - 16 байт

69
00:05:15,100 --> 00:05:20,115
плюс память для инцидентной переменной,
плюс, если есть вложенный класс,

70
00:05:20,115 --> 00:05:24,340
то еще дополнительные 8 байт,
 как в примере с узлами связанного списка.

71
00:05:24,340 --> 00:05:25,460
Ещё отступ.

72
00:05:27,290 --> 00:05:33,310
Придется определить, кто отвечает

73
00:05:33,310 --> 00:05:36,640
за ссылочные объекты в некоторых ситуациях,

74
00:05:36,640 --> 00:05:40,799
и мы обратим на это внимание,
когда доберемся до таких ситуаций.

75
00:05:40,799 --> 00:05:45,175
Для примера рассмотрим анализ
использования памяти

76
00:05:45,175 --> 00:05:49,813
функцией WeightedQuickUnionUF,
с которой мы познакомились

77
00:05:49,813 --> 00:05:53,943
несколько лекций назад.

78
00:05:53,943 --> 00:05:58,856
Здесь всего пара элементов,
работающих с памятью,

79
00:05:58,856 --> 00:06:06,420
которые легко анализируется
с помощью данных нами основ.

80
00:06:06,420 --> 00:06:09,571
Это объект, поэтому учитываем
16 байт на заголовок.

81
00:06:09,571 --> 00:06:12,240
Здесь два целочисленных массива,

82
00:06:12,240 --> 00:06:17,106
у каждого из них есть заголовок

83
00:06:17,106 --> 00:06:21,527
на 24 + 4*N,
где N - число элементов массива.

84
00:06:21,527 --> 00:06:24,547
Каждый из N элементов
занимает четыре байта,

85
00:06:24,547 --> 00:06:29,086
далее у нас 4 байта для переменной count
и 4 байта на отступ.

86
00:06:29,086 --> 00:06:30,768
Если сложить всё вместе,

87
00:06:30,768 --> 00:06:35,820
получаем 8*N + 88, то есть ~8*N.

88
00:06:35,820 --> 00:06:41,976
То есть при большом N, нас интересует только

89
00:06:41,976 --> 00:06:48,469
2*N целых чисел,
если говорить об анализе памяти.

90
00:06:49,820 --> 00:06:53,750
Два массива целых чисел размера N,
каждое из которых занимает 4 байта,

91
00:06:53,750 --> 00:06:55,840
с общей суммой 8N байт.

92
00:06:57,310 --> 00:07:02,880
Резюмируем: мы действительно
можем вычислять

93
00:07:02,880 --> 00:07:05,750
быстродействие программ
на современных компьютерах.

94
00:07:06,780 --> 00:07:11,836
Можно делать это эмпирически,
запуская программу

95
00:07:11,836 --> 00:07:17,278
и проводя эксперименты, формулировать гипотезы
и делать предположения.

96
00:07:17,278 --> 00:07:23,331
А можно производить математический анализ,
определяя самые

97
00:07:23,331 --> 00:07:29,790
затратные операции и то,
как часто они выполняются.

98
00:07:29,790 --> 00:07:33,310
А используя тильда нотацию
для упрощения анализа,

99
00:07:33,310 --> 00:07:37,020
мы можем объяснить поведение,
 а не просто предсказывать его.

100
00:07:37,020 --> 00:07:40,935
Это хороший пример использования
научного метода

101
00:07:40,935 --> 00:07:44,795
для понимания изучаемых нами алгоритмов.

102
00:07:44,795 --> 00:07:48,555
Наши математические модели
обычно не зависят

103
00:07:48,555 --> 00:07:53,000
от конкретной системы
и даже применимы к ещё несозданным компьютерам.

104
00:07:53,000 --> 00:07:58,082
Но мы всегда проверяем модели,
выполняя эксперименты,

105
00:07:58,082 --> 00:08:02,856
чтобы быть уверенными в предположениях

106
00:08:02,856 --> 00:08:04,477
и результатах анализа алгоритмов.