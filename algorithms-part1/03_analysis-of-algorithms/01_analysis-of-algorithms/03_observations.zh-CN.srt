1
00:00:09,035 --> 00:00:15,063
好，第一步就是要能观察程序的运行时间

2
00:00:15,063 --> 00:00:22,004
我们将看到，相对很多科学领域，算法分析做观察要更容易

3
00:00:22,026 --> 00:00:27,096
下面的实例中我们将使用

4
00:00:27,096 --> 00:00:34,016
所谓的3-SUM问题。这个问题很容易描述。如果有N个不同的整数

5
00:00:34,016 --> 00:00:40,254
多少组三整数组合的和为0？如8ints.txt这个文件中

6
00:00:40,254 --> 00:00:48,096
有8个整数。其中4组三整数组合的和为0。30

7
00:00:48,096 --> 00:00:56,832
-40和10，30、-20、-10等等。所以我们的目标是编写一个程序，它能

8
00:00:56,832 --> 00:01:03,554
对任意输入，任意N个整数的集合，计算这个值。实际上，这是

9
00:01:03,554 --> 00:01:09,796
与计算几何中很多问题深度相关的极其重要的计算问题

10
00:01:09,796 --> 00:01:16,446
计算几何是计算机科学的一个分支，它

11
00:01:16,446 --> 00:01:24,536
包含与图形、电影以及各种
几何模型相关的算法和科学基础

12
00:01:24,536 --> 00:01:32,040
这实际上是一个很重要的现实问题

13
00:01:32,040 --> 00:01:40,459
这个问题的代码很好写，不需要费很大劲就能在一页之内写下这个程序

14
00:01:40,759 --> 00:01:49,583
它有一个静态方法count，将一个

15
00:01:49,583 --> 00:01:56,317
整数数组作为参数。这是整数的个数

16
00:01:56,317 --> 00:02:02,660
是数组的长度。变量count开始等于0

17
00:02:02,660 --> 00:02:09,363
然后是一个三重for循环，检查每个三整数组合 i、j、k，i 从 1 到 N

18
00:02:09,363 --> 00:02:15,181
j 从 i+1 到 N，k 从 j+1 到 N，这样每个三整数组合只出现一次

19
00:02:15,181 --> 00:02:19,818
然后如果 a[i] + a[j] + a[k] = 0，count增加1。好，三重

20
00:02:19,818 --> 00:02:25,093
for循环之后，返回count值。下面是main方法，这个简单的类中

21
00:02:25,093 --> 00:02:30,769
只是读入所有的整数，然后输出count值。所以

22
00:02:30,769 --> 00:02:35,696
这就是一个正确的求解3-SUM问题的暴力算法

23
00:02:35,696 --> 00:02:41,615
现在我们感兴趣的是用关于N的函数表示算法需要的时间

24
00:02:41,615 --> 00:02:47,808
那么，有一种给程序计时的方法就是看表。如果你有

25
00:02:47,808 --> 00:02:54,925
秒表、也可以看钟表、手机，或者随便什么你能用的东西

26
00:02:54,925 --> 00:03:02,164
你喜欢的话就可以用它们计时。另一种方法，Java在它的

27
00:03:02,164 --> 00:03:09,024
标准库中就有一个秒表类，可以计算用掉的时间

28
00:03:09,024 --> 00:03:15,968
无论运行什么程序，如果它可以很容易改变输入的

29
00:03:15,968 --> 00:03:23,990
大小，很自然应该用越来越大的输入来运行它。对于8个

30
00:03:23,990 --> 00:03:32,381
整数这个程序不需要花太多时间，1000个整数需要半秒钟

31
00:03:32,381 --> 00:03:42,303
2000个需要花更多时间，3.7秒。再运行一次，还是3.7秒

32
00:03:42,303 --> 00:03:50,231
4000呢，所以每次我们将输入的大小翻倍，程序一定会

33
00:03:50,231 --> 00:03:58,930
运行更久。而实际上，如果程序员

34
00:03:58,930 --> 00:04:05,490
养成这样测试程序的习惯，就可以

35
00:04:05,490 --> 00:04:13,038
相当方便和快速地评估程序什么时候结束

36
00:04:13,038 --> 00:04:20,010
当你在等它运行的时候往往就知道了

37
00:04:20,010 --> 00:04:27,000
程序对于4000的输入需要30秒，那么我们就能

38
00:04:27,000 --> 00:04:33,047
在程序运行结束之前算出来8000的输入需要多久，你马上就知道怎么做了

39
00:04:33,047 --> 00:04:40,037
现在我不打算等程序结束了，你可以好好考虑一下

40
00:04:40,037 --> 00:04:45,203
好，这就是经验分析法。用不同大小的输入运行程序

41
00:04:45,203 --> 00:04:51,869
并测量运行时间。现在假如这是某个科学问题

42
00:04:51,869 --> 00:04:57,320
我们在对自然界中的某个事物计数。蚁丘中蚂蚁的个数

43
00:04:57,320 --> 00:05:03,255
之类的，我们只有几个数据点

44
00:05:03,255 --> 00:05:08,837
为了理解怎么回事，我们画一个图象，我们感兴趣的运行时间作为

45
00:05:08,837 --> 00:05:15,240
Y轴，问题大小作为X轴。得到这样一条曲线

46
00:05:15,240 --> 00:05:21,767
实际上很多这种类型的问题科学家们是这么做的

47
00:05:21,767 --> 00:05:29,001
是用双对数坐标。如果你用双对数坐标

48
00:05:29,001 --> 00:05:36,320
通常你会得到一条直线。这条直线的斜率就是

49
00:05:36,320 --> 00:05:41,582
关键。这个例子中，直线的斜率是3

50
00:05:41,582 --> 00:05:49,272
你可以做一个回归，拟合出一条经过数据点的直线

51
00:05:49,272 --> 00:05:55,078
做一些数学计算不难证明

52
00:05:55,078 --> 00:06:01,409
如果你得到一条直线，斜率为B，那么函数正比于N^B

53
00:06:01,409 --> 00:06:06,799
这叫幂定律。对于很多科学问题

54
00:06:06,799 --> 00:06:13,633
包括大多数算法都是成立的。这里是一些数学计算

55
00:06:13,633 --> 00:06:22,794
因为我们用了以二为底的双对数坐标作图，直线就是

56
00:06:22,794 --> 00:06:29,850
lg(T(N)) = b lg N + c。我们有了b和c的经验值，如果

57
00:06:29,850 --> 00:06:37,950
如果将等式两边同时取2的幂，就得到T(N) = 

58
00:06:37,950 --> 00:06:44,422
常数乘以N^B。所以从观察中我们就得到了程序运行时间

59
00:06:44,422 --> 00:06:50,512
相当不错的模型。做一些数学计算，我们就能知道

60
00:06:50,512 --> 00:06:59,028
运行时间看起来大约是10^-10 × N^3秒

61
00:06:59,028 --> 00:07:05,053
我们可以用这个假设继续做预测。只要代入

62
00:07:05,053 --> 00:07:11,067
不同的N值，计算出16000的输入需要400秒

63
00:07:11,067 --> 00:07:16,059
400秒是挺长的时间，但是现在我们可以运行这个实验

64
00:07:16,059 --> 00:07:22,611
我们就很确定需要的运行时间很接近那个408秒了

65
00:07:22,611 --> 00:07:27,109
现在我们能对32000或者其他我们感兴趣的做预测了

66
00:07:27,109 --> 00:07:32,219
这个模型帮助我们在不需要花时间运行实验的前提下

67
00:07:32,219 --> 00:07:38,927
做一些预测。实际上，这个情形中存在幂定律

68
00:07:38,927 --> 00:07:45,689
再说一次，绝大多数计算机算法的运行时间满足

69
00:07:45,689 --> 00:07:51,812
幂定律，我们需要做的就是想之前一样每次将输入的大小翻倍

70
00:07:51,812 --> 00:07:58,009
然后计算出N和2N运行时间的比率

71
00:07:58,009 --> 00:08:04,713
如果你这么做了，这个比率会收敛到一个常数。实际上比率的对数

72
00:08:04,713 --> 00:08:10,258
会收敛到N的指数

73
00:08:10,258 --> 00:08:16,342
做这个表格你只需要做一点点计算，但这是一种非常简单而且

74
00:08:16,342 --> 00:08:21,460
自然的预测运行时间的方式。这里是我之前说过的

75
00:08:21,460 --> 00:08:26,756
通过这种方式我们可以很快估计出幂定律关系中的B

76
00:08:26,767 --> 00:08:33,342
怎么估计a呢？我们可以运行程序然后求出a。所以一旦我们求出

77
00:08:33,342 --> 00:08:41,138
指数是3，在某个大N上运行程序，我们得出的模型和

78
00:08:41,138 --> 00:08:48,197
我们通过作图得到的模型是很接近的。几乎是完全相同的

79
00:08:48,197 --> 00:08:56,197
假设，我们只需要每次将N翻倍运行程序就能得到它

80
00:08:56,522 --> 00:09:04,905
为了理解程序运行的时间计算机中有很多的因素

81
00:09:04,905 --> 00:09:10,182
关键因素和计算机的型号是无关的

82
00:09:10,182 --> 00:09:15,004
就是你使用的算法以及数据

83
00:09:15,004 --> 00:09:20,269
它们实际上决定了幂定律中的指数。有很多

84
00:09:20,269 --> 00:09:25,632
系统相关的因素。你的硬件配置如何？你的计算机是快

85
00:09:25,632 --> 00:09:30,056
还是慢？软件环境如何？计算机系统中发生了什么？

86
00:09:30,056 --> 00:09:35,095
所有这些因素决定了幂定律中的a

87
00:09:35,095 --> 00:09:40,894
现代计算机系统中硬件和软件是非常复杂的

88
00:09:40,894 --> 00:09:46,288
有时很难获得非常精确的测量。但是另一方面

89
00:09:46,288 --> 00:09:52,050
我们不像其他科学中需要牺牲动物或者像另一颗行星发射探测器

90
00:09:52,050 --> 00:09:57,304
我们只需要运行大量的实验，然后就能

91
00:09:57,304 --> 00:10:00,032
处理这些因素