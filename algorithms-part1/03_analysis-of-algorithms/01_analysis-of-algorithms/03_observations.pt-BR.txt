Ok, então o primeiro passo é ser capaz de fazer algumas observações sobre o funcionamento tempo dos programas. E para a análise de algoritmos que é mais fácil do que em um monte de disciplinas científicas, como veremos. Para um exemplo de execução, vamos utilizar o os chamados 3 soma-problema. E é um problema fácil de estado. Se você tem N distinta inteiros, quantos soma triplo exatamente zero? Por exemplo, neste 8ints.text arquivo. Texto que tem oito inteiros nele. Há quatro triplos que soma a zero. 30 - 40, 10. 30 - 20-10 e assim por diante e assim nosso objetivo é escrever um programa que pode calcular esta quantidade para qualquer arquivo de entrada, qualquer conjunto de n inteiros. Isto é realmente um, um cálculo extremamente importante que está profundamente relacionado a muitos problemas de geometria computacional, que é um ramo da ciência da computação que cobre os algoritmos e ciência subjacente relacionadas a gráficos e filmes, e modelos geométricos de todo o tipo. Portanto, esta é uma verdade, um importante problema prático. Mas é um simples para escrever código para em uma visão que você poderia escrever este programa sem muito esforço. É um, tem uma contagem de método estático que está a ir em frente e tomar um array de inteiros como argumento. E, é isso, que é uma série de números inteiros, que é o comprimento da matriz. Vamos começar com uma contagem variável igual a zero, e depois um triplo loop, que verifica cada triplo I jk, vamos eu e de um j de I 1 a n, e k de j 1 a n, de modo que ficamos cada triplo apenas uma vez. E então se eu + j, ai + aj + ak = zero, incrementar a contagem. Tudo bem. E depois que malha quatro triplos, voltamos a contagem. E, em seguida, o método principal, neste classe simples, apenas lê, todos os números inteiros e imprime a contagem. Assim que é um algoritmo de força bruta que é um método muito bem para resolver a soma três problema, agora o que interessa é quanto tempo isso ter como função do "n? Bem, uma para o nosso tempo é programa é apenas olhar para o relógio. Se você tem um cronômetro, ou olhar para o relógio ou telefone, ou o que você pode precisar você pode ir em frente e tempo que se quiser ou o que temos, Java tem esta parte é biblioteca padrão, uma classe cronômetro que irá adiante e calcular um lapso de tempo. Assim, em ordem, quando você executar um programa, se ele está configurado para facilmente tirar a entrada de tamanhos diferentes, uma coisa natural a fazer, é só executá-lo para tamanhos maiores. Assim, para oito ints Este programa não leva muito tempo, para 1000 ints leva meio segundo. Para 2000. Leva mais tempo. Isso é 3,7 segundo executá-lo novamente, ainda leva 3,7 segundo para 4000, de modo que cada vez estamos dobrando o tamanho da entrada e é definitivamente tendo mais tempo de cada vez. E, na verdade, como vamos ver se os programadores que começam na hábito de teste ou em qualquer altura no seu programa, desta forma pode obter, de modo que lhe pode realmente muito facilmente e rapidamente avaliar quando vai terminar. Em fato. Enquanto você espera que ela termine muitas vezes você pode descobrir isso. Assim que um levou 30 segundos para 4K e definitivamente poderíamos descobrir quanto tempo que vai levar para 8K antes de terminar, e você vai ver como em apenas um segundo. Eu não vou esperar agora. Você pode pensar sobre o que você pensa. Ok assim [tosse] que é a análise empírica, análise. Executá-lo para vários tamanhos de entrada e medir o seu tempo de execução. Agora, se isso fosse algum problema científico onde estavam contando algo que acontece no mundo natural. O número de formigas em um formigueiro ou o que então teríamos apenas alguns pontos de dados e nós vamos tentar entender o que está se estava a passar, fazendo uma parcela de tempo ou correr com bastante interessados ​​em no eixo Y e problema de tamanho, com o eixo dos x. Bata uma curva como isso e, na verdade, o que é a ciência costuma fazer por causa de alguns problemas de muitos caem fora desta classe é fazer o enredo como uma trama lg lg. Se você fizer isso como um, lg lg trama muitas vezes você vai obter uma linha reta. E a inclinação da linha reta é a chave para o que está acontecendo. Neste caso, a inclinação da linha recta é três e assim você pode executar o que é chamado de uma regressão para atender a uma final, a linha reta através do pontos de dados. E então, não é difícil mostrar que fazer a matemática para mostrar que, se você obter uma linha reta ea inclinação é B, então a sua função é proporcional a A, N ^ B. Isso chama-se a lei de potência. E isso é verdade para muitos, muitos científico problemas, incluindo a maioria dos algoritmos. Então aqui vai um pouco da matemática para isso. Assim, a linha reta significa que desde que fez um lg, lg lote com potências de dois, que lg (T (N) = B lg N + C. E nós temos nossos valores empíricos de B e C, e em seguida, se você levantar ambos os lados da equação para dois para que o poder depois que você começa T (N) = a constante vezes N ^ B. Então, de imediato apenas a partir da observação que temos uma boa bonita modelo para o tempo de execução para o nosso programa, podemos descobrir e fazer as contas e figura que parece que o tempo de execução é de cerca de 10 ^ -10 N ^ 3 segundos. Podemos usar essa hipótese de ir em frente e fazer previsões. Basta ligar para diferentes valores de N e ele diz que vai levar-nos 400 segundo para 16.000. 400 segundos é muito tempo, mas agora podemos ir em frente e investir e executar o que experiência e com certeza estamos muito perto de que 408 segundo quando executá-lo. E agora podemos fazer uma previsão para 32000 ou para ou para qualquer outra coisa que pode estar interessado em O modelo nos ajuda a fazer previsões sem investir despesa para executar os experimentos. De facto, nesta situação, se existe uma lei de potência, e novamente em uma grande maioria de algoritmo de computador que executa vezes vai para ser uma lei de potência. O que se pode fazer é simplesmente o dobro do tamanho da entrada de cada vez que o jeito que éramos e tirar a razão dos tempos de execução para N e 2N. E se você fizer que, essa relação irá convergir para uma constante. E, de facto, o log da razão vai convergir para que constante, o que é o expoente de N e a execução tempo. E você só precisa de um pouco de matemática para verificar se um, mas isso é muito fácil e caminho natural para ir em frente e prever tempos de execução. Então é isso que eu disse antes é, por isso temos esta maneira rápida de estimar B no ip relationsh poder de direito. Como podemos estimar A? Bem, podemos apenas executá-lo e resolver para A. Assim, uma vez que decidimos isso, que expoente é três vamos executá-lo para algum N grande e ficamos muito perto modelo para o que teve de planejar as coisas. Então, é quase idêntico hipótese e nós acabou-lo executando o programa de dupla N de cada vez. Ok então há uma série de efeitos na tentativa de entender o tempo de execução de um programa em diante, em sua máquina. [Tosse] Então. Principais efeitos são independentes do que computador é. E esse é o algoritmo que você está usando e qual é o de dados. E isso é vai realmente determinar o expoente da lei de potência. E então há um monte de, efeitos dependente do sistema. Que tipo de hardware que você tem? Você tem um rápido computador ou uma lenta? Que tipo de software? O que está acontecendo em sua computador? Todas essas coisas realmente determinar o uma constante na lei de potência. So. Nos sistemas modernos, é tanta coisa acontecendo no hardware e software, é às vezes difícil de obter medições precisas realmente. Mas por outro lado nós não tem que sacrificar animais, ou voar para outro planeta da maneira que fazem em outros ciências, podemos apenas executar um grande número de experimentos e geralmente cuidar de compreensão estes tipos de efeitos.