Bem-vindo novamente. Hoje nós vamos fazer um pouco de matemática e um pouco de ciência. Não muito, mas nós necessidade de ter uma base científica para a compreensão do desempenho da nossa algoritmos corretamente implantá-los em prática. Então, hoje nós vamos falar, sobre como, observar as características de desempenho de algoritmos. Nós estamos indo olhar para como fazer modelos matemáticos e como classificar os algoritmos de acordo para o fim do crescimento do seu tempo de funcionamento. Vamos falar um pouco sobre a teoria da algoritmos e também como analisar o uso da memória. Então, para colocar tudo isso em perspectiva, vamos pensar sobre essas questões do ponto de vista de diferentes tipos de caracteres. Assim, o primeiro é o programador que precisa resolver um problema e fazê-lo funcionar e obtê-lo implantado. O segundo é o cliente que quer usar programa o que quer que fizeram para obter o trabalho feito. Um terceiro é o teórico, que é alguém que quer realmente entender o que está acontecendo. E, e o última é uma espécie de equipe, esta base de bloqueio e combate às vezes necessário para chegar, você sabe, todas essas coisas. Então, há um pouco de cada um de estes na palestra de hoje. E, na verdade, quando você é um estudante, você tem que pensar que você pode estar jogando uma ou todas essas funções algum dia. Então, é muito importante entender os diferentes pontos de vista. Então, a chave que nós vamos foco é tempo de execução. E, na verdade, a idéia de entender o tempo de execução de computação passa um caminho de volta até a Babbage e provavelmente antes. E aqui está um citação de Babbage, "Assim como existe um mecanismo analítico, ele vai necessariamente orientar o futuro da ciência. Sempre que qualquer resultado é procurado por sua ajuda, a questão vai surgir por que curso de cálculo pode ser estes resultados chegou pela máquina no menor espaço de tempo ". Se você olhar para a máquina de Babbage chamado de motor analítico, ele tem uma manivela sobre ele. E, literalmente, a preocupação Babbage que tinha em saber quanto tempo levaria uma computação é, como qualquer m vezes temos que girar a manivela. É, não é muito diferente, no mundo de hoje. O manivela pode ser algo eletrônico que está acontecendo de um bilhão de vezes por segundo. Mas ainda, que estamos procurando, quantas vezes faz alguma operação tem que ser discreto realizados a fim de obter um cálculo feito. Portanto, há muitas razões para analisar algoritmos. No contexto deste curso, estamos interessados ​​principalmente em previsão de desempenho. E nós também queremos comparar o desempenho de diferentes algoritmos para a mesma tarefa, e para ser capaz de fornecer algumas garantias sobre a forma bem eles executam. Junto com isso, é a compreensão de alguma base teórica para como os algoritmos executar. Mas, principalmente, a razão prática que queremos ser analisar algoritmos e compreendê-los é evitar bugs de desempenho. Queremos ter alguma confiança de que nossos algoritmos vai concluir o trabalho em a quantidade de tempo que, que acho que vai. E é muito, muito frequente ver, em infra-estrutura computacional de hoje, uma situação em que o cliente fica ruim desempenho, porque o programador não entender o desempenho características do algoritmo. E palestra de hoje é sobre a tentativa de evitar isso. Agora, vamos focar no desempenho e comparar algoritmos em este curso. Há posteriores cursos de ciência da computação típico currículos que ter mais informações sobre a base teórica de algoritmos e eu vou falar um pouco sobre isso mais tarde. Mas o nosso foco está em ser capaz de prever desempenho e algoritmos de comparação. Agora, há uma longa lista de casos de sucesso em concepção algoritmo com melhor desempenho em, para permitir que a solução de de problemas que de outra forma não ser resolvidos. E eu vou apenas dar um par de exemplos. Um dos primeiros e mais famosos é o chamado algoritmo FFT. Essa é uma algoritmo para quebrar a forma de onda de n amostras de um sinal periódico em componentes. E isso é a base para dvds e jpegs e, e muitos outros appl ications. Não há uma maneira fácil de fazer isso que leva um tempo proporcional a N ^ 2. Mas algoritmo FFT, leva apenas log N N passos. E a diferença entre N log N e N ^ 2 é, é a diferença entre ser capaz de resolver um problema grande e não ser capaz de resolvê-lo. Uma boa parte da tecnologia digital, mídia digital tecnologia que temos hoje é ativado por que o algoritmo rápido. Outro exemplo realmente foi desenvolvido por Andrew Appel, que é agora a cadeira de ciência da computação aqui em Princeton. E foi desenvolvido quando ele era um estudante para sua tese sênior. É um algoritmo rápido para o problema de simulação corpo N. O fácil algoritmo leva tempo proporcional a N ^ 2, mas algoritmo Appel foi um log N N algoritmo que, novamente, fez com que os cientistas podem fazer simulação de corpo de N valores enormes de N. e que permite uma nova pesquisa. S0, o desafio é que nós rosto normalmente é, será que meu programa seja capaz de resolver uma entrada grande prática? E, e , na verdade, o programador de trabalho é realmente confrontado com isso o tempo todo. Por que, porque é o meu programa em execução tão lentamente? Por que sem memória? E isso é programadores enfrentados por um tempo muito longo e no discernimento para lidar com isso. Deuter Kanoof, na década de 1970, era de que, realmente pode usar o método científico para entender o desempenho de algoritmos em operação. Talvez nós não estamos desbloqueando novos segredos do universo, mas, podemos usar o método científico, e tratar a computador, como algo a ser estudado em que forma e chegar a um entendimento de como o nosso programa está indo para executar. E vamos dar uma olhada em que em mais detalhe. Portanto, este apenas um resumo rápido do que queremos dizer com o método científico, que tem, sido bem sucedida por um par de séculos. Então, o que nós vamos fazer é, observar a partir de alguma característica do mundo natural. Neste caso, ele vai ser o tempo de funcionamento do nosso programa em um computador. Então nós vamos desenvolver hipótese algum modelo que é consistente com as observações, e vamos esperar que, essa hipótese é bom o suficiente para que ele vai nos permitir prever algo. Normalmente prever um tempo de execução para o tamanho do problema maior, ou em um computador diferente. E então nós vamos verificar as previsões, fazendo mais observações e validar até que está confortável que a nossa hipótese de modelo e observações todos concordam. Isso é uma maneira de obter o conforto que nós entendemos o desempenho do nosso programas. Agora, o dentro do método científico, há alguns princípios básicos e a, a primeira é que se você está indo para executar experiências, você deve esperar que outra pessoa deve ser capaz de executar experiências e obter o mesmo resultado. E também as hipóteses tem de ter uma propriedade específica que a experiência pode mostrar a hipótese de estar errado. Então, tem que ser cuidadosamente trabalhada, e nós vamos ser certo para tentar fazer isso. Assim, e mais uma vez o futuro do mundo natural de que estamos Estudar é algum computador particular que existe no mundo natural. Ele muda algoritmo a partir de uma abstração para um, alguns, algum tipo de coisa física real acontecendo como os elétrons de corrida ao redor dentro do computador.