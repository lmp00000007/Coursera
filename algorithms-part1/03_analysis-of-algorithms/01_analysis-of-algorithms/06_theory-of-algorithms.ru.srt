1
00:00:01,087 --> 00:00:07,024
Классификации порядков роста
настолько важны, что привели

2
00:00:07,024 --> 00:00:13,038
к большому количеству исследований
в последние годы. Поговорим об этом коротко.

3
00:00:13,038 --> 00:00:19,692
Жизнь чуть сложнее, чем указывалось
в последнем примере.

4
00:00:19,692 --> 00:00:25,747
Проблема в том, что данные могут
сильно влиять на производительность.

5
00:00:25,747 --> 00:00:31,076
Приходится думать
о разных способах анализа алгоритма

6
00:00:31,076 --> 00:00:37,001
в зависимости от входных данных.
Время работы определяется как среднее

7
00:00:37,001 --> 00:00:42,014
между лучшим и худшим вариантом.
Оно всегда выше

8
00:00:42,014 --> 00:00:48,008
или равно нижней границе.

9
00:00:48,008 --> 00:00:53,368
А худший вариант соответствует

10
00:00:53,368 --> 00:00:58,562
наиболее сложным входным данным.
Можно гарантировать,

11
00:00:58,562 --> 00:01:04,327
что время работы
не превысит верхней границы.

12
00:01:04,327 --> 00:01:11,078
Во многих ситуациях
входные данные случайные,

13
00:01:11,078 --> 00:01:17,577
и нужно смоделировать их случайность,
если сделать это,

14
00:01:17,577 --> 00:01:24,680
то появляется способ предсказать быстродействие
при широком изменении

15
00:01:24,680 --> 00:01:33,369
входных данных. Быстродействие алгоритма 3-SUM
почти не меняется.

16
00:01:33,617 --> 00:01:39,441
Единственное, что меняется в этом алгоритме,

17
00:01:39,441 --> 00:01:46,514
это количество обновления счетчика.
Но это не влияет

18
00:01:46,514 --> 00:01:53,318
на наш анализ. 
Для двоичного поиска: искомое может найтись сразу,

19
00:01:53,318 --> 00:02:00,553
то есть время постоянное.
Можно показать, что в среднем и худшем варианте

20
00:02:00,553 --> 00:02:08,205
время равно log2(N). Есть и другие примеры

21
00:02:08,205 --> 00:02:17,256
с большей вариативностью.
То есть анализ подстраивается

22
00:02:17,256 --> 00:02:22,398
под входные данные.
Но что насчет той задачи,

23
00:02:22,398 --> 00:02:28,543
которую пытается решить клиент?
Придется разобраться и в ней,

24
00:02:28,543 --> 00:02:33,933
чтобы понимать быстродействие алгоритма.
Есть два надежных подхода.

25
00:02:33,933 --> 00:02:40,346
Один в том, чтобы писать алгоритм
под худший сценарий.

26
00:02:40,346 --> 00:02:45,403
Тогда он всегда будет работать быстро.

27
00:02:45,403 --> 00:02:50,794
Если это не удается, то ориентироваться
на случайность данных,

28
00:02:50,794 --> 00:02:55,769
полагаясь на вероятностную гарантию.
Мы увидим примеры обоих подходов.

29
00:02:55,769 --> 00:03:00,546
Рассуждения подобного толка
приводят к обсуждению

30
00:03:00,546 --> 00:03:06,058
того, что я называю теорией алгоритмов.

31
00:03:06,058 --> 00:03:12,022
Наша цель: есть задача, например,

32
00:03:12,022 --> 00:03:17,500
3-SUM, и мы хотим понять,
 насколько она сложная. Хотим найти

33
00:03:17,500 --> 00:03:24,302
лучший алгоритм для её решения.
Программисты используют следующий подход:

34
00:03:24,302 --> 00:03:30,091
они стремятся исключить из анализа
как можно больше факторов,

35
00:03:30,091 --> 00:03:37,015
свести анализ времени
к одной постоянной величине.

36
00:03:37,015 --> 00:03:42,831
Применяется порядок роста.
Нас не заботит входная модель.

37
00:03:42,831 --> 00:03:48,070
Сосредотачиваемся на разборе
худшей ситуации.

38
00:03:48,090 --> 00:03:54,372
Быстродействие можно свести
к порядку роста.

39
00:03:54,372 --> 00:03:59,357
Это можно сделать строгим образом,
который дает оценку

40
00:03:59,357 --> 00:04:04,692
сложности решения задач.
 Нашей целью является поиск оптимального алгоритма,

41
00:04:04,692 --> 00:04:11,326
для которого мы могли бы гарантировать
производительность с точностью

42
00:04:11,326 --> 00:04:17,735
до постоянного множителя,
ведь мы рассмотрели худший случай.

43
00:04:17,735 --> 00:04:24,022
И никакой другой алгоритм
не может обеспечить лучшую производительность.

44
00:04:24,022 --> 00:04:31,549
Для оценки скорости роста
широко используются обозначения:

45
00:04:31,549 --> 00:04:39,745
Тета большое, О большое и Омега большое.
 Их определения даны здесь.

46
00:04:40,033 --> 00:04:47,396
Тета большое — это просто способ
описать порядок роста.

47
00:04:47,396 --> 00:04:53,733
Тета(N^2) это сокращения для всего,
что имеет степень N^2.

48
00:04:53,733 --> 00:05:00,393
Она ограничена степенью N^2 и используется
при классификации алгоритмов.

49
00:05:00,393 --> 00:05:05,730
О большое является оценкой
верхней границы производительности.

50
00:05:05,730 --> 00:05:11,360
O(N^2) означает время меньшее,
чем N^2 с ростом N.

51
00:05:11,360 --> 00:05:17,569
Омега большое обозначает нижнюю границу, то есть больше значения

52
00:05:17,569 --> 00:05:23,694
N^2 с ростом N.
Эти три обозначения используются

53
00:05:23,918 --> 00:05:30,113
для классификации алгоритмов,
они нам ещё пригодятся.

54
00:05:30,113 --> 00:05:36,725
Наши примеры 1-sum, 2-sum
 и 3-sum просто сформулировать

55
00:05:36,725 --> 00:05:42,829
для установления сложности задачи
и построения оптимального алгоритма.

56
00:05:42,829 --> 00:05:48,999
1-sum состоит в нахождении числа в массиве.
 Итак, верхняя граница сложности

57
00:05:48,999 --> 00:05:54,299
задачи — специфический алгоритм.
Например, алгоритм перебора,

58
00:05:54,299 --> 00:06:00,049
который проверяет каждый элемент массива.

59
00:06:00,049 --> 00:06:06,490
Быстродействие равняется O(N).
Времени требуется меньше,

60
00:06:06,490 --> 00:06:12,307
чем N. Время работы
оптимального алгоритма должны быть

61
00:06:12,307 --> 00:06:17,616
не выше O(N). Таким образом, конкретный алгоритм
устанавливает верхнюю границу

62
00:06:17,616 --> 00:06:23,431
времени работы оптимального алгоритма.
Но в данном случае легко установить

63
00:06:23,431 --> 00:06:29,052
нижнюю границу, которую не преодолеть
ни одному алгоритму.

64
00:06:29,052 --> 00:06:34,536
Для 1-sum вы должны проверить все элементы массива.
Любой пропущенный

65
00:06:34,536 --> 00:06:40,016
может оказаться искомым,
значит оптимальный алгоритм должен иметь время работы

66
00:06:40,016 --> 00:06:46,270
как минимум C*N, то есть Омега(N).

67
00:06:46,270 --> 00:06:52,287
В данном случае верхняя
и нижняя границы равны,

68
00:06:52,287 --> 00:06:59,133
значит метод перебора оптимален
для 1-SUM задачи.

69
00:06:59,133 --> 00:07:05,459
Его время работы Тета(N).
Он включает Омега(N) и O(N). Легко получить

70
00:07:05,459 --> 00:07:11,576
оптимальный алгоритм для простой задачи.
Для более сложных задач

71
00:07:11,576 --> 00:07:17,027
становится сложнее получить оценки
нижних и верхних границ,

72
00:07:17,027 --> 00:07:22,617
особенно совпадающих.
Разберем задачу 3-SUM.

73
00:07:22,617 --> 00:07:30,211
Метод перебора давал результат

74
00:07:30,211 --> 00:07:37,375
О(N^3), но мы его усовершенствовали
и получили алгоритм

75
00:07:37,375 --> 00:07:43,691
со временем работы O(N^2*log(N)).
Это верхняя граница.

76
00:07:43,691 --> 00:07:49,526
Нижняя граница: необходимо проверить
каждый элемент,

77
00:07:49,526 --> 00:07:56,274
чтобы не пропустить искомое,
значит время работы

78
00:07:56,274 --> 00:08:02,304
оптимального алгоритма — Омега(N).
Но никто не знает истинных границ.

79
00:08:02,304 --> 00:08:08,280
Верхняя и нижняя граница задачи 3-SUM
остаются открытым вопросом.

80
00:08:08,280 --> 00:08:14,237
Есть ли оптимальный алгоритм для 3-sum?
Мы не знаем.

81
00:08:14,237 --> 00:08:20,592
Мы даже не знаем, есть ли алгоритм
со временем работы меньше O(N^2),

82
00:08:20,592 --> 00:08:27,130
не знаем верхнюю и нижнюю границы.
Это пример нерешённой задачи

83
00:08:27,130 --> 00:08:33,181
теории алгоритмов.
Нам не известна сложность задачи 3-SUM.

84
00:08:33,181 --> 00:08:40,448
Эта методика была успешной
в последние десятилетия.

85
00:08:40,448 --> 00:08:45,958
Разрабатываем алгоритм,
находим нижнюю границу.

86
00:08:45,958 --> 00:08:51,679
Если есть разрыв, ищем новый алгоритм,
который станет нижней границей,

87
00:08:51,679 --> 00:08:56,527
ищем способ повысить нижнюю границу.
 Обычно очень сложно

88
00:08:56,527 --> 00:09:02,164
находить нижние границы.
Тривиальные задачи с перебором элементов

89
00:09:02,164 --> 00:09:07,435
не представляют труда.
Нетривиальные задачи,

90
00:09:07,435 --> 00:09:13,251
например, Union-Find намного сложнее.
В последние десятилетия

91
00:09:13,251 --> 00:09:20,081
мы столкнулись
с вычислительными сложностями

92
00:09:20,081 --> 00:09:26,124
задач при уменьшении верхних границ.
Удалось улучшить

93
00:09:26,124 --> 00:09:31,979
время работы многих алгоритмов,
но остается ещё много

94
00:09:31,979 --> 00:09:37,944
нерешенных задач.
Это обширное поле для исследования,

95
00:09:37,944 --> 00:09:43,617
в котором занято много специалистов.
Есть несколько оговорок

96
00:09:43,617 --> 00:09:48,770
в контексте нашего курса.
Во-первых, может быть,

97
00:09:48,770 --> 00:09:54,409
фокусироваться на худшем случае — слишком пессимистично.

98
00:09:54,409 --> 00:09:59,786
У нас есть данные и задачи.
Не всегда срабатывает

99
00:09:59,786 --> 00:10:05,194
худший вариант.
На нашем курсе худшим вариантом

100
00:10:05,194 --> 00:10:10,708
будем считать удар молнии,
но закладываться на него не будем.

101
00:10:10,708 --> 00:10:16,301
Стоит сосредоточиться на анализе

102
00:10:16,301 --> 00:10:21,252
входных данных и поиске алгоритмов,
 которые эффективны для этих данных.

103
00:10:21,252 --> 00:10:26,645
Во-вторых, для оценки производительности
и сравнения алгоритмов

104
00:10:26,645 --> 00:10:33,210
потребуется более точный анализ,
чем с точностью до постоянного множителя.

105
00:10:33,210 --> 00:10:39,719
Мы поговорили о тильда нотации,
 Тета большое, О большое и Омега большое.

106
00:10:39,719 --> 00:10:46,161
В теории алгоритмов имеется огромное количество
опубликованных исследований,

107
00:10:46,161 --> 00:10:51,608
и многие делают ошибку,
интерпретируя результаты

108
00:10:51,608 --> 00:10:56,964
поиска улучшенной верхней границы
со значением О большое

109
00:10:56,964 --> 00:11:02,179
как модель быстродействия. Это ошибка.

110
00:11:02,179 --> 00:11:07,619
Мы сосредоточимся на усредненных моделях,

111
00:11:07,619 --> 00:11:12,738
попытаемся получить конкретные результаты
для некоторого круга задач

112
00:11:12,738 --> 00:11:17,766
с точностью до произвольного неопределенного коэффициента
 во времени выполнения.

113
00:11:17,766 --> 00:11:22,271
Разберемся в свойствах
компьютеров и систем,

114
00:11:22,271 --> 00:11:27,542
чтобы использовать эти результаты
 для предсказания производительности

115
00:11:27,542 --> 00:11:29,013
и сравнения алгоритмов.