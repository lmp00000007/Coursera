Tudo isso QuickFind é muito lento para grandes problemas. Então, como é que vamos fazer melhor? Nossa primeira tentativa é uma alternativa chamada, Quick-sindical. Isto é denominada abordagem preguiçosa para projeto do algoritmo onde tentamos evitar fazer trabalho até temos que fazer. Ele usa a mesma estrutura de dados ou ID matriz M com tamanho, mas agora , tem uma interpretação diferente. Vamos pensar nisso como matriz que representa um conjunto de árvores que se chama uma floresta como descrito à direita. Assim, cada entrada na matriz vai conter uma referência a seu pai na árvore. Assim, por exemplo, pai 3 é quatro, quatro pai é nove. Então, a entrada 3 é quatro e 4 de entrada é de nove na matriz. Agora, cada entrada na matriz tem associado a ele uma raiz. Essa é a raiz de sua árvore. Elementos que são por si mesmos em apenas, em seu próprio componente conectado ponto, para si, de modo que um pontos para si, mas também nove pontos a si mesmo. É a raiz da árvore, contendo dois, quatro e três. Então, a partir desta estrutura de dados que pode associar com cada item uma raiz, que é representante de, digamos, a que está ligado componente. Então esse é o raiz de três são nove, indo-se que a raiz. Agora, uma vez que podemos calcular essas raízes, então podemos implementar a operação de encontrar apenas verificando se os dois itens que deveríamos verificar com está conjuntivo onde eles têm a mesma raiz. Isso é equivalente a dizer, eles estão no mesmo componente conjuntivo? Então, isso é algum trabalho, vai encontrar as raízes de cada item, mas a operação de união é muito fácil. Para mesclar componentes que contenham dois itens diferentes. Dois itens que estão em componentes diferentes. Tudo o que fazemos é definir a identificação da rota P para a identificação da rota de Q. Vamos fazer ponto P da árvore de P. Portanto, neste caso, seria alterar a entrada de nove para ser seis fundir três e cinco. Os componentes que contêm de três a cinco. E com apenas mudando um valor na matriz temos os dois grandes componentes emergiu juntos. Esse é o algoritmo Quick-união. Como uma operação de união só envolve mudar uma entrada na matriz. Encontre operação requer um pouco mais trabalho. Então, vamos olhar para a Implementação, uma demonstração de que um em primeira operação. Assim novamente nós, começamos da mesma forma, mas agora a entrada da matriz idéia realmente significa que cada uma dessas coisas é uma pequena árvore onde o nó de cada um apontando todos para si. É a raiz de sua própria árvore agora se tem que colocar quatro e três em componente o mesmo, então tudo o que fazemos é tirar a raiz do componente que contém o primeiro artigo e fazer com que uma criança da raiz do componente, componente contendo o segundo item. Neste caso, basta fazer quatro como pai três. Então agora três e oito. Então, novamente, nós tomamos o primeiro item e torná-lo um filho da raiz da árvore contendo o segundo item. Então, agora três, quatro e oito estão na mesma componente. Seis e cinco seis vai abaixo de cinco anos. Nove e quatro, Então agora é a quatro raiz da árvore contendo quatro é oito. E a raiz da árvore contendo nove é nove. E assim fazemos nove um filho de oito anos. Dois e um, isso é fácil. Agora, se nós temos o nosso, o nosso oito e nove conectados, nós apenas verificado que eles têm raiz o mesmo e ambos têm a mesma raiz oito e assim que eles estiverem conectados. Cinco e quatro 4 de raiz é oito. 5 raiz é cinco. Eles são diferentes. Eles não são conectado. Cinco e zero. Cinco vai ser uma criança de zero. Sete e dois sete vai para ser um filho de raiz 2, que é um. Seis e um. 6 rota é zero 1 é a sua própria rota, de modo a zero se torna um filho de um. Cada uma destas operações de união apenas envolve mudar uma entrada na matriz. E, finalmente, sete e três. Assim, sete de raiz é um, três de raiz é de oito, um torna-se uma criança de oito anos. Ok e agora nós tem um componente conectado com todos os itens juntos. Tudo bem, então agora vamos ver o código para a implementação rápida união. O construtor é o mesmo que a outra um. Criamos a matriz e, em seguida, definir cada elemento a ser sua própria raiz. Agora temos um método particular que implementa este processo de encontrar a raiz perseguindo ponteiros pai até chegarmos ao ponto em que é igual a ID do eu, e se é não iguais, estamos apenas eu subir um nível na árvore, pus igual ID de eu e voltar lo. Então, a partir de qualquer nó, basta seguir ID igual ID eu até que eles estão igual e então você está em uma raiz e que é um método particular que podemos usar para implementar a operação de localização ou a operação ligado. Você acabou de encontrar o raiz de P e Q a raiz e se você verificar se eles são iguais. E então, a união operação é simplesmente encontrar as duas raízes I e em seguida, definir a ideia de o primeiro pode ser a segunda. Código realmente menos do que para Rápida, sem loops dianteiros. Não há circuito este selvagem que temos que se preocupar um pouco. Mas isso é uma forma rápida e implementação elegante de código para resolver o problema de ligação dinâmica chamada Quick-união. Então agora nós vamos ter de olhar para esse código pode ser eficaz para grandes problemas? Bem, infelizmente, Quick-união é mais rápido, mas também é muito lento. E é um pouco diferente do tipo muito lento então para Rápida, há momentos em que poderia ser rápido, mas também há momentos em que ele pode ser muito lento. E defeito para Quick-união é que as árvores podem ficar muito alto. O que significaria que a operação de busca seria muito caro. Você pode acabar com um longo árvore magro. De cada objeto apenas apontando para a próxima e, em seguida, fazer uma operação de localização para o objeto no fundo envolveria indo todo o caminho através da árvore. Custeio envolvendo no raio axises apenas para fazer a operação de busca e que vai ser muito lento se você tiver um monte de operações.