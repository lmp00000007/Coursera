欢迎回到算法课程 今天我们要讨论的是并查集 一种用于解决所谓的动态连通性问题的算法 我们将介绍两个经典算法：快速查找和快速合并 以及这些算法的一些实现和改进 本节课程的另一个目的是 体验一下我们日后将反复经历的 开发有效算法的流程  首先第一步是建立问题模型 找出解决该问题大体上所需要的基本操作 据此找出算法解决该问题 在很多情况下 我们最初提出的算法可能已经足够快 并且符合对存储空间的要求 这种算法我们可以直接拿来用 但是在另一些情况下 算法可能不够快 或者存储空间不足 我们需要搞清楚 为什么会这样 想办法找出造成这些问题的源头 然后提出新的算法 如此循环直到满意为止 这就是 设计和分析算法的科学途径 我们先建立数学模型 搞清楚问题的实质 然后通过实践来验证模型 进而改进模型和方法 在这里 我们来讨论动态连通性问题 也就是并查集问题的模型 问题是这样的 有一组共N个对象 我们不必在意它们究竟是什么 我们用0到N的数字来标记它们 两个对象间可以连通 我们假设有一个命令 用来连接两个对象 将两个对象传入该命令 将创造两者之间的连接 现在问题的关键是连通性的查询 即查询两个对象之间是否有连通的路径存在 例如 对这10个对象 我们已经执行了一组连接命令 连接4和3 3和8 6和5 9和4 2和1 然后我们进行一次连通性查询 0与7连通吗？ 在这个例子中 它们没有连通 所以我们得到“否” 但是 如果我们查询 8与9连通吗？ 我们将得到“是” 即便它们之间其实 并没有直接相连 因为存在一条路径从8到3到4到9 这就是我们的任务 即对于给定的对象集合 高效地实现这两个命令 现在 我们执行union(5, 0) 该命令创建5和0之间的连接 传入7和2的命令 创建7和2之间的连接 然后同样地 连接6和1 所以，如果现在我们查询0与7是否是连通的，额，将1和0连通也是可以执行的，那是一个冗余的连接 那么现在，如果我们问0和7是否连通，那么我们会回答“是” 所以这就是我们的要处理的问题，合并命令与连通查询的交叉混合，而且 我们需要能对大量对象高效地支持这些命令 那么，这就是一个大得多的例子。你会发现对于这个问题我们需要高效的算法 首先，你会发现我们需要计算机处理这个问题 对于人类需要花掉相当一段时间才能判定（给定两个对象）是否存在连接 在这个例子中，连接是存在的。现在 我们今天要学习的算法实际上并不会给出连接两个对象的路径 它只能回答这样的问题：是否存在一条路径？ 在第二部分课程中，我们会讲到能够确切地找出路径的算法 这些算法不如并查集高效，因为它们需要完成更多的工作。现在 这些算法的应用涉及各种各样的对象。这些算法 用在数码照片上，应用对象就是像素。用在网络上 应用对象是计算机。用在社交网络上，应用对象就是人 用在计算机芯片上，应用对象就是电路元件。应用对象可以是抽象的事物，如程序中的变量名 数学集合中的元素，也可以是物理对象如复合体系中的金属位 但是所有这些不同类型的对象 在编程中我们需要对每一个对象命名，我们会简单地 用从0到N-1的整数为这些对象编号。这对于我们的程序是便于着手的出发点 因为我们可以用整数作为数组索引号 之后便能快速地访问每个对象的相关信息。而且 还可以略去与并查集问题不相关的很多细节。实际上 将对象名称映射为从0到N的整数的这种做法 是符号表或搜索算法的一个漂亮的应用 是本课程中之后我们将会学习的用来解决映射问题的算法与数据结构 现在，关于连接 我们需要几个连接必须满足的抽象性质。这些性质都很自然而且直观 那么我们假设“连接到”是一个等价关系。就是说 每个对象都能连接到自己。“连接到”是对称的。如果P连接到Q 那么Q连接到P。而且“连接到”是传递性的。如果P连接到Q，而且Q连接到R 那么P就能连接到R。这些性质都很直观 但是明确列出这些性质并确定我们的算法具备这些性质是有必要的 当我们有了一个等价关系之后，一个对象和连接的集合就分裂为子集 这些子集叫连通分量。连通分量是互相连接的对象的最大集合 比如在这个小例子中 有三个连通分量。其中一个只有一个对象0构成，第二个 由对象1、4、5构成，第三个由其余四个对象构成 连通分量具有如下性质：连通分量中的任意两个对象都是相连接的 连通分量中对象不与连通分量之外的对象相连接 这就是连通分量。我们的算法通过维护连通分量来获得效率 并使用连通分量来高效地应答接收到的请求 好，那么要实现的操作有查找请求和 合并命令。我们要维护连通分量 查找就是检查两个对象是否在相同的分量中 合并命令就是将包含两个对象的分量替换为其并集 例如，如果我们有图中这些分量 收到了连接2和5的命令，根本上，我们需要 合并包含2和包含5的两个连通分量 得到一个大的连通分量，这样我们就只有两个连通分量了 从之前讨论过的那些我们得到了一个数据类型，在编程的概念中它是 为了解决问题我们想要实现的方法的规范 那么一个典型的Java模型中，我们要做的就是 创建一个叫UF的类，它包含两个方法，一个用来实现合并，另一个 用来实现连接查找，返回一个布尔量（逻辑变量，真或者假）。构建器需要对象的数量作为参数 这样它能够根据对象的数量建立数据结构 那么当我们在实现算法的时候，我们要在心里牢记 对象的数量和操作的数量都可能是巨大的 我们可能会有非常大量的合并与连接查询操作，而 我们的算法在这样的情况下也必须是高效的 这门课程中接下来常常要做的事就是要在处理更深层的问题之前 检查我们的应用编程接口（API）设计，我们通过设计一个 使用我们开发的数据类型的客户端来检查API。比如这个例子中 我们已经有了一个客户端从标准输入中读取信息。首先 读取一个整数，表示将要处理的对象的数量。然后是一对一对对象名字 客户端首先从标准输入中读取这个整数 并创建一个UF对象。然后只要标准输入中还有输入 客户端将从输入读取两个整数 如果它们没有相连，它将会连接他们并输出。如果它们已经相连 客户端就忽略这条输入。那么这就是我们的测试客户端，而且是一个很好的测试客户端 它可以确保任何一种实现都执行我们期望它进行的操作。好，这就是整体结构了 我们已经描述了我们想要实现的操作，细致到了代码层面。而且我们 有了我们的实现需要服务的客户端代码