1
00:00:01,006 --> 00:00:06,058
Мы рассмотрели эффективную
реализацию алгоритма,

2
00:00:06,058 --> 00:00:12,025
которая может решить задачу
объединения и поиска, рассмотрим

3
00:00:12,025 --> 00:00:17,095
практическое применение.
Есть огромное количество применений объединения и поиска.

4
00:00:17,095 --> 00:00:24,005
Мы говорили о динамической связности,
есть и много других примеров

5
00:00:24,005 --> 00:00:30,008
в вычислительных задачах.
В самом низу одна важная

6
00:00:30,008 --> 00:00:36,018
задача — обработка изображений для понимания того,
как помечать области изображения.

7
00:00:36,018 --> 00:00:41,057
Мы увидим алгоритм минимального
остовного дерева Крускала,

8
00:00:41,057 --> 00:00:48,009
это алгоритм обработки графов,
который использует объединение и поиск как подзадачу. Есть алгоритмы в физике

9
00:00:48,009 --> 00:00:54,077
для понимания физических явлений,
которые мы рассмотрим на примере.

10
00:00:55,000 --> 00:01:00,064
Поговорим о задаче перколяции.

11
00:01:00,086 --> 00:01:07,046
Это модель многих физических систем.
Рассмотрим абстрактную модель

12
00:01:07,046 --> 00:01:13,063
и коротко обсудим, как это применяется в физических системах. Итак рассмотрим

13
00:01:13,063 --> 00:01:20,076
сетку квадратов n x n, которые назовем участками.
Будем говорить, что участок открыт —

14
00:01:21,001 --> 00:01:27,076
белый цвет на диаграмме — с вероятностью p
или заблокирован — черный на диаграмме —

15
00:01:27,076 --> 00:01:34,029
с вероятность 1-p.
Будем называть систему 

16
00:01:34,029 --> 00:01:40,059
просачивающейся если верх
и низ соединены открытыми участками. Так в системе

17
00:01:40,059 --> 00:01:46,089
слева, вы можете найти путь
сверху вниз по белым 

18
00:01:46,089 --> 00:01:53,019
квадратам, но система справа
не просачивающаяся, нет пути 

19
00:01:53,019 --> 00:02:00,017
сверху вниз по белым квадратам.
Это модель для многих 

20
00:02:00,017 --> 00:02:05,098
систем. Например в электронике.
Можно представить, что открытые участки —

21
00:02:05,098 --> 00:02:11,091
проводники, а заблокированные изолированы.
И тогда если есть проводимость

22
00:02:11,091 --> 00:02:17,091
сверху вниз, тогда устройство проводит
электричество. Или вы можете считать,

23
00:02:17,091 --> 00:02:23,039
что вода текущая сквозь поры
некоторого вещества, где свободные участки

24
00:02:23,039 --> 00:02:28,055
просто пустые, а заблокированные участки
заполнены материалом, и вода может 

25
00:02:28,055 --> 00:02:34,030
или протечь сверху вниз, или нет.
Или это может быть социальная сеть,

26
00:02:34,030 --> 00:02:39,869
где между людьми либо есть связь,
либо нет,

27
00:02:39,869 --> 00:02:46,063
как и путь коммуникации
от одной группы людей 

28
00:02:46,063 --> 00:02:52,076
до другой через социальную сеть.
Это всего лишь несколько примеров

29
00:02:52,076 --> 00:02:58,089
модели перколяции. Мы поговорим
о случайной модели,

30
00:02:58,089 --> 00:03:05,075
где участки свободны
с заданной вероятностью.

31
00:03:06,005 --> 00:03:11,087
Вероятность, что участок свободен,
низкая слева, и на этих двух примерах

32
00:03:11,087 --> 00:03:17,002
слева просачивания не будет.
Недостаточно открытых участков

33
00:03:17,002 --> 00:03:22,016
для соединения верха и низа.
Если вероятность высока,

34
00:03:22,016 --> 00:03:26,002
то будет много открытых участков,
и будет просачивание.

35
00:03:26,002 --> 00:03:30,055
Будет много путей сверху вниз.
Но по середине,

36
00:03:30,055 --> 00:03:35,067
где вероятность средняя,
неизвестно будет ли просачиваться или нет.

37
00:03:35,067 --> 00:03:40,065
Математический вопрос
из этой модели такой: как мы узнаем

38
00:03:41,005 --> 00:03:46,062
будет ли перколяция? В этой задаче
и многих подобных

39
00:03:46,062 --> 00:03:52,034
есть то, что называют фазой перехода.
Ниже определенного значения

40
00:03:52,034 --> 00:03:56,072
перколяции не будет.
А при превышении начнется просачивание.

41
00:03:56,072 --> 00:04:02,003
Порог между 2 состояниями очень резкий. 

42
00:04:02,003 --> 00:04:07,092
При росте N существует
некое значение вероятности,

43
00:04:07,092 --> 00:04:13,089
ниже которого почти наверняка
просачивания не будет,

44
00:04:13,089 --> 00:04:19,045
а выше — точно будет. Задача найти значение. Это пример

45
00:04:19,045 --> 00:04:26,051
математической модели с понятной задачей.

46
00:04:26,051 --> 00:04:32,092
Но это пороговое значение не найдено.

47
00:04:32,092 --> 00:04:37,032
Единственное решение —
вычислительная модель

48
00:04:37,032 --> 00:04:42,082
для определения этой вероятности.
Такая симуляция

49
00:04:42,082 --> 00:04:47,093
доступна благодаря алгоритму
объединения и поиска.

50
00:04:47,093 --> 00:04:53,024
Рассмотрим на примере, зачем нужны
быстрые алгоритмы объединения и поиска.

51
00:04:53,024 --> 00:04:59,053
Проведем моделирование методом
Монте-Карло.

52
00:04:59,053 --> 00:05:06,063
Мы задаем заблокированную сетку
и случайно выбираем

53
00:05:06,063 --> 00:05:12,096
открытые участки. Каждый раз добавляя
открытый участок, мы проверяем

54
00:05:12,096 --> 00:05:18,095
систему на предмет перколяции. Продолжаем до тех пор, пока не достигнем

55
00:05:18,095 --> 00:05:24,026
перколяции. Процент отрытых участков

56
00:05:24,026 --> 00:05:29,080
будет оценкой порогового значения.

57
00:05:29,080 --> 00:05:35,008
Компьютер позволяет провести
эксперимент более миллиона раз,

58
00:05:35,008 --> 00:05:40,069
если при этом мы сможем
определять перколяцию.

59
00:05:40,069 --> 00:05:45,064
Моделирование методом
Монте-Карло дает решение

60
00:05:45,084 --> 00:05:51,012
научной проблемы,
которая не решена математически.

61
00:05:51,012 --> 00:05:56,097
Рассмотрим подробнее,
как мы будем использовать

62
00:05:56,097 --> 00:06:03,092
модель динамической связности.
Мы создадим по

63
00:06:03,092 --> 00:06:09,093
объекту для каждого участка
и пронумеруем их от нуля до N^2-1

64
00:06:09,093 --> 00:06:16,091
Затем будем соединять, если они соединяются

65
00:06:16,091 --> 00:06:23,029
по открытым участкам. Модель перколяции
слева соответствует модели 

66
00:06:23,029 --> 00:06:28,089
справа, согласно тому как мы это делали.
Можно сказать,

67
00:06:28,089 --> 00:06:33,081
что теперь нужно проверить,
связан ли какой-либо участок снизу

68
00:06:33,081 --> 00:06:39,039
с каким либо участком сверху,
используя для этого объединение-поиск.

69
00:06:39,039 --> 00:06:44,091
Но это метод перебора
с большими затратами по времени.

70
00:06:44,091 --> 00:06:50,030
Потому что ему потребуется N^2 операций поиска
для проверки связности:

71
00:06:50,030 --> 00:06:55,048
для каждого участка сверху проверяется
участок снизу.

72
00:06:55,048 --> 00:07:01,024
Слишком медленно. Вместо этого
создадим по виртуальному участку сверху и снизу.

73
00:07:01,024 --> 00:07:06,087
И затем, если мы хотим узнать,
просачивается система или нет, мы просто проверяем

74
00:07:06,087 --> 00:07:14,025
связан ли верхний виртуальный участок
с нижним. Как мы 

75
00:07:14,025 --> 00:07:20,097
моделируем открытие нового участка?
Для того, чтобы открыть участок мы соединяем его со всеми

76
00:07:20,097 --> 00:07:28,034
соседними открытыми участками.
Несколько операций объединения, которые легко реализовать.

77
00:07:28,034 --> 00:07:34,092
Можем использовать тот же код,
который разработали,

78
00:07:34,092 --> 00:07:42,000
чтобы решить задачу связности.

79
00:07:42,000 --> 00:07:48,082
Получаем результат, запуская моделирование
достаточно много раз:

80
00:07:49,007 --> 00:07:55,409
порог перколяции примерно 0.592746.
Используя алгоритм,

81
00:07:55,409 --> 00:08:01,693
получаем достаточно точный ответ.
Если используем медленный алгоритм объединения и поиска,

82
00:08:01,693 --> 00:08:06,822
то не сможем запустить его
для очень больших задач и не получим

83
00:08:06,822 --> 00:08:11,979
точный ответ. Мы взяли важную задачу

84
00:08:11,979 --> 00:08:17,359
динамической связности
и смоделировали её, чтобы понять, какого рода

85
00:08:17,359 --> 00:08:22,109
структуры данных и алгоритмы
нам нужны для ее решения. Мы рассмотрели

86
00:08:22,109 --> 00:08:26,676
несколько простых алгоритмов
для решения задачи и быстро заметили,

87
00:08:26,676 --> 00:08:31,953
что они не походят для больших задач. И затем рассмотрели как их улучшить,

88
00:08:31,953 --> 00:08:37,300
чтобы получить эффективный алгоритм.
Затем взялись за приложения, которые нельзя

89
00:08:37,300 --> 00:08:42,768
решить без эффективных алгоритмов.

90
00:08:42,768 --> 00:08:47,954
При работе над алгоритмами
мы создаем математические модели,

91
00:08:47,954 --> 00:08:52,343
которые помогают понять свойства
разрабатываемых алгоритмов.

92
00:08:52,343 --> 00:08:56,675
Мы тестируем модели
в ходе экспериментов с целью улучшить

93
00:08:56,675 --> 00:09:02,363
алгоритмы, разработать лучшие алгоритмы
и более специфические модели,

94
00:09:02,363 --> 00:09:07,061
пока не получим
решение практических задач.

95
00:09:07,061 --> 00:09:12,165
В этом курсе мы будем использовать
общую структуру

96
00:09:12,165 --> 00:09:14,036
для изучения алгоритмов.