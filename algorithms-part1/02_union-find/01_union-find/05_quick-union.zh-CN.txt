好吧，快速查找对于巨大问题太慢了。所以我们如何才能做得更好？ 我们的第一个尝试是一个叫做快速合并的替代算法。这在 算法设计中是所谓的“懒策略”，我们尽量避免计算直到不得不进行计算 它使用相同的数据结构，大小为N的id数组，但是 数组有了不同的含义。我们把数组看作 一组树即一片森林的表示，如右图所示。那么 数组中每一项则包含它在树中的父节点。比如 3的父节点是4，4的父节点是9。所以数组中3对应的项是4 4对应的项是9。现在每个记录都有对应的根节点 是其所在树的根节点。彼此不相连的对象 在各自的连通分量中，记录中的父节点则指向自己，所以1指向自己 但是9也指向自己，因为它是树的根节点，那棵树包括2、4、3 所以，利用这个数据结构我们可以将每个记录与一个根节点相联系 这就表示了它所在的连通分量 3的根节点是9，一路从父节点向上就能找到根节点。一旦我们能够计算根节点 我们就能这样实现查找操作：通过检查 我们想要知道是否相连的两个对象的根节点是否相同 这和它们是否在相同的连通分量这个问题是等价的。这里需要一些计算 以找到每个对象的根节点，但是合并操作非常简单 要合并包含两个对象的分量，两个对象在不同的分量中 我们只需要将P的根节点id记录值设为Q的根节点ID记录值 我们将P的树指向Q。例如，我们将9对应的项改为6以 合并3和5所在的分量 只需改变数组中一个值我们就将两个大分量合并到了一起 这就是快速合并算法。因为合并操作只 改变数组中的项。查找操作需要多一些操作 我们先来看一下这个实现运行的演示 我们再一次从同样的方式初始化，但是id数组项实际上表示 每个对象是一棵小树其中每个节点指向它自己 即它自己那课树的根节点。现在如果我们要将4和3放进同一个分量 我们要做的就是将包含第一个对象的分量的根节点 变成包含第二个对象的分量的根节点的一个子节点 这个例子中，我们就将4的父节点设为3。现在是3和8 同样地，我们将第一个对象变为包括第二个对象的树的根节点的子节点 所以现在3、4、8在同一个分量中 6和5，6成为5的子节点。9和4，现在 包含4的树的根节点是8，包含9的树的根节点是9 所以9变成8的一个子节点。2和1，这个很简单 现在如果我们得到8和9是否连通的请求，我们只需要检查他们是否 具有相同的根节点，而它们的根节点都是8，所以它们是连通的 5和4，4的根节点是8，5的根节点是5，根节点不同，它们不连通 5和0，5成为0的一个子节点。7和2，7成为2的根结点1的一个子节点 7成为2的根结点1的一个子节点
6和1，6的根节点是0，1是它自己的根节点 所以0成为1的一个子节点。每个合并操作只需要 改变数组中的一项。最后，7和3，7的根节点是1 3的根节点是8，1成为8的一个子节点。好，现在 我们有了一个包含所有对象的连通分量。那么，现在我们来看 实现快速合并的代码。构造器与快速查找相同 我们创建一个数组并将每个对象设为它自己的根节点 这里我们有一个私有方法实现寻找根节点的过程，通过回溯 父节点直到到达节点i，其id记录值也等于i。如果不相等 则继续将i在树中上移一层，把i设为i的id记录值。最后返回i 所以从任何节点开始，只需要一直进行i等于i的id记录值操作直到两者相等 就能到达根节点。我们用这个私有方法来 实现查找操作或者“是否连通”操作。只需要找到 P的根节点和Q的根节点，检查它们是否相等。接下来合并操作 就是找到两个根节点并将第一个根节点的id记录值设为第二个根节点 实际上快速合并算法的代码量比快速查找少，而且没有for循环 这里有一个while循环我们可能需要稍微考虑一下。但是 快速合并算法依然是用来求解动态连通性问题的一个快速而优雅的代码实现 接下来我们看看这个代码对于巨大问题是否是高效的 不幸的是快速合并算法快了一些但是依然太慢了 相对快速查找它是另一种慢 有些情况下它可以很快，而有些情况下它还是太慢了 快速合并的缺点在于树可能太高了。这意味着 查找操作的代价太大了。你可能需要回溯一棵瘦长的树 每个对象只是指向下一个节点，那么对叶子节点执行一次查找操作 需要回溯整棵树 只进行查找操作就需要花费N次数组访问 如果操作次数很多的话这就太慢了