さて、高速findは巨大な問題には
遅すぎます。では、どうやってより良く実行しましょうか？ 最初に、高速unionと呼ばれる
代替案を試します。 これは、いわゆる遅延評価のアプローチで、
する必要があるまで仕事を しないでおくというものです。このアルゴリズムでは、
サイズMの同じデータ構造、配列IDを使いますが、 今度は異なる解釈をします。
私たちは、この配列を フォレストと呼ばれる木の集合として解釈します。
スライドの右に示したようなものです。 配列の各要素は、木の親への参照を含んでいます。 たとえば、3の親は4で、4の親は9です。
ですので、配列の3の要素は4であり、 4の要素は9です。ここで、配列の各要素は
ルートに関連付けられています。 各要素の木のルートです。
要素は、すべてそれ自体が 自分につながったコンポーネントなので、
自分自身を指しています。ですので1は1を指しています。 しかし、同様に9も自分自身を指しています。
これは木のルートであり、 2と4と3を含んでいます。つまり、このデータ構造から、
各要素とルートとを関連付けることができます。 接続されたコンポーネントを
代表するのがルートと言うことですね。 ですので、3のルートは9です。たどっていくと
ルートに行き着きます。 さて、いったんルートが計算できれば
find操作は実装できます。接続されているか 確かめようとしている2要素が同じルートを
持っているかを確かめれば良いだけです。 これは、同じ接続コンポーネントを持っているか、
というのと同じことです。 各要素のルートを探すのは少し作業がいりますが、
unionはとても簡単です。 2つの異なる要素を含んだコンポーネントを
結合するには、ここでの2要素は 異なるコンポーネントと考えられますが、
PのルートIDをQのルートIDに設定するだけで良いです。 ではPの木をQを指すようにしましょう。
この場合では、9のエントリを 6にすることで、3と5とを結合します。この木は3と5を含んでいますので。 そして、配列内の1つの値を変更するだけで
2つの大きなコンポーネントを 結合できます。これが高速unionアルゴリズムです。
なぜなら、union操作が 配列内の1要素を変更するだけで良いからです。
find操作は少し作業が必要です。 それでは実装を見てみましょう。
まず1つの操作例をデモで見てみます。 ここでは、繰り返しになりますが、
同じ方法で開始しますが、配列の要素の考え方は それぞれの要素が小さな木になっており、
ノードは自分自身を指していると考えます。 自分自身の木のルート、ということです。
ここで、4を3を同じコンポーネントに入れる必要があれば 1番目の要素の入ったコンポーネントの
ルートを取り出し、 これを2番目の要素の入ったコンポーネントの
ルートの子とすれば良いだけです。 この場合では、4の親を3とするだけです。 それから3と8。ここでも繰り返しますが、
最初の要素を取り出し、それを2番目の要素を 含んだ木のルートの子とします。ですので、
3,4,8が同じコンポーネント内にあることになります。 6と5ですね。6が5の下に付きます。
9と4ですね。ここで、4は 4を含んだ木のルートは8で、
9を含んだ木のルートは8ですので、 9を8の子とします。
2と1ですね。これは簡単です。 ここで、8と9が接続されているか
チェックを受ければ、それらが同じルートを 持つかどうかだけチェックします。
5と4の場合、4のルートは8です。 5はルートが5ですから違います。
接続されていません。 5と0ですね。5が0の子になります。
7と2ですね。 7が2のルートである1の子になります。
6と1ですね。6のルートは0で 1は自分がルートなので、0がその子になります。
union操作の1つ1つが 単純に配列の1要素を変更するだけです。
最後に7と3ですね。 7のルートは1で3のルートは8ですので、
1が8の子となります。いいでしょう。 これで1つのコンポーネントを得、
すべての要素がつながりました。 では高速unionの実装コードを見てみましょう。
コンストラクタは同じです。 配列を作り、各要素が自分自身をルートに設定します。
ここで、 privateメソッドを作っていて、
ルートを探す処理を実装しています。 iがiのID値と等しくなるまで親への参照を追いかけます。 等しくなければ、iを木の一段上に移動させます。
iをiのID値に設定するのですね。 それを返り値とします。ですので、どのノードから始めても
ID値がiのID値と等しいものに なるまで追いかけ、つまりルートにたどり着きます。
これはprivateメソッドであり findおよびconnected操作の実装に使用します。 同じかどうかのチェックには、Pのルートと
Qのルートを見つければよいだけです。 union操作は簡素化しており、2つの要素の
ルートを探し、第1引数のIDを 第2引数のそれに設定するだけです。
高速findよりコード量は少ないです。 forループがありません。少し心配する
必要のあるwhileループが一個ありますが。 しかし、これは高速でエレガントなコード実装で、
動的接続問題を解くものです。 高速unionと呼ばれます。それでは、このコードが
大きな問題に対して効率的かを見ていきましょう。 まぁ、残念ながら高速unionは速いのですが、 同時に遅すぎるのです。高速findとは
少し異なる遅さなのです。 数倍速いこともありますが、
数倍遅すぎることもあるのです。 高速unionの欠点は、木がとても
高くなってしまうことがあることです。 これはつまり、find操作がとても高くついて
しまうということです。長くひょろっとした 木をかき分けていくことになります。各オブジェクトは
次の要素を指しているだけですから 底にあるオブジェクトに対するfind操作は木を
すべて上っていく処理になります。 コストは、単にfind操作を行うだけで
配列のアクセス量が増えてしまいます。 たくさん操作をすれば遅すぎるでしょう。