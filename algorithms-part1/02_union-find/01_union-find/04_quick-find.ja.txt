動的接続問題を解くアルゴリズムの最初の実装を見てみましょう。 Quick findと呼ばれているものですね。これはいわゆる欲張りアルゴリズムで、 接続問題をとくことが出来ます。アルゴリズムで使っているデータ構造は 対象でインデックス化された整数配列です。 PとQの2つの対象が接続されているということは、 配列の中の2つのエントリが同じであり、かつ、そのときに限ると考えることが出来ます。今回の10個の対象の例では、 配列idで7つの接続が出来た後の状況を示しており、 スライドの中央に示しています。で、ここでは、0、5、 6はすべて同じ接続コンポーネントに含まれています。なぜなら、それらは 同じ配列のエントリ、0になっているからです。1、2、7も皆、エントリが1で、3、4、8、 9はすべてエントリが8になっています。つまり、このようにして、接続されていることを 示しているのです。また明らかに。findの操作に対する高速な実装をサポートすることができます。 配列のエントリをチェックして、それらが等しいかどうかを見ればよいですね。PとQが同じIDを持っているのかをチェックするのです。 そう、6と1は違うIDになっています。1のIDは1で6のIDは 0です。この2つは同じ接続コンポーネントの中には含まれていないということです。unionはもう少し難しく、 与えられた2つの対象を含むコンポーネントを併合する必要があります。エントリが どちらかのIDに等しいID場合は、もう片方のIDni
すべて変更する必要があるのです。そのときには Pと同じものをすべてQと同じになるように変更する必要があります。 6と1を連結するときは、0、5、6のエントリを変更する必要があります。 6と同じ接続コンポーネントにあるもの全部です。0から1に変更します。 これは、皆さんもわかると思いますが、対象の数が非常に大きくなるときには、ちょっと問題になります。 なぜかというと、たくさんの値を変更することになるからです。しかし、それでも簡単に 実装できるので、これを最初のスタート地点にします。はじめに どのように機能するかをお見せしましょう。そう、最初は、配列idを準備して、各エントリはそのインデックスと等しくなっています。 こらは、すべての対象が独立であるということです。皆、 自分自身の接続コンポーネントに入っているということですね。さあ、ここでunionオペレーションを受け取ると、そうですね、 4が3と接続されるとします。すると、すべてのエントリ、 IDが1番目のIDと同じIDのものをすべて、2番目のIDに変更します。この場合は、 3と4を接続するということは、4を3に変更する必要があります。そして、 もう少し続けてみましょう。するとどのようにしているのかを理解するようになってきます。3と8 3と8を接続するために、こんどは3と4を8と接続する必要があります。 これらのエントリをすべて8に変更する必要があります。いいですか？今度は、 6と5はどうでしょう？今度も1番目のエントリを変更して、2番目と会わせる必要があります。 そうです、6と5を接続するには、6を5に変更します。9と4はどうでしょうか？ 今度も変更する必要がありますね、9と4を接続するのですから、9のエントリを4と同じにする必要があります。 これで、3、4、8、9ができました。皆、エントリが8になっています。 同じ接続コンポーネントに入っていることになりますね。2と1についても、 2を1に変更して接続します。8と9は、もう接続されています。 配列idのエントリがもう同じですから。接続のクエリ、findは真を返します。 既に接続されています。5と0のエントリは違っています。 接続されていないということですから、この場合は偽を返します。接続されていないということです。 もし、5と0を接続したいのであれば、同じように、 5と6の両方の対応するエントリを0に変更すればよいですね。7と2は、7と２を接続しましょう。 これは簡単ですね。6と1を接続してみます。今度は3つのエントリを変更する必要があります。 すべて0になっているのを1に変更する必要があります。quick findのデモを見てみました。 今度は、これを実装したプログラムを見てみましょう。いいですか？ デモを頭に浮かべておくと、このアルゴリズムをプログラミングするのはきっと単純だと思います。 とても面白いプログラミングの練習で、 最初は多くの人が間違えます。では、コンストラクターからはじめます。 プライベートな整数配列があります。これが、id配列です。このデータ構造を使って、 実装を進めることになります。 コンストラクターは配列を生成し、配列のインデックスに対応した値をセットしていきます。 i番目の配列にはiをセットします。簡単ですね。findオペレーション、あるいは、connectedオペレーションです。 これは簡単ですね。これが、quick findアルゴリズムです。2つの引数、 PとQをとって、id配列のエントリが等しいかどうかをチェックして、その結果を返します。 等しければ、真を返し、異なるときは偽を返します。 複雑なオペレーションを実装しているのはunionです。そこでは、 まず、一番目の引数に対応するidを見つけ、次に二番目の引数に対応するidを見つけます。 次に、すべての配列を探索して、 一番目の引数のidと等しいidのエントリを探し、そこに 二番目の引数のidをセットするのです。これはちょっと愚直な実装ですね。 多くの人が間違いをおかすといいましたね。ここで犯しやすい間違いは、 ここに、一番目に取り出した値でなく、Pのidをセットしまうことです。皆さんもわかると思いますが、 油断のならないバグです。さて、これがquick findの実装です。 次に考えるのは、アルゴリズムがどれくらい効率的であるかということです。 いくつか詳細の話もしますが、 ここでは、次のような回数を考えれば十分ですね。 コードが配列にアクセスする回数を数えるのです。実行してわかるのは、 初期化とunion操作の両方がforループを含んでいて、配列をすべて走査しています。 したがって、配列のエントリにアクセスした後、一定のn倍の比率でアクセスする必要があります。 findオペレーションは高速で、配列のエントリに対するチェックは、コンスタントな回数です。 これは問題で、union操作のコストが大きすぎるのです。 特にn個の対象に対して、n個のunionコマンドがあるときは、合理的でないことが明らかです。 それぞれが接続されているか、そうでないかのいずれかで平方的な時間という二次関数的な時間が必要になるのです。 このコースを通して、繰り返し登場するテーマの一つが、 二次関数的な時間は非常に遅いということです。 大規模な問題では、二次関数時間のアルゴリズムは適用することはできません。なぜなら、スケールしないからです。コンピュータが より高速に、大規模なものになっても、二次関数的なアルゴリズムは実際はどんどん遅くなるのです。 簡単に私が意図していることをお話しておきます。非常にラフな基準ですが、 コンピュータは毎秒何十億もの命令を実行することができ、 メモリには何十億ものエントリを格納することができます。つまり、 メモリ上のすべてのエントリに約１秒以内でアクセスすることができます。このような 不思議なことに、このような基準が50~60年もの間用いられてきました。コンピューターは より大きくなりましたが、同時により高速にもなったので、メモリを全部アクセスするのに２、３秒ですむというものです。 メモリ上にあるのが数千ワードのであれば正しいですし、 数十億、それ以上の場合でも大丈夫です。ですから コンピューターはこのようなものだとしましょう。これは、巨大なメモリ空間があれば、 巨大な問題を解決することができるということです。数十億の対象がある場合も、そこで 数十億のunionコマンドを実行することは期待できるでしょう。しかし、問題はquick findアルゴリズムで、 10の18乗のオペレーション、あるいは、配列への操作やメモリアクセスが必要になるのです。 簡単な計算で、三十数年もの計算時間となることがわかります。 現在のコンピューターでこのような問題を解くことは現実的ではないですね。 また、理由、問題は二次関数的なアルゴリズムが技術に対してスケールしないことです。 十倍の速さの新しいコンピュータがあれば、 十倍の大きさの問題を解決しようとします。しかし、二次関数的な アルゴリズムを使うと、十倍遅くなってしまうのです。 このような状況を回避するために、より効率的なアルゴリズムを開発し、 このような問題を解く必要があるのです。