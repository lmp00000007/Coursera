Ok, also ist QuickFind zu langsam für große Probleme. Wie geht es besser? Unser erster Versuch ist eine Alternative namens QuickUnion. Dies ist die sogenannte "bequeme" Herangehensweise an Algorithmusdesign, bei der wir versuchen, erst dann zu arbeiten, wenn wir es müssen. Sie verwendet die gleiche Datenstruktur oder Feld ID der Größe N, aber mit einer anderen Bedeutung. Wir werden ein Feld als eine Menge Bäume betrachten, die als ein Wald bezeichnet wird, so wie rechts zu sehen. Jeder Eintrag in das Feld enthält eine Referenz auf seinen Elternknoten im Baum. Der Elternknoten von 3 ist also 4, der von 4 ist 9. Also ist der Eintrag für 3 im Feld vier und der für 4 ist neun. Jeder Eintrag im Feld hat eine dazugehörige Wurzel, und zwar die seines Baums. Elemente, die allein in ihrer Menge sind, zeigen auf sich selbst, also zeigt 1 auf sich selbst, aber auch 9, da es die Wurzel des Baums ist, der 2, 4 und 3 enthält. Also können wir aus dieser Datenstruktur jedem Element eine Wurzel zuordnen, die repräsentativ für die Gesamtmenge ist. Die Wurzel von drei ist also 9. Sobald wir also diese Wurzeln berechnen können, können wir die Suchoperation implementieren, indem wir einfach prüfen, ob die beiden zu untersuchenden Elemente, die verbunden sein sollen, die gleiche Wurzel haben. Das ist äquivalent zu der Aussage, ob sie in der gleichen Menge sind. Das ist also das Problem, die jeweiligen Wurzeln zu finden, aber die Union-Operation ist sehr einfach. Um zwei Elemente in verschiedenen Mengen zu vereinigen, müssen wir nur die ID von Ps Wurzel auf die ID von Qs Wurzel setzen. Wenn also P´s Baum auf Q zeigen soll, würden wir den Eintrag für 9 auf sechs ändern, um drei und fünf zu vereinen, also die Mengen, drei und fünf beinhalten. Und durch den Wechsel eines einzigen Eintrags im Feld bekommen wir die beiden großen Mengen vereinigt. Das ist der QuickUnion-Algorithmus. Da eine Vereinigungsoperation nur durch eine einzige Veränderung in den Einträgen des Felds geschieht. Die Suchoperation ist etwas aufwändiger. Aber sehen wir uns das Demo der Implementierung an. Wir fangen genauso an, aber jetzt bedeutet das ID-Feld, dass jeder Eintrag einen kleinen Baum beinhaltet, in dem jeder Knoten auf sich selbst zeigt. Er ist die Wurzel seines eigenen Baums, also können wir jetzt drei und vier in einer Menge vereinen, indem wir die Wurzel der Menge, die das erste Element enthält, nehmen, und es zum Kind der Wurzel der zweiten Menge machen. In diesem Fall nehmen wir vier als Kindknoten von drei. Und jetzt 3 und 8. Wir nehmen also wieder das erste Element und machen es zum Kind des Baums, der das zweite Element enthält. Jetzt sind also 3, 4 und 8 in der gleichen Menge. Sechs und fünf gehen unter fünf. Neun und vier, die Wurzel des Baums, der vier enthält ist acht. Und die Wirzel des Baums, der neun enthält ist 9. Also wird neun ein Kind von acht. Zwei und eins, das ist einfach. Also wenn wir jetzt acht und neun verbunden haben, haben wir geprüft, dass sie die gleiche Wurzel haben, nämlich acht, also sind sie verbunden. 5 und 4: Die Wurzel von 4 ist acht, die von fünf ist fünf. Sie sind verschieden. Sie sind also nicht verbunden. Fünf und null. Fünf wird ein Kind von 0. Sieben und zwei: Sieben wird ein Kind der Wurzel von zwei, also von eins. Sechs und Eins: Die wurzel von sechs ist null, eins ist seine eigene Wurzel, also wird null das Kind von eins. Jede dieser Vereinigungoperationen beinhaltet nur das Ändern eines einzigen Eintrags im Feld. Und zum Schluß, sieben und drei. Die Wurzel von sieben ist eins, die von drei ist acht, also wird eins das Kind von acht. Also haben wir jetzt eine große Menge mit allen Elementen. Also sehen wir uns jetzt die Implementierung der QuickUnion an. Der Konstruktor ist der gleiche wie vorher. Wir implementieren das Feld und setzen jedes Element als seine eigene Wurzel. Jetzt haben wir eine private Methode, die die Suche nach der Wurzel implementiert, indem sie die Elternzeiger durchsucht, bis wir zu dem Punkt kommen, wo i gleich der ID von i ist, und wenn es nicht gleich ist, gehen wir eine Ebene im Baum höher, setzen i = id[i] und geben es zurück. Also kann man an jedem Knoten starten, man folgt einfach den i=id(i) bis sie gleich sind, dann ist man an der Wurzel. Mit dieser privaten Methode können wir die Suchoperation implementieren oder die Vereinigungsoperation. Man findet einfach die Wurzel von P und die von Q und prüft, ob sie gleich sind. Und die Vereinigung ist einfach auch das Finden der beiden Wurzeln und dann das Ändern der id der ersten auf die zweite. Sogar weniger Code als für QuickFind, keine for-Schleifen. Es gibt eine Schleife, über die wir uns etwas Gedanken machen müssen. Aber das ist eine schnelle und elegante Implementierung, um das dynamische Vereinigungsproblem zu lösen. Also fragen wir uns jetzt, kann dieser Code effektiv sein, um große Probleme zu lösen? Nun leider ist QuickUnion schneller, aber es ist auch zu langsam, aber eine andere Art von zu langsam. Quick Find kann mal schnell sein, aber auch mal zu langsam. Und bei QuickUnion werden die Bäume einfach zu groß. Das würde heißen, dass die Suchoperation zu teuer wird. Man könnte einen zu langen dünnen Baum bekommen. Immer ein Objekt auf das nächste zeigen lassen und dann eine Suchoperation zu starten, würde bedeuten, den gesamten Baum durchsuchen zu müssen. Es wären also N Feldzugriffe nur für eine Suchoperation, und das ist zu langsam, wenn man viele Operationen hat.