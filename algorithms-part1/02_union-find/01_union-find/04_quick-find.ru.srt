1
00:00:01,078 --> 00:00:08,004
Посмотрим на первую реализацию
алгоритма решения проблемы 

2
00:00:08,004 --> 00:00:14,012
динамический связности, называемую быстрым поиском.
Это так называемый немедленный алгоритм

3
00:00:14,012 --> 00:00:20,013
для решения такой задачи.
Структура данных, которую мы будем использовать

4
00:00:20,013 --> 00:00:25,082
для алгоритма, — это просто
целочисленный массив проиндексированный объектами.

5
00:00:25,082 --> 00:00:31,099
Будем считать, что два объекта P и Q
соединены тогда и только тогда,

6
00:00:31,099 --> 00:00:39,005
когда их элементы в массиве одинаковы.
В этом примере с 10 объектами

7
00:00:39,005 --> 00:00:46,099
массив, который описывает
ситуацию после 7 соединений

8
00:00:46,099 --> 00:00:53,349
представлен в центре слайда.
И так точки 0, 5

9
00:00:53,349 --> 00:00:59,578
и 6 принадлежат одной компоненте,
потому что имеют одинаковое значение

10
00:00:59,578 --> 00:01:05,171
в массиве, 0.
У 1, 2 и 7 значение в массиве 1. А у 3, 4, 8,

11
00:01:05,171 --> 00:01:10,664
и 9 - значение 8.
Такое представление показывает, что они

12
00:01:10,664 --> 00:01:16,636
соединены. Ясно что это обеспечит
быструю реализацию операции

13
00:01:16,636 --> 00:01:22,439
поиска. Мы просто проверяем, равны ли
элементы массива. Проверяем имеют ли

14
00:01:22,439 --> 00:01:27,904
P и Q один ID. Так 6 и 1 имеют разные ID.
У 1 ID 1, а у 6 —

15
00:01:27,904 --> 00:01:34,171
0. Они не в одной связной компоненте.
Объединение сложнее.

16
00:01:34,171 --> 00:01:40,981
Для того чтоб объединить компоненты содержащие
два данных объекта, мы должны изменить

17
00:01:40,981 --> 00:01:47,755
элементы массива, чьи ID равны
одному из них на другой. И произвольно мы

18
00:01:47,755 --> 00:01:53,634
выбираем изменить те что равны P на те что равны Q.

19
00:01:53,634 --> 00:01:58,898
Так если мы объединяем 6 и 1, мы должны изменить элементы 0, 5. 

20
00:01:58,898 --> 00:02:04,741
и 6. Все из той же связной компоненты,
что и 6. От 0 до 1.

21
00:02:04,741 --> 00:02:10,917
И это, как мы увидим, проблема,
когда имеем дело с большим количеством

22
00:02:10,917 --> 00:02:16,927
объектов, потому что много значений
могут меняться. Но это легко 

23
00:02:16,927 --> 00:02:23,263
реализуемо, и это будет нашей стартовой точкой.
Итак, начнем с демонстрации,

24
00:02:23,263 --> 00:02:31,189
как это работает. Изначально мы задаем
массив ID, где каждый элемент равен 

25
00:02:31,189 --> 00:02:37,932
его индексу. Можно сказать,
что все объекты независимы.

26
00:02:37,932 --> 00:02:43,918
Они принадлежат собственной связной компоненте.
Перейдем к операции объединения.

27
00:02:43,918 --> 00:02:49,694
4 должно быть объединено с 3.
Тогда мы должны изменить все элементы,

28
00:02:49,694 --> 00:02:56,190
ID которых равны ID первого, на ID второго.
Так в этом случае соединения

29
00:02:56,190 --> 00:03:02,061
3 и 4 нам нужно изменить 4 на 3.

30
00:03:02,061 --> 00:03:10,259
Повторим несколько раз,
чтобы вы поняли как это работает. Теперь 3 и 8

31
00:03:10,259 --> 00:03:13,657
должны быть соединены,
т.е . сейчас 3 и 4 должны быть соединены с 8.

32
00:03:13,657 --> 00:03:19,950
И оба элемента должны измениться на 8.
Ясно? А как теперь с 6 и 5?

33
00:03:19,950 --> 00:03:26,026
Мы снова меняем первый на второй. 

34
00:03:26,026 --> 00:03:32,332
Для объединения 6 и 5 мы меняем, 6 на 5.
Что насчет 9 и 4? Теперь

35
00:03:32,332 --> 00:03:39,789
мы должны соединить 9 и 4,
мы должны изменить элемент 9 на тот

36
00:03:39,789 --> 00:03:45,325
же, что у 4. Получаем 3, 4, 8 и 9.
Все имеют элемент 8.

37
00:03:45,325 --> 00:03:52,365
То есть связаны одним элементом.
2 и 1 значит, что мы

38
00:03:52,365 --> 00:04:00,013
соединяем 2 и 1, изменяя 2 на 1.
8 и 9 уже соединены.

39
00:04:00,013 --> 00:04:06,660
Они имеют одинаковые элементы в массиве. Запрос connected возвращает true.

40
00:04:06,660 --> 00:04:13,096
5 и 0 имеют разные компоненты. Они 

41
00:04:13,096 --> 00:04:21,780
не соединены, мы получим false.
Если хотим

42
00:04:21,780 --> 00:04:31,617
объединить 5 и 0,
тогда как обычно соединим элемент,

43
00:04:31,617 --> 00:04:39,855
соответствующий 5 и 6, с 0.
Объединим 7 и 2.

44
00:04:39,865 --> 00:04:49,623
Делается легко. Объединение 6 и 1:
нужно изменить 3 элемента.

45
00:04:49,623 --> 00:04:57,899
Все эти 0 нужно заменить на 1.
Это была короткая демонстрация 

46
00:04:57,899 --> 00:05:04,126
быстрого поиска. Теперь посмотрим на код.

47
00:05:04,126 --> 00:05:10,628
После демонстрации несложно перейти
к программированию этого алгоритма.

48
00:05:10,628 --> 00:05:16,518
Хотя это интересное упражнение
на программирование,

49
00:05:16,518 --> 00:05:23,312
которые многие могут сделать
неверно с первой попытки.

50
00:05:23,312 --> 00:05:29,125
Есть целочисленный массив. Это наш массив ID.
Эту структуру данных

51
00:05:29,125 --> 00:05:33,953
будем использовать в нашей реализации.
Конструктор должен

52
00:05:33,953 --> 00:05:40,637
создать массив и затем задать
значение соответственно индексу i к i.

53
00:05:40,637 --> 00:05:47,200
Это просто. Операция поиска
или проверки связности тоже довольно

54
00:05:47,200 --> 00:05:53,024
простые. Это алгоритм быстрого поиска.
Он просто принимает два

55
00:05:53,024 --> 00:05:58,552
аргумента P и Q, проверяет,
равны ли их ID, и выводит

56
00:05:58,552 --> 00:06:04,077
значение. Если равны, то выводится true,
если не равны - false.

57
00:06:04,077 --> 00:06:09,942
Более сложная реализация у операции объединения.
В этом случае

58
00:06:09,942 --> 00:06:15,803
мы сперва находим ID, соответсвующий
первому аргументу, затем ID, соответсвующий

59
00:06:15,803 --> 00:06:21,018
второму аргументу.
А затем проходим весть массив в поиске

60
00:06:21,018 --> 00:06:27,068
элементов чьи ID равны ID первого аргумента
и приравниваем

61
00:06:27,068 --> 00:06:32,565
их к ID второго аргумента.
Это довольно простая реализация.

62
00:06:32,565 --> 00:06:38,156
Многие совершают ошибку, помещая сюда

63
00:06:38,156 --> 00:06:43,660
id[p] вместо того, чтобы выбрать значение.
Можете догадаться о последствиях.

64
00:06:43,660 --> 00:06:48,672
Это коварная ошибка.
Это хорошая реализация

65
00:06:48,672 --> 00:06:54,900
быстрого поиска.
Нужно выяснить, насколько эффективным

66
00:06:54,900 --> 00:07:01,152
будет этот алгоритм.
Обсудим, как это сделать.

67
00:07:01,152 --> 00:07:07,088
Важно оценить количество обращений

68
00:07:07,088 --> 00:07:12,901
к массиву в программе. В нашей реализации

69
00:07:12,901 --> 00:07:19,019
операция инициализации и объединения
включали for-цикл по всем элементам

70
00:07:19,019 --> 00:07:25,469
массива.

71
00:07:25,469 --> 00:07:32,155
Операция поиска быстрее,
она лишь проверяет

72
00:07:32,155 --> 00:07:37,829
элементы массива. Проблема в том,
что операция объединения слишком

73
00:07:37,829 --> 00:07:45,708
затратная. В частности если произвести
N операций объединения на N объектах,

74
00:07:45,708 --> 00:07:52,515
независимо от того, соединены они или нет,
то время будет расти в квадрате.

75
00:07:52,515 --> 00:07:58,458
В курсе мы снова и снова
будем сталкиваться с идеей,

76
00:07:58,458 --> 00:08:04,531
что квадратичное время слишком медленно.
Мы не можем использовать алгоритмы

77
00:08:04,531 --> 00:08:10,796
с квадратичным временем для больших задач.
Они не масштабируются. При ускорении

78
00:08:10,796 --> 00:08:16,305
работы компьютеров
квадратичные алгоритмы фактически замедляются.

79
00:08:16,305 --> 00:08:22,464
Вот что я имею ввиду: в настоящее время

80
00:08:22,464 --> 00:08:29,206
есть компьютеры, которые могут делать
миллиарды операций в секунду

81
00:08:29,206 --> 00:08:34,815
с миллиардами обращений к памяти.
Значит, можно считать

82
00:08:34,815 --> 00:08:40,916
всю память за секунду.
Удивительно, что такой стандарт

83
00:08:40,916 --> 00:08:46,907
актуален уже 50-60 лет.
Компьютеры становятся

84
00:08:46,907 --> 00:08:52,735
больше и быстрее,
чтобы доступ ко всей памяти занимал 

85
00:08:52,735 --> 00:08:57,403
несколько секунд. Это соблюдалось для компьютеров
с тысячью ячейками памяти,

86
00:08:57,403 --> 00:09:04,657
соблюдается и сейчас при миллиарде.

87
00:09:04,657 --> 00:09:11,873
Значит, с большим объемом памяти мы можем

88
00:09:11,873 --> 00:09:17,712
решить большие задачи.
Есть иметь миллиард объектов,

89
00:09:17,712 --> 00:09:23,608
над которыми мы хотим провести миллиард
операций объединения. Но такая задача с алгоритмом

90
00:09:23,608 --> 00:09:29,770
быстрого поиска
может занять 10^18 операций.

91
00:09:29,770 --> 00:09:35,098
Если посчитать, получится около 30 лет

92
00:09:35,098 --> 00:09:42,033
вычислений на компьютере.
Не практично решать такую задачу на современном

93
00:09:42,033 --> 00:09:48,057
компьютере. Причина в том,
что квадратичные алгоритмы

94
00:09:48,057 --> 00:09:54,097
не масштабируются вместе с технологиями.
На компьютере, который в 10 раз быстрее,

95
00:09:54,097 --> 00:10:00,033
можно решить задачу в 10 раз больше.
Но если это квадратичный алгоритм,

96
00:10:00,033 --> 00:10:06,028
то выйдет в 10 раз медленнее.
Таких ситуаций

97
00:10:06,028 --> 00:10:11,048
мы постараемся избежать,
разрабатывая более эффективные алгоритмы

98
00:10:11,048 --> 00:10:13,020
решения подобных задач.