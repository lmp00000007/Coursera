Посмотрим на первую реализацию
алгоритма решения проблемы динамический связности, называемую быстрым поиском.
Это так называемый немедленный алгоритм для решения такой задачи.
Структура данных, которую мы будем использовать для алгоритма, — это просто
целочисленный массив проиндексированный объектами. Будем считать, что два объекта P и Q
соединены тогда и только тогда, когда их элементы в массиве одинаковы.
В этом примере с 10 объектами массив, который описывает
ситуацию после 7 соединений представлен в центре слайда.
И так точки 0, 5 и 6 принадлежат одной компоненте,
потому что имеют одинаковое значение в массиве, 0.
У 1, 2 и 7 значение в массиве 1. А у 3, 4, 8, и 9 - значение 8.
Такое представление показывает, что они соединены. Ясно что это обеспечит
быструю реализацию операции поиска. Мы просто проверяем, равны ли
элементы массива. Проверяем имеют ли P и Q один ID. Так 6 и 1 имеют разные ID.
У 1 ID 1, а у 6 — 0. Они не в одной связной компоненте.
Объединение сложнее. Для того чтоб объединить компоненты содержащие
два данных объекта, мы должны изменить элементы массива, чьи ID равны
одному из них на другой. И произвольно мы выбираем изменить те что равны P на те что равны Q. Так если мы объединяем 6 и 1, мы должны изменить элементы 0, 5. и 6. Все из той же связной компоненты,
что и 6. От 0 до 1. И это, как мы увидим, проблема,
когда имеем дело с большим количеством объектов, потому что много значений
могут меняться. Но это легко реализуемо, и это будет нашей стартовой точкой.
Итак, начнем с демонстрации, как это работает. Изначально мы задаем
массив ID, где каждый элемент равен его индексу. Можно сказать,
что все объекты независимы. Они принадлежат собственной связной компоненте.
Перейдем к операции объединения. 4 должно быть объединено с 3.
Тогда мы должны изменить все элементы, ID которых равны ID первого, на ID второго.
Так в этом случае соединения 3 и 4 нам нужно изменить 4 на 3. Повторим несколько раз,
чтобы вы поняли как это работает. Теперь 3 и 8 должны быть соединены,
т.е . сейчас 3 и 4 должны быть соединены с 8. И оба элемента должны измениться на 8.
Ясно? А как теперь с 6 и 5? Мы снова меняем первый на второй. Для объединения 6 и 5 мы меняем, 6 на 5.
Что насчет 9 и 4? Теперь мы должны соединить 9 и 4,
мы должны изменить элемент 9 на тот же, что у 4. Получаем 3, 4, 8 и 9.
Все имеют элемент 8. То есть связаны одним элементом.
2 и 1 значит, что мы соединяем 2 и 1, изменяя 2 на 1.
8 и 9 уже соединены. Они имеют одинаковые элементы в массиве. Запрос connected возвращает true. 5 и 0 имеют разные компоненты. Они не соединены, мы получим false.
Если хотим объединить 5 и 0,
тогда как обычно соединим элемент, соответствующий 5 и 6, с 0.
Объединим 7 и 2. Делается легко. Объединение 6 и 1:
нужно изменить 3 элемента. Все эти 0 нужно заменить на 1.
Это была короткая демонстрация быстрого поиска. Теперь посмотрим на код. После демонстрации несложно перейти
к программированию этого алгоритма. Хотя это интересное упражнение
на программирование, которые многие могут сделать
неверно с первой попытки. Есть целочисленный массив. Это наш массив ID.
Эту структуру данных будем использовать в нашей реализации.
Конструктор должен создать массив и затем задать
значение соответственно индексу i к i. Это просто. Операция поиска
или проверки связности тоже довольно простые. Это алгоритм быстрого поиска.
Он просто принимает два аргумента P и Q, проверяет,
равны ли их ID, и выводит значение. Если равны, то выводится true,
если не равны - false. Более сложная реализация у операции объединения.
В этом случае мы сперва находим ID, соответсвующий
первому аргументу, затем ID, соответсвующий второму аргументу.
А затем проходим весть массив в поиске элементов чьи ID равны ID первого аргумента
и приравниваем их к ID второго аргумента.
Это довольно простая реализация. Многие совершают ошибку, помещая сюда id[p] вместо того, чтобы выбрать значение.
Можете догадаться о последствиях. Это коварная ошибка.
Это хорошая реализация быстрого поиска.
Нужно выяснить, насколько эффективным будет этот алгоритм.
Обсудим, как это сделать. Важно оценить количество обращений к массиву в программе. В нашей реализации операция инициализации и объединения
включали for-цикл по всем элементам массива. Операция поиска быстрее,
она лишь проверяет элементы массива. Проблема в том,
что операция объединения слишком затратная. В частности если произвести
N операций объединения на N объектах, независимо от того, соединены они или нет,
то время будет расти в квадрате. В курсе мы снова и снова
будем сталкиваться с идеей, что квадратичное время слишком медленно.
Мы не можем использовать алгоритмы с квадратичным временем для больших задач.
Они не масштабируются. При ускорении работы компьютеров
квадратичные алгоритмы фактически замедляются. Вот что я имею ввиду: в настоящее время есть компьютеры, которые могут делать
миллиарды операций в секунду с миллиардами обращений к памяти.
Значит, можно считать всю память за секунду.
Удивительно, что такой стандарт актуален уже 50-60 лет.
Компьютеры становятся больше и быстрее,
чтобы доступ ко всей памяти занимал несколько секунд. Это соблюдалось для компьютеров
с тысячью ячейками памяти, соблюдается и сейчас при миллиарде. Значит, с большим объемом памяти мы можем решить большие задачи.
Есть иметь миллиард объектов, над которыми мы хотим провести миллиард
операций объединения. Но такая задача с алгоритмом быстрого поиска
может занять 10^18 операций. Если посчитать, получится около 30 лет вычислений на компьютере.
Не практично решать такую задачу на современном компьютере. Причина в том,
что квадратичные алгоритмы не масштабируются вместе с технологиями.
На компьютере, который в 10 раз быстрее, можно решить задачу в 10 раз больше.
Но если это квадратичный алгоритм, то выйдет в 10 раз медленнее.
Таких ситуаций мы постараемся избежать,
разрабатывая более эффективные алгоритмы решения подобных задач.