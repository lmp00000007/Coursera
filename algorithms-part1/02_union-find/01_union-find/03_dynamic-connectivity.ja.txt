おかえりなさい。今日お話するのは、はunion find問題 いわゆる動的接続問題を解くアルゴリズムのことです。 まず、二つの古典的なアルゴリズムから始めます。Quick FIndとQuick Unionです。 適用例を紹介し、これらのアルゴリズムの改良を考えてみます。本日の講義のサブテキストは 使えるアルゴリズムを開発するためにこれから紹介する手順を繰り返し実施するということです。 最初のステップは問題のモデル化です。 基本的には解決すべき問題の主な要素がなんであるかを理解する必要があります。 すると問題を解決するアルゴリズムをいくつか発見するようになります。多くの場合、 多くの場合は最初に見つけたアルゴリズムが十分に高速で、メモリにも収まるものと思います。 その場合は、どんどん先に進み、それを使っていけばよいでしょう。しかし、他の多くの場合は、 十分な速度を得られなかったり、メモリが不足したりします。そのようなときに、私たちがやるべきことは、 原因を突き止め、問題の原因となっているものへの対処を検討し、 新しいアルゴリズムを見つけ、満足できるまでこれを繰り返すのです。これは アルゴリズムを設計、分析するときの科学的なアプローチです。そこでは、数理モデルを構築し、 何が起きているのか理解し、モデルの確からしさを検証し、 物事を改善する役に立つのです。まず最初に動的接続問題について、 次にunion-findの問題のモデルついての話をします。
さて、次のように考えてみましょう。 n個のものからなる集合があります。それらが何かは問題ではありません。 数字のゼロからnを使って、それらをモデル化します。次に 2つの間の接続について考えてみます。何かの命令が存在すると考えて、 2つをつなぐことにするのです。2つのものがあり、 それらの間に接続を考えるのです。そして、問題の重要な部分はクエリー、あるいは、 一連のクエリーを見つけることで、そのクエリを使って、2つのものの間の経路があるかどうかを答えることができるのです。 例えば、この集合は10個の要素があり、既に多くのunion命令を実行して、 4と3を、3と8を、6と5を、9と4を、 2と1を接続しています。ここで、クエリを発行し、0と7が接続されているかを問い合わせてみます。 この場合は接続はありませんので、Noを答えることになります。しかし、 8と9の接続を問い合わせられたら、Yesを答えることになります。8と9の間には直接の接続はありませんが、 8から3へ、そして4へ、次に9へという経路が存在しているのです。 そうです。これが今回の問題で、与えられた集合に対してこれら二つの命令に公式に対応することなのです。 ここで、5と0のunionを追加します。 5と0の間の接続をつくります。 7と2の間の接続を構築し、6と1の間の接続を構築します。 ここで、0と7は接続されているでしょうか？そうですね1と0もつなげることができます。これは冗長な接続ですね。 ここで0が7と接続されているかどうか質問されたら、答えは Yesとなりますね。そう、これが今回の問題で、union命令と接続のクエリを組み合わせで、 多数のものに対して、これらの命令を明確にサポートすること必要があるのです。 ここにより大きな例があります。これに対しては効率的なアルゴリズムが必要となるのはわかりますね。 まず最初に、コンピュータが必要ですね。 接続があるかどうかを人間が確かめるには、相当の時間かかります。 この場合は接続が存在します。さて、アルゴリズムは、 私たちが今日見るものですが、それは、2つのものを接続する経路を実際に与えるものではありません。 ただ、問い合わせに答えるだけです。経路があるかどうかいうね。 コースの第2部では、経路を明示的に発見するアルゴリズムを検討する予定です。 それらはunion findほどは効率的なものではありません。なぜなら、やらないといけないことが多いですから。 このアルゴリズムはいろんな種類のものに対して適用することができます。 デジタル写真に利用されたり、ここではピクセルが対象になります。ネットワークにも利用されています。 ここではコンピュータが接続の対象になりますね。人のつながりを対象としてソーシャルネットワークもそうです。また、コンピュータチップ、 回路の要素を接続する対象としています。抽象的なものにも使われます、プログラムの変数名や 数学の集合の要素などですね。複合材料の金属部位のような物理的なものにも使われます。 そのため、どんな種類のものに対しても、 プログラミングのためには、それぞれの対象に対する名前をつける必要があります。ここでは 対象を数字、0からN-1までの整数で識別することにします。プログラミングの最初の出発点としてはとても便利です。 整数を配列のインデックスとして使うことができますから、 すると、各対象に関連する情報に簡単にアクセスすることができますね。 また、union findに関係ない詳細な事項を省略することができます。 実際、対象の名前から0からN-1の整数に対するマッピングは、 シンボルテーブルや探索アルゴリズムへの応用にみることができます。 探索アルゴリズムはこのコースでも後ほど問題を解くためのアルゴリズムやデータ構造について学習する予定です。 さて、接続は満たすべき2,3の抽象的な性質があります。 みな、自然で直観的なものばかりです。 "接続されている"というのは同値関係と仮定します。つまり、 すべての対象は自分自身と接続されています。対称であるとします。
つまり、PがQと接続されているならば、QはPと接続されているということです。 また、推移的です。PとQが接続され、QとRが接続されているなら、 PとRは接続されているということです。これらの性質はとても直観的ですね。 しかし、それらを明示して、われわれのアルゴリズムがそれを満たしていることを保証するのは重要なことです。 同値関係があれば、対象と接続の集合が 接続コンポーネントという部分集合に分割することができます。
接続コンポーネントは極大集合で、 その中の対象は相互に接続されています。たとえば、ここに簡単な例を挙げましょう。 3つの接続コンポーネントがありますね。1つ目は、対象0しかありません。2つ目は 1と4と5があります。3つ目には、残りの4つの対象があります。 これらのコンポーネントはそこに含まれるどの2つの対象も接続されていて、 外側にはこれらの対象に接続されている対象がないとき、 接続されたコンポーネントであるといいます。今回のアルゴリズムは接続コンポーネントを維持して、 効率性を確保する予定であり、その知識を利用して、提示されたクエリに効率的に答えを返すことができるのです。 いいですね。では、この操作を実装するためには、クエリコマンドとunionコマンドを見つける必要があります。 また、接続コンポーネントを維持する必要があるのです。 findコマンドは2つのオブジェクトが同じコンポーネントに入っているかどうかをチェックする必要があり、 unionコマンドは2つのオブジェクトを含むコンポートをその合併、union、で置換するのです。 例えば、このようなコンポーネントで、 2と5を接続するunionコマンドが発行されたとしています。このときには必ず、 2を含む接続コンポーネントと5を含む接続コンポーネントを併合して、 1つの接続コンポーネントにします。そうして、接続コンポーネントを2つだけにします。 これで、プログラミングで必要となる、データ型をきめて、 問題を解くために実装する必要があるメソッドの仕様を考えることができるようになりました。 典型的なJavaモデルでは、まず最初に、 UFというクラスを作り、そこに2つのメソッド、1つはunionメソッドを実装し、 もう一つは、bool値を返すconnectedメソッドを実装します。コンストラクターは、SR単位をとり、 対象の数を表すものですが、対象の数を応じたデータ構造を構築します。 ここで、対数オーダーで構築するように気をつける必要があります。 対象の数が多くなることもありますし、操作の数についても同様です。 unionやconnectedのオペレーションは非常に多くなることがありますので、 このアルゴリズムは、このような状況でも効率的である必要があるのです。 このコースでよく従うプラクティスの一つが、APIの設計をチェックすることです。 問題に深く入りこむ前に、クライアントプラグラムを作って、 開発しているデータ型を使ってみるのです。今回の例では、 標準入力から情報を読み取るクライアントを作りました。最初に、整数、 これは処理すべき対象の数を表します。次に、一連の対象の名前のペアを処理します。 クライアントプログラムがやることは、まず、整数を標準入力から リードして、UFオブジェクトを生成します。次に標準入力が空になるまで、 入力から2つの整数を読み込み、次に、それらが 接続されていなければ、それらを接続し、プリントアウトします。接続されている場合は、 無視します。そうです。これがテストクライアントプログラムで、このテストクライアントで どのような実装でも期待するように動作することを確認することができるのです。これで準備はできました。 プログラムとして実装したいことはすべて説明し、 実装が機能するかどうかを確認するクライアントプログラムも作ることができます。