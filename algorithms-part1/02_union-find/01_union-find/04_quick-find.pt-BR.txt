Agora vamos olhar para a nossa primeira implementação de um algoritmo para resolver a dinâmica problema de conectividade, chamado Quick-encontrar. Este é um algoritmo de chamada ansiosos, por resolver problema atividade tipo. A estrutura de dados que vamos usar para o apoio do algoritmo é simplesmente uma matriz de inteiros indexados pelo objeto. O interpretação é os dois objetos, P e Q estão ligados se e somente se, o seu entradas na matriz são os mesmos. Assim, por exemplo, neste exemplo, com o nosso 10 objetos da matriz idéia de que descreve a situação após sete ligações é ilustrada no meio da lâmina. De modo que, depois de o, neste ponto zero, cinco, e seis são todos no mesmo componente ligado, porque eles têm a mesma entrada matriz, zero. Um, dois, e sete todos têm uma entrada. E três, quatro, oito, e nove têm entrada oito. Assim que a representação é, mostra que eles são conectado. E, claramente, que vai apoiar uma rápida implementação do achado operação. Acabamos de verificar as entradas de matriz para ver se eles são iguais. Verifique se P e Q ter a mesma identificação. Assim, seis e um ter identificações diferentes. Um deles tem um ID, seis tem ID zero. Eles não estão no mesmo componente conectado. União é mais difícil no visando a integração de componentes, contendo dois objetos dados. Temos que mudar tudo as entradas, cuja identificação é igual a uma delas para o outro. E arbitrariamente nós optar por alterar esses que são os mesmos que P para os que são mesmo Q. Então, se nós estamos indo para a união de seis e um, então temos de alterar as entradas zero, cinco, e seis. Todo mundo no mesmo componente conectado como seis. De zero a um. E esta é, como veremos, este é um pouco de um problema quando temos um grande número de objetos, porque há um monte de valores que podem mudar. Mas ainda assim, é fácil implemento, de modo que vai ser o nosso ponto de partida. Então, vamos começar com um, uma demonstração de como isso funciona. Assim, inicialmente, montamos a matriz de identificação, com cada entrada, igual a seu índice. E assim tudo o que diz é que todos os objetos são independentes. Eles são no seu próprio componente conectado. Agora, quando temos uma operação de união. Assim, digamos, quatro é suposto ser unio n com três. Então nós vamos mudar, todas as entradas, cuja identificação é igual ao ID primeiro para o segundo. Portanto, neste caso, nós vamos mudar , conecte três e quatro meios que temos de mudar os quatro a um três. E nós vamos continuar a fazer um pouco mais para que você terá uma idéia de como ele funciona. Assim, três e oito agora de modo a conectar-se três e oito agora três e quatro têm de ser ligados a oito. Assim, ambas as entradas têm de mudar para oito. Ok? Então, agora, o que dizer seis e cinco? Então, novamente, nós mudamos o primeiro a combinar a segunda. Então, para connect seis e cinco, mudamos a seis para cinco. O que cerca de nove e quatro? Então, agora temos que mudar o, para ligar nove e quatro, nós temos que mudar, a entrada de 9 para ser o mesmo que 4 a. Portanto, agora temos três, quatro, oito e nove. Todos têm entradas oito. Eles estão todos no mesmo componente conectado. Dois e um meio que connect dois e mudando a 2201. Oito e nove já estão ligados. Eles , têm as mesmas entradas na matriz idéia. Então, essa consulta conectado, que diz encontrar, verdade, eles já estão conectados. E cinco e zero têm entradas diferentes. Eles são não ligado, assim que nós return false, nesse caso, não está conectado. E então, se nós deseja se conectar cinco e zero. Depois, como de costume, vai se conectar, a entrada correspondendo a ambos cinco e seis para zero. Sete e dois, união de sete e dois. Isso é fácil. E união, seis e um para que haja três entradas que tem que começar alterado. Todos esses zeros tem que se mudou para uns. Então, isso é uma demonstração rápida de Quick-encontrar. Agora vem veremos o código para que implementating. Ok, com esta demonstração concreta em mente, então mover-se para codificação esta algorithim é bastante para a frente. Apesar de ser um exercício de programação interessante que um muitos de nós iria ficar errado da primeira vez. Então, vamos começar com o construtor, bem temos um, uma matriz inteiro privado. Essa é a nossa matriz de identificação. Essa é a estrutura de dados que vai apoiar esta implementação. O construtor tem de criar a matriz e, em seguida, passar e definir o valor correspondente a cada índice I I. Isso é para a frente. A operação de localização ou operação conectada. Isso é a uma fácil. Este é o algoritmo Quick-encontrar. Por isso, simplesmente leva seus dois argumentos, P e Q, e verifica se suas entradas de ID são iguais, e retorna valor. Se eles são iguais, ele retorna true. Se eles não são iguais, ele retorna falso. O implemento operação mais complicada é a união. E lá, encontramos primeiro o ID correspondente com o primeiro argumento, e, em seguida, o ID correspondente à o segundo argumento. E então passamos por todo o conjunto, e à procura de as entradas cujas identificações são iguais ao ID do primeiro argumento, e definir aqueles a a identificação do segundo argumento. Isso é uma implementação bastante simples. E eu mencionei que muitos de nós não nos levaria a mal. O erro que pode fazer é colocar ID de P aqui em vez de primeiro escolhendo, esse valor. E você pode pensar as implicações disso. Isso é um bug insidioso. Então, isso é uma multa implementação de QuickFind para a próxima coisa a decidir é como eficaz ou eficiente algoritmo que vai ser e vamos conversar com alguns detalhes sobre como fazer isso, mas, para isso, é suficiente apenas para pensar sobre o número de vezes que o código tem de acessar a matriz. Como vimos ao fazer a implementação, tanto o inicializado e operações sindicais envolvidos tona loop que passar por todo o matriz. Então eles têm que tocar em uma proporcional constante para n vezes depois de tocar entrada matriz. Encontre Operação é rápido, é só para um número constante de vezes verificar entradas de matriz. E o que é problemático, porque a operação de união é muito caro. Em particular, se você só tem em comandos sindicais em objetos N que é razoável. Eles estão conectados ou não, então, que vai levar tempo quadrática no tempo ao quadrado. E um dos temas que nós vamos passar por mais e mais em claro que isso é que o tempo quadrática é muito lento. E nós não podemos aceitar quadrática algoritmos de tempo para problemas de grande porte. A razão é que eles não escala. Como os computadores chegar mais rápido e maior, algoritmos quadráticos realmente ficar mais lento. Agora, vamos apenas falar sobre o que eu mais ou menos dizer com isso. Um padrão muito áspera, dizer, por agora, é que as pessoas têm computadores que podem ser executados bilhões de operações por segundo, e eles têm milhares de milhões de entradas na memória principal. Então, isso significa que você pode tocar tudo na memória principal em cerca de um segundo. Esse é um tipo de uma incrível fato de que este padrão áspero é realmente realizada por 50 ou 60 anos. Os computadores ficam maior, mas eles ficam mais rápido para tocar tudo na memória vai ter alguns segundos. Agora é verdade que os computadores só tem alguns milhares de palavras de memória e é verdade, agora que eles têm bilhões ou mais. Então, vamos aceitar isso como que os computadores são como. Agora, o que significa é que, com essa grande capacidade de memória, podemos endereço enormes problemas. Para que pudéssemos ter, bilhões de objetos, e esperamos fazer bilhões de união comanda sobre eles. E, mas o problema com que localização rápida algoritmo é que, que levaria 10 ^ 18 operações, ou, digamos axises matriz ou tocar memória. E se você fizer as contas, que funciona a 30 de alguns anos de tempo de computador. Obviamente, não prático para resolver um tal problema em hoje computador. E, ea razão é, eo problema é que os algoritmos quadráticos não escala com a tecnologia. Você pode ter um novo computador que é 10 vezes mais rápido, mas você poderia resolver um problema que é 10 vezes maior. E com uma quadrática algoritmo quando você faz isso. Vai ser dez vezes mais lenta. Esse é o tipo de situação que estamos indo para tentar evitar através do desenvolvimento de algoritmos mais eficientes para resolver problemas como este.