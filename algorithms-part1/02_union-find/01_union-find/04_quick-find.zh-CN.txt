现在我们来将用来解决
动态连通性问题算法的第一种实现 叫做快速查找 这是一种
用于求解此类问题的所谓贪心算法 我们将要用来支持这个算法的数据结构 是一个简单的对象索引整数数组 具体来说就是两个对象P与Q是连通的
当且仅当 他们在数组中的项是一样的
那么 比如这个例子中 id数组中的10个对象描述了
图中表示的七个连接操作之后的情形 所以 此时0、5、6都在同一个
连通分量中 因为他们有相同的对应的数组项 0 1、2、7对应的项都是1
而3、4、8 9对应的项都是8
所以这种表示说明他们是连通的 显然这种表示能够支持查找操作的一种快速实现 我们只需要检查数组项是否相等。检查P与Q 是否具有相同的id。所以，6和1的id不同。1的id是1，6的id 是0。它们不在相同的连通分量中。合并操作难一些 为了合并包含两个给定对象的两个分量，我们需要将所有 与给定对象之一相同id对应的项变为
另一给定对象对应的项。我们不妨 选择将与P相同的数组项变为与Q相同的数组项 那么如果我们要合并6和1
我们必须改变0、5和6等项 即每一个和6在相同连通分量的项
从0变为1 而这样实现合并操作 接下来我们会看到 
当对象数目很大时 会出现一些问题 因为会有很多值需要变
但这个算法依然容易实现 所以我们把它作为我们的出发点 那么
我们先来演示一下这个算法是如何运行的 首先 我们设置id数组的都每一项
等于它的索引 这说明所有的对象都是独立的 它们在自己的连通分量中 现在
我们进行一个合并操作 比如说 4将要和3合并 我们将 所有与第一个id项相同的项变为
第二个id的项 所以这个情形中 我们将3与4连通
意味着我们需要将4变为3 我们继续进行几个操作 
这样你就会明白它是如何运行的 那么3和8 现在 要连接3和8
那么3和4必须和8相连 所以3和4对应的项就应该变为8
对吧 然后 6和5呢 同样的 我们把第一个项变得和第二个相同 那么要连通6和5 我们就把6变成5
那么 9和4该怎么连通呢？ 要连接9和4 我们必须把9的项变成4的项 所以现在3、4、8、9对应的项都是8 他们在相同的连通分量中 
合并2和1意味着 我们将2变为1使得2和1相连
8和9已经相连了 它们在id数组中具有相同的项
所以 那个查找请求返回 “是” 表示它们已经连通了 
5和0对应的项不同 它们不连通 所以返回“否” 这种情况下 表示不连通
接下来如果要 连接5和0 和之前我们连接一样 把5和6对应的项变为0
7和2 合并7和2 这个很简单 合并6和1 
那么有三项必须变 所有的0都要变成1 这就是
关于快速查找算法的一个简短的演示 接下来我们看实现它的代码 当我们对这个具体的演示已经有概念以后
编写这个算法的代码就相当直接了 尽管这个是有意思的编程练习
但我们当中很多人第一次做仍会犯错 那么让我们从构造器开始 我们有一个私有的整数数组
那就是我们的id数组 是用来支持这个实现的数据结构 构造器创建了这个数组
并将对应索引的数组项设为索引值 显而易见 查找操作或者连通判断操作
那都是简单的操作 这就是快速查找算法
因为它只需要两个参数 P和Q 然后检查他们的id项
是否相等并返回判断值 如果它们相等 返回“真”
如果它们不相等 返回“假” 下面这个合并操作的实现更复杂一些 我们首先找到第一个参数对应的id项
然后是第二个参数对应的id项 然后我们遍寻整个数组 找到与第一个参数的id相等的id项 并把该项设为第二个参数的id项
这是一种相当直接的实现 我之前提过我们很多人或出错
我们可能犯的错误是 将p的索引值放在这里而不是首先取出它的项
你们想想这种实现 那是一个很隐秘的错误 那么 以上就是快速查找算法一种精细的实现
接下来我们要知道这个算法效率如何 我们会介绍一些关于如何做这个分析的细节 但对于这个算法我们只需要考虑
代码需要访问数组的次数就足够了 正如我们在实现的过程中所看到的 初始化和合并操作都包含了
扫描整个数组的for循环 所以它们必须以常数正比于N次访问数组 查找操作很快
只需要进行常数次查找数组项 这是有问题的 因为合并操作代价太大了 特别是如果你需要在N个对象上
进行N次合并操作 这就是不合理的 只是判断它们是否连通
就需要正比于N的平方的时间 这门课中我们会反复强调的一个主题
就是平方量级的时间太慢了 对于大型问题
我们不能接受需要平方时间的算法 原因在于它们无法成比例适应大规模问题 当计算机变得更快更大
平方时间算法实际上变得更慢 我大概解释一下我这么说是什么意思
粗略地计算一下 当今而言 我们有每秒能够进行
几十亿次操作的计算机 这些计算机的主内存中有几十亿项
这表示你可以 在大约一秒钟的时间内访问主内存所有的项
这是一个相当奇妙的事实 这个粗略的标准已经被保持了50至60年
计算机变得越来越大 但也变得更快
所以访问内存中的每一项只需要几秒钟 当计算机的内存只有几千个字的时候
这是成立的 现在计算机的内存有几十亿个字甚至更多
这依然是成立的 现在我们假设 有一台拥有了那么巨大的内存计算机 我们可以处理巨大的问题
所以我们能够拥有几十亿个对象 并且希望能对它们进行几十亿个操作
但是对于那个快速查询算法 需要10的18次方个操作 
或者说需要访问数组这么多次 或者需要访问这么多次内存
如果你计算一下 这需要30多年的计算时间 很显然在现在的计算机上
处理这样的问题是不现实的 原因就在于问题出在二次方时间算法不能成比例适用于新的技术 也许你拥有一台比现在的快10倍的
新计算机 但你可能遇到一个10倍大的问题
那么使用平方时间算法处理这个问题 花的时间就要多10倍 这就是我们 通过设计更高效的算法
来解决这样的问题努力避免的情形 通过设计更高效的算法
来解决这样的问题努力避免的情形