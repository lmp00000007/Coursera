Bem-vindo de volta aos algoritmos. Hoje, vamos falar sobre o problema Union-Find. Um conjunto de algoritmos para resolver o tão chamado problema da conectividade dinâmica. Veremos dois algoritmos clássicos. Quick Find e Quick Union e alguns aplicativos e melhorias desses algoritmos. O subtexto do curso hoje na verdade é seguir os passos que nós faremos várias e várias vezes para desenvolver um algoritmo útil. O primeiro passo consiste em modelar o problema. Tente entender, basicamente, o que são os elementos principais do problema que precisa ser resolvido. Então nós encontraremos algum algoritmo para resolver o problema. Em muitos casos, o primeiro algoritmo que elaboramos seria rápido o suficiente e talvez ele se encaixe na memória e, iremos em frente e usaremo-lo, e estará executando. Mas em muitos outros casos, talvez ele não é rápido o suficiente, ou não há memória suficiente. Então, o que fazemos é tentar descobrir a razão, encontrar uma forma de resolver o que está causando o problema, encontrar um novo algoritmo e repetir até que estejamos satisfeitos. Esta é a abordagem científica para projetar e analisar algoritmos, onde nós construímos modelos matemáticos para tentar e entender o que está acontecendo, e então fazer experimentos para validar os modelos e nos ajudar a melhorar as coisas. Então, primeiro vamos falar sobre o problema da conectividade dinâmica, o modelo do problema para Union Find. Então, aqui está a idéia. Eles vão ter um conjunto de N objetos. Não importe importa o que eles são. Nós vamos usar os números, de zero a N para modelar nossos objetos. E então, temos a idéia de uma conexão entre dois objetos. E nós postularemos que haverá um comando que diz, conecte dois objetos. Dado dois objetos, forneça uma conexão entre eles. E então parte-chave do problema é a consulta find ou a consulta connected, que apenas pergunte, há um caminho que liga os dois objetos. Assim, por exemplo, neste conjunto de 10 objetos, nós já executamos vários comandos union, conectando 4 e 3, 3 e 8, 6 e 5, 9 e 4, 2 e 1. E agora podemos ter uma consulta connected que diz, 0 está conectado com 7? Bem, neste caso, não há conexão, então nós dizemos não. Mas se perguntarmos 8 está conectado com 9? Vamos dizer que sim, mesmo que não tenhamos uma conexão direta entre 8 e 9. Há um caminho de 8 para 3 para 4 para 9. Então, esse é o nosso problema, para ser capaz de suportar estes dois comandos para determinado conjunto de objetos. Agora, vamos dizer que adicionamos uma union(5,0). Então, essa cria uma conexão entre 5 e 0. 7 e 2 cria uma conexão entre 7 e 2. E 6 e 1, entre 6 e 1. Então, agora se perguntarmos se nosso 0 está conectado com 7, bem como 1 e 0, nós podemos fazer isso também. E isso é uma conexão redundante. E agora, se nós perguntarmos se 0 está ligado a 7 nós vamos responder sim. Então esse é o nosso problema, misturar comandos union e consultas connected e precisamos ser capazes de oficialmente suportar esses comandos para um grande número de objetos. Então, aqui está um exemplo mu deito maior. E você pode ver que nós vamos precisar algoritmos eficientes para isso. Primeiro de tudo, você pode ver que nós vamos precisar de um computador para isso. Levaria muito, muito tempo para um ser humano descobrir se há uma conexão. Neste caso, há uma conexão. Agora, os algoritmos que estamos olhando hoje não vão na verdade dar o caminho conectando os dois objetos. Ele só vai ser capaz de responder à pergunta, há um caminho? Na segunda parte do curso, consideraremos algoritmos que explicitamente encontrem caminhos. Eles não são tão eficientes como union find porque eles têm mais trabalho a fazer. Agora, aplicações destes, estes algoritmos envolvem objetos de todos os tipos. Estes são usados para fotos digitais, onde os objetos são pixels. Eles são usados para redes, onde os objetos são computadores, redes sociais, onde é de pessoas, ou de chips de computador, onde os objetos são elementos do circuito ou coisas abstratas como nomes de variáveis ​​em um programa, ou elementos de um conjunto matemático, ou coisas físicas como locais metálicos de um sistema composto. Então, todos os diferentes tipos de objetos para, mas para programação vamos associar cada objeto com um nome e nós vamos nomear o objetos com um número, inteiros de zero a N-1. Esse é um ponto de partida muito conveniente para os nossos programas porque podemos usar inteiros como um índice em uma matriz então, e então acessar rapidamente as informações relevantes para cada objeto. E também só suprime um monte de detalhes que não são relevantes para ao union find. Na verdade, para fazer este mapeamento de um nome de objeto para o inteiro de 0 até N-1 é encontrar a aplicação de uma tabela de símbolos ou de um algoritmo de busca, o qual é uma das coisas que estudaremos mais adiante neste curso de algoritmos e estruturas de dados para resolver esse problema. Agora, as conexões, bem, precisamos de algumas propriedades abstratas que estas ligações devem satisfazer. E elas são todas bem naturais e intuitivas. Assim, assumimos que está ligada a uma relação de equivalência. Isto é, cada objeto conectado a si mesmo, é simétrica. Se P está ligado a Q, então Q, está ligado ao P, e é transitivo. Se P está ligado a Q, e Q está ligado a R, então P está ligado ao R. Agora, essas propriedades são muito intuitivas. Mas vale a pena afirmar-los explicitamente e assegurar-se de que nossos algoritmos os mantenham. Quando nós temos uma relação de equivalência de um conjunto de objetos e conexões dividem-se em subconjuntos chamados componentes conectados. Um componente conectado é um conjunto máximo de objetos que são mutuamente ligados. Por exemplo, neste exemplo pequeno aqui, há três componentes conectados. Um constituído de apenas o objeto 0,  o segundo objetos 1, 4 e 5. E o terceiro, os outros 4 objetos. E estes componentes têm a propriedade que, se dois objetos neles estão ligados e não existe nenhum objeto fora que está ligado a esses objetos, que são componentes conectados. Nossos algoritmos vão ganhar eficiência, mantendo conectado componentes e utilizando esse conhecimento para responder à consulta que eles apresentam. Ok, então para implementar as operações, temos de encontrar consulta eo comando sindical. E assim vamos mai ntain a conectado componentes. O find vai ter que verificar se dois objetos estão na mesma componente eo comando sindical vai ter de substituir componentes que contêm dois objetos com a sua união. Assim, por exemplo, se tivermos estes componentes, e temos o comando para a união de ligação, dois e cinco. Essencialmente, nós precisamos de mesclar contendo os componentes ligados a um contendo dois ou aquele que contém cinco para obter um grandes componentes conectados e agora temos apenas dois componentes conectados. Tudo isso leva até, em um mundo de programação para especificar um tipo de dados que é especificação simplesmente dos métodos que estamos querem vai implementar, a fim para resolver este problema. Então você sabe, Java típico do modelo, o que vamos fazer é criar uma classe chamada UF que contém dois métodos, um para implementar a união, o outro uma para implementar conectado, que retorna um booleano. O construtor, leva unidade SR, , o número de objectos, de modo que ele pode construir a estrutura de dados com base no número de objetos. Então, e nós temos que, ter em mente, como estamos construindo nossos logaritmos, que tanto o número de objetos pode ser enorme, mas também, o número de operações. Podemos ter um, um número muito grande, de união e conectados, operações e nossa algoritmos vão ter que ser eficiente, sob essas condições. Um dos as práticas que se seguirão muitas vezes neste curso é verificar nosso projeto API antes de ficar muito longe para lidar com o problema, através da construção de um cliente que é vai usar o tipo de dados que desenvolvemos. Assim, para este exemplo, nós temos um cliente que, Will ler informações a partir da entrada padrão. Em primeiro lugar, um número inteiro que é , o número de objectos que vão ser processados. E, em seguida, uma série de pares de nomes de objetos. E o que o cliente faz é, ele vai, primeiro ele vai ler o inteiro da entrada padrão, e criar um, um objeto de UF. E em seguida, enquanto a entrada padrão não é vazio, ele vai ler dois números inteiros a partir da entrada. E se eles são não conectado, então ele vai conectá-los e imprimi-los. Se eles estão ligados ele vai ignorar. Então, esse é o nosso cliente de teste e que é um cliente de teste para certificar-se bem que qualquer aplicação faz o que nós esperamos que isso acontecerá. Então, essa é a configuração. Nós descrevemos as operações que queremos implementar todo o caminho para o código e nós têm código de cliente que vamos ter que ser capaz de serviço com o nosso