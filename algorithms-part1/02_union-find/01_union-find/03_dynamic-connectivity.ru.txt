Добро пожаловать на курс алгоритмов. Сегодня мы поговорим о системе непересекающихся множеств — наборе алгоритмов для решения так называемой проблемы динамический связности. Мы рассмотрим два классических алгоритма: Quick Find и Quick Union, и их приложения и улучшения. Цель сегодняшней лекции в том, чтобы пройти шаги, которые Вы будете повторять снова и снова при разработке полезного алгоритма. Первый шаг — моделирование задачи. Попытаться понять, в общих чертах, что является основными элементами решаемой задачи. Далее, мы находим какие-нибудь алгоритмы, решающие задачу. В большинстве случаев наш первый алгоритм будет достаточно быстрым и, может быть, будет помещаться в память, так что мы будем использовать его. Но во многих других случаях наш алгоритм, возможно, не будет столь быстр или же у нас будет меньше доступной памяти. Таким образом, наша задача выяснить, почему это так, и постараться решить проблему, найдя новый алгоритм и продолжать, пока требуемый результат не будет достигнут. Это — научный подход к разработке и анализу алгоритмов, где мы строим математические модели, описывающие происходящее, а затем проводим эксперимент для проверки и улучшения наших моделей. Итак, для начала мы поговорим о задаче динамической связности, модели задачи для систем непересекающихся множеств. Идея состоит в следующем: Пусть у нас есть множество из N объектов. Неважно, каких. Мы будем использовать числа от 0 до N для моделирования наших объектов. Также у нас будет понятие связи между двумя объектами и команда, соединяющая два объекта. По двум объектам она устанавливает связь между ними. Основная часть задачи ответить на вопрос, есть ли путь, соединяющий два объекта. Например, в этом наборе из 10 объектов, уже рассмотренном нами, набор команд union, соединяющих 4 и 3, 3 и 8, 6 и 5, 9 и 4 2 и 1. И теперь у нас есть запрос связности, спрашивающий, соединены ли 0 и 7? В данном случае связи нет, так что ответ — нет. Но если мы спросим, соединены ли 8 и 9, ответом будет да, несмотря на то, что нет прямого соединения между ними. Есть путь 8 → 3 → 4 → 9 Наша задача — поддерживать эти две команды для данного набора объектов. Допустим, мы объединили 5 и 0. Теперь у нас есть связь между 5 и 0. union(7, 2) образует связь между 7 и 2. Объединим ещё 6 и 1. Теперь, если мы зададимся вопросом, соединены ли 0 и 7… Объединим ещё 1 и 0, хотя это избыточное соединение. Теперь, если мы зададимся вопросом, соединены ли 0 и 7, ответом будет да. В этом и состоит наша задача — имея перемешанные команды union и connected, уметь поддерживать их для большого количества объектов. Вот пример побольше. Как видно, для него нужен эффективный алгоритм. Во-первых, конечно же, понадобится компьютер. Человеку понадобилось бы существенное количество времени, чтобы определить есть ли здесь связь. В данном случае — есть. Алгоритмы, что мы рассмотрим сегодня, не смогут выдать нам самого пути, соединяющего два объекта, они лишь смогут сказать, есть ли путь. В части второй этого курса мы рассмотрим алгоритмы, находящие пути. Они не столь эффективны как система непересекающихся множеств, так как им приходится выполнять больше операций.