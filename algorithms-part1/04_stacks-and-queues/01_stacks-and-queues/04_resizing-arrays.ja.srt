1
00:00:01,019 --> 00:00:06,056
さて、我々の配列実装のスタックは欠点があります。

2
00:00:06,056 --> 00:00:11,610
クライアントに事前にスタックの最大容量を指定してもらう必要があります。

3
00:00:11,610 --> 00:00:17,020
それでは、この問題を解決する方法を見ていきましょう。どうやって？

4
00:00:17,020 --> 00:00:22,033
そもそも API に含まれていません。API では、スタックを作ることしか明記していませんので

5
00:00:22,033 --> 00:00:27,021
任意のサイズに増減できるべきです。ではどうやって配列を増やしたり

6
00:00:27,021 --> 00:00:31,632
減らしたりできるでしょうか？考えられそうなことは、クライアントが

7
00:00:31,632 --> 00:00:36,530
新しい要素をスタックに追加した時に配列サイズを一つ増やし、pop した時には

8
00:00:36,530 --> 00:00:41,225
配列サイズを一つ減らすことです。実装はとても簡単ですが、良い方法ではありません。なぜならば

9
00:00:41,225 --> 00:00:46,533
そのためにとても大きなコストがかかります。理由は、サイズが一つ増えた配列を新たに生成して、

10
00:00:46,533 --> 00:00:52,290
全ての要素をその配列にコピーします。となると、最初から N 個の要素を追加するには

11
00:00:52,290 --> 00:00:58,361
表記の N - 1 に相当する時間がかかりますので、N の時間がかかると言えます。

12
00:00:58,361 --> 00:01:04,148
そして都度２回の N - 1 を繰り返すので、最初から N 個の要素を追加するには

13
00:01:04,148 --> 00:01:10,953
1 から N の数列の総和、ご存知の通り N^2 / 2 の時間がかかります。

14
00:01:10,953 --> 00:01:16,623
N 個の要素をスタックに積むのに二乗時間がかかるというのは、大きな問題を扱うには受け入れられる性能ではありません。

15
00:01:16,623 --> 00:01:22,693
私たちが見てきた通り、そして何度も見る事になるでしょう。というわけでやるべきことは

16
00:01:22,693 --> 00:01:29,227
可変長とすることです。しかしどのタイミングでどのくらいの頻度で行なえばよいでしょうか？

17
00:01:29,227 --> 00:01:35,995
出来る事は repeated doubling と呼ばれる方法で、配列が一杯になった時

18
00:01:35,995 --> 00:01:43,088
新たに倍のサイズの配列を生成して、全ての要素をコピーします。

19
00:01:43,088 --> 00:01:50,773
その都度、配列を生成することはしません。というわけで、これが実装になります。

20
00:01:50,773 --> 00:01:57,049
サイズが 1 の配列から始めます。スタックが一杯になったら、すなわち

21
00:01:57,049 --> 00:02:03,038
スタックの要素数 N と実際の配列長を比較すればわかりますね、そうであれば

22
00:02:03,038 --> 00:02:09,066
要素を追加する前に、配列長を倍にリサイズします。どうやって

23
00:02:09,323 --> 00:02:16,312
新たな容量にリサイズすればよいでしょうか？新しい配列を生成したら、単に走査して

24
00:02:16,312 --> 00:02:22,803
元スタックの内容を最初の半分の領域にコピーした後、それを返します。

25
00:02:23,029 --> 00:02:30,211
以上のことで、スタック用のインスタンス変数は、新しいより大きな配列にリセットされます。

26
00:02:30,211 --> 00:02:37,570
この考え方、および結論は、 N 個の要素を配列、

27
00:02:37,570 --> 00:02:43,675
配列によるスタックに追加する場合、その時間は

28
00:02:43,675 --> 00:02:50,712
N^2 ではなく N に相当します。理由は、新たに配列を生成するタイミングは

29
00:02:50,712 --> 00:02:57,203
倍のサイズに達した時だけであり、倍になった時には、多くの要素をスタックに追加するとはいえども

30
00:02:57,203 --> 00:03:04,514
平均としては、それぞれの可変操作の際のコストに加わるだけです。

31
00:03:04,514 --> 00:03:10,977
コストを計算するならば、N 個の要素を追加する時

32
00:03:10,977 --> 00:03:16,179
1 から N の数列の総和を求めるのではなく

33
00:03:16,179 --> 00:03:21,689
2 の累乗の数列の総和を求めますので、それは

34
00:03:21,689 --> 00:03:27,284
大まかに 3N となります。まず一回の配列アクセス、そしてコピーの際の

35
00:03:27,284 --> 00:03:33,009
二回の配列アクセス。つまり要素を追加するには、おおまかに三回の配列アクセスが起こります。

36
00:03:33,009 --> 00:03:38,623
このグラフは別の視点から、push 操作時に起こる配列アクセス数を

37
00:03:38,623 --> 00:03:43,883
示しています。2 の累乗となる毎に、多くの配列アクセスが起こりますが

38
00:03:43,883 --> 00:03:48,801
ある意味、スタックに要素を積んでいく過程ですでに清算しています。

39
00:03:48,801 --> 00:03:54,871
この見方は amortized analysis と呼ばれるもので

40
00:03:54,871 --> 00:04:01,343
全処理の平均による総コストで考えます。これは分かりやすく

41
00:04:01,574 --> 00:04:07,377
有用な amortized analysis の例で、スタック実装の効率を確認できます。

42
00:04:07,377 --> 00:04:12,402
pop はどうなるでしょうか？どうやって配列を縮小するか考えなければなりません。

43
00:04:12,598 --> 00:04:17,589
一杯になった時に倍にするのだから、半分になったら、半分の目一杯で

44
00:04:17,589 --> 00:04:23,074
切り出すことを考えるかもしれません。空ばかりになった配列は不要ですからね。

45
00:04:23,074 --> 00:04:28,934
なのですが、その考えでは明らかにうまくいきません。なぜならば

46
00:04:28,934 --> 00:04:34,553
スラッシングと呼ばれる現象があります。もし push pop push pop と交互に繰り返すとして

47
00:04:34,553 --> 00:04:40,208
そのとき配列が一杯なら、倍にして、半分にして、倍にして、半分にしてと

48
00:04:40,208 --> 00:04:45,308
それぞれの操作で配列を生成しますので、その都度 N に相当する時間がかかります。

49
00:04:45,308 --> 00:04:51,069
ゆえに全体で見れば二乗時間ですので、そうはしたくありません。

50
00:04:51,268 --> 00:04:56,810
効果的な解決策は、４分の１が一杯になるまで待ってから行なう方法です。

51
00:04:56,810 --> 00:05:02,074
そして実装はとても簡単です。単に配列の４分の１が一杯になったかチェックして、

52
00:05:02,074 --> 00:05:08,091
そうであれば半分にリサイズする。すなわち、その時点では

53
00:05:08,091 --> 00:05:15,000
半分が一杯になっている状態なので、追加して拡張か、削除して縮小の、どちらも出来ます。

54
00:05:15,000 --> 00:05:21,009
半分になって再び一杯になるまでは、さらなる配列のリサイズは行なわれません。

55
00:05:21,009 --> 00:05:26,880
不変であるのは、配列は常に 25% から

56
00:05:26,880 --> 00:05:31,390
 100% の間で一杯になる点です。サイズが 1 と 2 では毎回リサイズを行ないます。

57
00:05:31,390 --> 00:05:37,887
push や pop 操作ですでにある意味で償却しています。

58
00:05:37,887 --> 00:05:44,791
このスライドでは、小さなクライアントを例にして、配列がどうなるかを確認します。

59
00:05:44,791 --> 00:05:50,139
最初のほうを見るとわかりますが、1 から 2 そして 4 で倍になりますが

60
00:05:50,139 --> 00:05:55,736
いったん 4 になると、8 になるまでそのままです。

61
00:05:55,736 --> 00:06:01,632
操作がなんであれ、そのままです。4 に縮小するのは

62
00:06:01,816 --> 00:06:07,036
要素数が二つになってからで、それから縮小したらそのままです。

63
00:06:07,036 --> 00:06:13,130
配列リサイズは頻繁に起こらず、配列でのスタックAPI を実装する

64
00:06:13,394 --> 00:06:20,500
とても効率的な方法です。クライアントはスタック最大容量を与えることもなく、

65
00:06:20,500 --> 00:06:27,707
それでいてメモリ利用量を、スタックで実際に扱う要素数の

66
00:06:27,707 --> 00:06:34,110
ほんの定数倍に常に収まることを保証されます。

67
00:06:34,110 --> 00:06:41,570
以上をふまえた解析結果として、操作毎の平均実行時間は

68
00:06:41,570 --> 00:06:48,896
操作手順が何であろうとも、平均実行時間は

69
00:06:48,896 --> 00:06:55,489
定数時間に相当します。最悪のケースは

70
00:06:55,489 --> 00:07:01,048
スタックが倍になる時で、N 相当の時間がかかります。

71
00:07:01,048 --> 00:07:07,823
よいとは言えない性能ですが、それとは引き換えに

72
00:07:07,823 --> 00:07:13,470
配列へのアクセスとインデックス増減だけの、とても高速な push と pop を実現でき

73
00:07:13,681 --> 00:07:19,851
ほとんどの処理で効率的です。多くのクライアントにとって有益なトレードオフです。

74
00:07:19,851 --> 00:07:27,065
メモリ利用量はどうでしょうか？これがスタックのメモリ利用量の解析についてです。

75
00:07:27,065 --> 00:07:35,113
文字列であればその利用量は、配列がどのくらい一杯かによって 8N と

76
00:07:35,113 --> 00:07:42,528
 32N の間で容量が確保されるので、実質それ以下になります。単に手っ取り早く

77
00:07:42,528 --> 00:07:50,452
Java で確保される配列サイズでの解析ですが。そして繰り返しますが

78
00:07:50,452 --> 00:07:57,009
この解析はスタック自身のものでクライアントが保持する文字列には関与しません。以上が

79
00:07:57,238 --> 00:08:01,906
可変長配列と連結リストのトレードオフです。二つは異なる実装であるものの

80
00:08:01,906 --> 00:08:07,771
同じ API を持ち、クライアントは相互に使い分けができます。

81
00:08:07,771 --> 00:08:13,295
どちらがより良いでしょう？あらゆる状況で、私たちは複数の API 実装を持つことになりますし、

82
00:08:13,295 --> 00:08:19,117
クライアントプログラムの特性に応じて、どちらが良いかは

83
00:08:19,117 --> 00:08:24,520
選択しなければならないでしょう。連結リストでは全ての処理は

84
00:08:24,520 --> 00:08:30,091
最悪のケースでも定数時間が保証されますが

85
00:08:30,091 --> 00:08:36,001
リンクを扱うためにやや余計な時間と容量がかかります。つまりより遅くなります。

86
00:08:36,232 --> 00:08:42,888
可変長配列の実装では、うまく時間の償却ができますので、総体的にみた平均では

87
00:08:42,888 --> 00:08:48,514
良い結果となります。容量の浪費も抑えられ、おそらく

88
00:08:48,514 --> 00:08:53,946
各処理でもより速い実装になります。いくつかのクライアントでは効果はあるでしょう。

89
00:08:53,946 --> 00:08:58,192
あるいは、可変長配列の実装を使いたいとは思わないこともあるでしょう。

90
00:08:58,192 --> 00:09:02,950
着陸のために飛行機が侵入してくる時とか

91
00:09:02,950 --> 00:09:06,929
不意にいくつかの処理がつっかかるのを避けたいとか。このような場合や

92
00:09:06,929 --> 00:09:11,403
大量のパケットが流れつづけるネットワークスイッチ等では、

93
00:09:11,403 --> 00:09:15,312
突然重くなって、いくつかのデータを失うような事は避けたいでしょう。

94
00:09:15,312 --> 00:09:19,314
というわけで、以上がトレードオフというもので

95
00:09:19,314 --> 00:09:24,109
クライアントが決定できます。私の場合なら、全ての処理で安定した速さが必要なら、

96
00:09:24,109 --> 00:09:29,595
連結リストを使います。そのような保証は不要で、単に

97
00:09:29,595 --> 00:09:34,684
全体の実行時間が気になるなら、おそらく可変長配列を使うでしょう。

98
00:09:34,892 --> 00:09:40,379
個々の処理は速いので、全体的にはより短い時間になるからです。

99
00:09:40,379 --> 00:09:49,271
このように簡単なデータ構造ですら、本当に重要なトレードオフがあり、

100
00:09:49,271 --> 00:09:56,043
実際に多くの現場で違いが出てきます。