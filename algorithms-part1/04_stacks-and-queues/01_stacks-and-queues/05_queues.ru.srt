1
00:00:02,501 --> 00:00:07,071
Далее мы кратко рассмотрим реализации
очереди с использованием

2
00:00:07,071 --> 00:00:10,182
базовых структур данных.

3
00:00:10,182 --> 00:00:14,552
Итак, вот соответствующий API
для QueueOfStrings.

4
00:00:14,552 --> 00:00:20,723
На самом деле это тот же API,
что и для стеков, различие только в именах.

5
00:00:20,723 --> 00:00:25,827
Вместо push у нас enqueue,
вместо pop у нас dequeue. Отличаются они и семантикой.

6
00:00:25,827 --> 00:00:31,593
Для enqueue() мы добавляем элемент,
 допустим, в конец очереди.

7
00:00:31,593 --> 00:00:37,089
А для dequeue() удаляем элемент из начала.

8
00:00:37,089 --> 00:00:41,122
Это как ждать в очереди,
чтобы купить билет.

9
00:00:41,122 --> 00:00:43,339
Когда вы встаёте в очередь (enqueue()),
то попадаете в конец,

10
00:00:43,339 --> 00:00:47,044
а тот, кто простоял дольше
всех, выходит из очереди.

11
00:00:47,044 --> 00:00:54,072
Посмотрим на реализацию,
сначала с помощью связного списка, затем массива.

12
00:00:54,072 --> 00:00:58,377
Итак, представление очереди
с помощью связного списка.

13
00:00:58,377 --> 00:01:02,144
Нам нужно поддерживать
два указателя, две ссылки.

14
00:01:02,144 --> 00:01:07,243
Одна для первого элемента в списке,
 а другая — для последнего.

15
00:01:07,243 --> 00:01:08,126
Когда мы производим вставку,

16
00:01:08,126 --> 00:01:12,108
то добавляем элемент
в конец списка, а не в начало.

17
00:01:12,108 --> 00:01:17,050
А когда удаляем, то убираем элемент
из начала списка.

18
00:01:17,050 --> 00:01:22,234
Вот здесь реализация метода dequeue().

19
00:01:22,234 --> 00:01:26,688
Она идентична коду метода
pop() для стека.

20
00:01:26,688 --> 00:01:32,583
Сохраняем элемент в переменную,
удаляем первый элемент путем замены ссылки на следующий

21
00:01:32,583 --> 00:01:35,677
и выводим элемент.
 Так что код идентичен.

22
00:01:35,677 --> 00:01:40,580
При добавлении нового элемента
или постановки в очередь:

23
00:01:40,580 --> 00:01:48,016
он оказывается последним в очереди.

24
00:01:48,016 --> 00:01:50,666
Для добавления его в конец

25
00:01:50,666 --> 00:01:55,555
первое что мы делаем — сохраняем
ссылку на последний элемент.

26
00:01:55,555 --> 00:02:00,264
Нам придется изменить эту ссылку 

27
00:02:00,264 --> 00:02:02,802
с null на указатель на новый узел.

28
00:02:02,802 --> 00:02:07,964
Затем мы создадим новый узел
 для размещения к конце списка,

29
00:02:07,964 --> 00:02:13,448
мы заполним его поля, и затем заменим

30
00:02:13,448 --> 00:02:19,609
ссылку с null на ссылку на новый узел.

31
00:02:19,609 --> 00:02:23,151
Всего несколько строк кода.

32
00:02:23,151 --> 00:02:28,002
Это основы работы со связными списками.

33
00:02:28,002 --> 00:02:33,779
Много лет назад большая часть
курса по алгоритмам

34
00:02:33,779 --> 00:02:38,867
и структурам данных была посвящена
подобным манипуляциям с указателями.

35
00:02:38,867 --> 00:02:45,159
Сейчас ограничиваются
несколькими реализациями:

36
00:02:45,159 --> 00:02:49,431
стек, очередь и ещё пара структур данных.

37
00:02:49,431 --> 00:02:55,701
Нам не нужны общие программы
для управления связными списками.

38
00:02:55,701 --> 00:03:00,531
Их инкапсулируют в базовые
типы данных подобного рода.

39
00:03:00,531 --> 00:03:06,089
Вернемся к нашей полной реализации.

40
00:03:06,089 --> 00:03:12,997
Здесь объединен код с предыдущих слайдов.

41
00:03:12,997 --> 00:03:19,045
Мы также учли особые случаи,
когда очередь пуста.

42
00:03:19,045 --> 00:03:23,902
Если очередь пуста
после удаления элемента,

43
00:03:23,902 --> 00:03:26,141
то устанавливаем last в null.

44
00:03:26,141 --> 00:03:30,461
Обеспечиваем, чтобы first и last были такими,
какими нужно.

45
00:03:30,461 --> 00:03:35,451
Это детали, которые легко проверить.

46
00:03:35,451 --> 00:03:36,729
Что насчет массивов?

47
00:03:36,729 --> 00:03:39,229
Опустим детали,

48
00:03:39,229 --> 00:03:44,079
но не трудно реализовать очередь
на основе изменяемых массивов.

49
00:03:44,079 --> 00:03:45,365
Это несложная,

50
00:03:45,365 --> 00:03:50,139
но каверзная задача для программиста —
попробуйте сами.

51
00:03:50,139 --> 00:03:54,584
У нас 2 указателя: первый элемент очереди

52
00:03:54,584 --> 00:03:58,800
и последний, который представляет собой
позицию для следующего.

53
00:03:58,800 --> 00:04:01,765
При enqueue() новый элемент
добавляется в конец списка,

54
00:04:01,765 --> 00:04:04,501
а при dequeue() удаляется
элемент из начала.

55
00:04:04,501 --> 00:04:08,681
Хитрость в том,
чтобы при выходе за размер массива

56
00:04:08,681 --> 00:04:11,152
переустановить указатель назад в ноль.

57
00:04:11,152 --> 00:04:14,584
Отсюда дополнительный код.

58
00:04:14,584 --> 00:04:19,264
Также нужно добавить
возможность динамического изменения размера

59
00:04:19,264 --> 00:04:23,851
для реализации структуры данных такой же,
как и для стека.

60
00:04:23,851 --> 00:04:27,498
Это задача для вас.