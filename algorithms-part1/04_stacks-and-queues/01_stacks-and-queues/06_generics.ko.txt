다음으로, 지금까지의 구현들이 문자열에만 적용된다는 또다른 근본적인 결함을 해결하기 위해 고민해봅시다. 만약 다른 데이터를 포함한 큐나
 스택이 필요하면 어떻게 해야 할까요? 이런 측면에서 JAVA의
 제네릭(generic)이란 주제를 다루게 됩니다. 기존엔 문자열 스택을 구현해 왔지만,
 응용들에서는 또다른 종류의 데이터를 다루어야 해서 정수형, URL, 자동차, 승합차(van)
 등의 스택을 다루어야 할 수 있죠. 그 대상이 어떠한 데이터든 처리해야 한다면요.
 그럼 그런 타입의 큐와 스택을 어떻게 구현할까요? 음, 처음 우리가 고려해야 하는 것을 많은 프로그래밍 환경에서 다룰 때에는 사용하는 데이터 타입 마다 스택 클래스를 따로 구현하는 겁니다. 불만족스럽지만요. 배열 리사이징 등의
 기능을 사려깊게 코드로 작성했음에도 그 코드를 복사해서 데이터 타입을 스트링 타입에서 승합차 데이터 타입 또는
 정수형 등으로 모든 곳을 고쳐야 합니다. 처리하고 있는 수백가지 다른 타입의 데이터가
 있다면 어떨까요. 우리는 수백 가지의 다른 (타입만 다른) 구현을 가져야 합니다.
 불행히도 이 문제는 JAVA의 초기에서부터 대두된 문제이며 다른 많은 프로그래밍 언어들에서도
 기본적으로 발생하는 문제입니다. 그래서 여기서 다루려는 내용은 데이터 타입만 바꾸어
 API를 따로 구현하는 불편을 피하기 위한 현대적인 접근 방법 중 하나입니다.
 사실 (이외에) 쉽게 시도할 수 있는 방법은 다른 데이터 타입으로 작성된 코드를 재사용하기 위해서
 (타입) 캐스팅을 사용하는 것입니다. JAVA의 모든 데이터 타입은 Object 클래스의 하위 타입임에 주목해서,
 Object 타입으로 스택 구현을 해둔 뒤 사용자가 그 구현을 사용할 때, 그저 대응하는 타입으로 단순히 타입 캐스팅을 하는 겁니다.
 이 방법은 제 생각엔 그리 만족스런 답이 아니므로 시간을 더 쓰고 싶지는 않습니다만, 이 예시에서는
 이름만 다른 두 개의 스택을 생각하려는데요. 하나는 오렌지(Orange) 타입을 저장하고 다른 하나는
 사과(Apple) 타입을 저장하기 위해 선언되었습니다. 이 때, 사용자는 사과(Apple) 스택 a에서 pop 연산을 할 때, 타입 체킹 시스템이
 편하도록 pop의 리턴값을 Apple 타입으로 캐스팅합니다. 이 문제는 사용자의 코드가
 이런 역할을 해주어야 한다는 점입니다. 이러한 캐스팅이 제대로 되지 않는다면, 발견하기 쉽지 않은, 
즉 서서히 프로그램을 고장내는 버그(insidious bug)가 될 겁니다. 이제부터 말할 세 번째 접근법은, 제네릭을 사용하는 겁니다. 이를 이용하면 사용자 코드가 캐스팅을 할 필요가 없습니다.
 타입 상의 불일치를 컴파일 타입에 발견할 수 있으며, 이는 앞의 방법이 런타임에서 타입 상의
 불일치가 발생하는 점과 구분됩니다. 제네릭을 이용할 때는, 클래스를 표기할 때
 타입 파라미터(type parameter)를 같이 표기해야 하는데, 이처럼 앵글 브라켓(<, >) 사이에 표기합니다.
 만약 사과 타입의 스택을 만들었을 때, 만약 사과 타입의 스택에 오렌지를 push하면
 컴파일 타임 오류가 발생합니다. 우리가 이미 그 스택을 애플만으로 구성하겠다고
 선언을 하였음을 컴파일러가 아니까요. 모듈 프로그래밍(modular programming)을 작성할 때에는 컴파일 타임 에러보다는 런타임 에러를 반기게 됩니다.
 만약 컴파일 타임에 에러를 발견하게 되면 이를 수정하면 되니까, 수정을 마친
 우리의 API 구현을 제품화하고 배포할 때, 여러분은 어떤 사용자에게 그 제품이 주어져도
 잘 동작하리라 어느 정도 확신할 수 있게 됩니다. 어떤 사용자 환경에서만 발생하는 런타임 에러의의 경우
 실행을 해볼 때까지 발견되지 않으므로 수 년이 지난 뒤에, 모든 사람들에게 소프트웨어를
 다시 배포해야 할 수 있으며 이는 매우 끔찍하게 어려운 일입니다. 자, 사실 (JAVA처럼) 좋은 제네릭 구현을 가지고 있다면,
 우리가 String 클래스를 활용해 구현한 Stack 구현에서 String 타입을 제네릭 타입으로 변경하는 작업은
 여기에 있듯 어렵지 않습니다. 좌측에는 String을 쓴 리스트 기반 스택 구현이있고요. 오른쪽에는 이를 수정해 제네릭을 쓰는
 리스트 기반 스택 구현입니다. 좌측에서 String 타입이 쓰인 모든 부분이 우측에서는 Item이라는 단어로 바뀌었음을 볼 수 있고,
 맨 위에 클래스 선언에서 Item이 우리가 쓰려는 제네릭 타입의 이름임을
 앵글 브라켓 안에서 살펴볼 수 있습니다. 이 구현은 더 이상 쉬울 수 없을 정도로 아주 명확하고, 한 구현을 통해 여러 종류의 데이터 타입을
 다루는 문제를 멋지게 풀어냅니다. 배열을 이용하는 구현의 경우엔, 앞과 같은 방법이
 모든 프로그래밍 언어에서 통용되진 않습니다. 요즈음의 많은 프로그래밍 언어가 배열과
 제네릭을 결합하는 문제에 어려움이 있으며, 특히 JAVA에서 문제가 됩니다. 예를 들어, 앞의 변환 방법을 적용하면 단순히 흰 색으로 강조된 라인에 String 대신 제네릭 명칭인
 Item으로 바꾸어서 새로운 배열을 선언하면 될 것 같습니다. 하지만 문제는, JAVA는 제네릭 타입의 배열 생성을 허용하지 않습니다. 이렇게 하는 이유는 매우 다양한 기술적 이유들이 존재하고,
 웹에서 다양한 논쟁을 살펴볼 수 있을 겁니다. 이러한 논쟁은 우리의 논의 범위를 넘어가고요.
 따라서 우리가 해야 할 것은 프로그램이 동작할 수 있도록 캐스팅을 하는 겁니다.
 즉, Object 클래스의 배열을 만든 뒤 Item의 배열로 이를 캐스팅을 하는 것입니다.
 제 관점에선 좋은 코드는 캐스팅이 없어야 하고, 캐스팅을 하는 건 우리 코드에 어떤 약점을 만드는 일과
 같기 때문에 최대한 캐스팅을 피하고 싶은 겁니다만, 이 경우에는 어쩔 수 없이 한 번의 캐스팅을 해야 합니다. 때문에 이 구현은 보기 싫은 캐스팅이라는 평가를 들을 수 밖에 없습니다. 이 코드에 기분이 좋을 수 없지요.
 이러한 것이 불필요한 기능이라고, 견딜 수 없어할 수 있는데 저는 코드는 이처럼 간결한 게 좋다고 봅니다. 다만 불행히도, 우리가 모든 걸 좋게 만들 수는 없고, 이 강의에서는 이런 보기 싫은 캐스팅을 알아야 되는 상황이라는 겁니다.
 이제, 이 코드를 컴파일하면 JAVA로부터 경고(Warning) 메시지를 받게 될 겁니다.
 이는 컴파일러가 체크하지 않았거나 안전하지 않은 연산을 했음을 알려줍니다. 따라서 이 프로그램을 -Xlint:unchecked라는 옵션을 주어 재컴파일 해서
 정확히 무엇이 체크되지 않았는지를 확인해야 합니다. 여기서 실제 재컴파일한 결과를 살펴보면, 체크되지 않은 캐스트가 코드에 있으며, 체크되지 않은 캐스트를 코드에 삽입하지 않는 게 필요함을 경고했음을 알려줍니다.
 이 정도 경고는 괜찮지만 이와 같은 코드를 컴파일 할 때에는 계속 보게 될 겁니다.
 제 생각엔 컴파일러 개발자들이 이 경고 문구에 "이런 결과를 초래해서 죄송합니다"를 추가해야 할 것 같아요. 이런 결과가 나온 건 우리가 잘못 짠 것이 아니라
 제네릭 타입을 지원하면서 제네릭 배열의 선언을 허용하지 않는 JAVA의 요구사항 때문이니까요. 덧붙이자면 지금까지의 관점을 여러분이 따른다면, 이런 경고 메시지를 보더라도
 여러분의 코드에 문제가 있다고 생각할 필요는 없습니다. 이제, 다른 JAVA에 관한 문제를 살펴볼건데요. 제네릭에서 원시 타입(premitive type)은 어떻게 쓰느냐입니다. 우리가 쓴 제네릭 타입은 객체에 관한 것이어고,
 객체의 배열을 캐스팅했던 것이죠. 만약 제네릭 타입에 원시 타입을 쓰고 싶다면,
 JAVA가 지원하는 Wrapper 객체 타입을 쓰면 됩니다. 예를 들어 int 원시 타입은 시작이 대문자인
 Integer Wrapper 타입을 쓰면 되겠죠. 여러분들은 아마 이런 것에 익숙하리라 보는데,
 이를 Auto-boxing이라고 부릅니다. 제네릭 처음에만 명확하게 Wrapper 타입을 써주면,
 원시 타입과 그 래퍼 간에 자동적으로 캐스팅이 일어나거든요. 즉, 원시 타입을 다루는 문제는 장막의
 뒷편에서 처리되는 문제의 일종입니다. 이제 정리하면, 지금까지 어느 데이터 타입에도
 잘 동작하는 제네릭 기반의 스택 API를 다루었다는 거고요. 그 스택 API의 두 가지 구현,
 즉 리스트 기반과 배열 기반 구현을 다루었는데 각 구현은 어느 데이터 타입에서도 잘 동작하고, 배열 리사이징이나 리스트 링크를 하는 데 문제가 없다는 것입니다.