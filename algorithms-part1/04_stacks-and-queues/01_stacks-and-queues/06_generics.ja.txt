次に、実装時の別の根本問題に目を向けてみましょう。 これまでの実装は、文字列のみに絞って考慮してきました。 他のデータ型のキューやスタックが必要な時はどうなるでしょうか？ ここでジェネリクスの出番です。ではいきましょう。 文字列のスタックは実装しましたが、アプリケーションではあらゆるデータ型を扱いますし、 Int や  URL や Car や Van など扱うデータに関わらず、スタック等を実装したいわけです。 ではそのような型のスタックやキューを実装するには どうするでしょうか？最初に思いつきそうなことは、 まあ実のところ多くのプログラミング環境ではそう考えてしまうのですが、 利用するデータ型毎にスタックのクラスを分けることです。 なんとなく厳しそうですね。配列リサイズ等のコードを注意深く書いて、 コードをコピーして、データ型を文字列から Van や Int へ、全ての箇所にわたって書き換えるわけです。何百もの 異なるデータ型を扱う時はどうなるでしょう？何百もの異なる実装が必要ですね。 不運にも、初期の Java では我々はこの問題に悩まされ、 多くのプログラミング言語でも基本的には同じです。 というわけで、これから見ていくモダンな手法により データ型ごとに複数の実装を持つことを避けます。手っ取り早い方法として、 異なるデータ型に対しては、型キャストを用いてコードを再利用する方法が広く使われています。 Java では全ては Object 型のサブクラスですので、Object 型で実装します。 クライアントがそれを使う時点で、単に対応する型に キャストするだけです。私はこんな事には時間を割きたくないですね。 いまいちの解決策だと思います。この例では、二つの型を スタックに積んでいます。一つは Apple 型で、もう一つは Orange 型です。 Apple のスタックから pop で取り出したら、クライアント次第で Apple 型にキャストして、 型チェックが働くように保ちます。ここでの問題は、クライアント側のコードが 型キャストの責務を負うので、それがうまくいかない場合にバグとなる危険が潜んでいます。 三度目の試みでは、ジェネリクスについてお話しましょう。 この場合、クライアントはキャストすることはありません。型が合っていなれば 実行時ではなくコンパイル時に間違いを見つけることができます。この場合は ジェネリクスを使っていて、型パラメータをクラス名に含めています。 このコードのブラケット内ですね。それで、 [cough] もし Apple 型のスタックがあって Orange 型の要素を Apple 型のスタックに追加しようとすれば、 コンパイルエラーになります。スタックは Apple 型であると宣言されていたからです。 良質のモジュラープログラミングの指針は コンパイルエラーを活用し、実行時エラーは避けることにあります。なぜならば コンパイル時にエラーが検出できるならば、製品として出荷したり API 実装を公開したりと、あらゆるクライアントで動作する事に自信が持てます。 一方で、エラーが実行時にならないと検出できないなら ソフトウェアを公開した後の数年後に、クライアント側での開発時にエラーが起こるかもしれませんし、 誰にとっても極めて困難でしょう。いいでしょう。そして実際のところ 良いジェネリック実装とはいっても難しいものではありません。単に [cough] String としていた箇所を、全てジェネリック型名に置き換えます。ここにあるコードのように。 左側が連結リストを使った String 型のスタック実装です。右側が ジェネリック実装ですね。左側で String 型を使っている全ての箇所で、 右側では Item を使っています。先頭のクラス宣言では ブラケット内の Item をジェネリック型として利用することを宣言しています。 実装はこれ以上ないくらい簡潔で 一つの実装で複数の型を扱う問題を解決するのに優れた方法です。 配列の場合は、完全にはできません。全てのプログラミング言語、 というか今日では多くのプログラミング言語がこの課題を抱えていて、 Java は特に顕著です。やれたらよい事は、単に配列生成の箇所を ハイライトされた行にあるように、ジェネリック名にすることです。さもなければ 同じ事です。不運にも Java では、ジェネリック型の配列生成は許可されていません。 さまざまな技術的な理由によるもので、関連する広範囲な議論をウェブ上で読めますが それはそれとしておきましょう。今必要なのは動かすことで、それにはキャストを使います。 すなわち、いったんオブジェクト型の配列を生成してからキャストします。 私の判断では、良いコードには型キャストはありません。ですので 可能な限りキャストは避けたいわけです。何かよろしくない事をやっていますよと 宣言しているわけですからね。ですが、この場合は、この唯一のキャストを含めなければいけません。 ご存知の通り、見苦しいキャストです。コードを見ていい気はしませんね。 こうすることは、あなた自身の思いつきではなく、 望ましくない仕様なのだと、このコードについては、私は割り切って考えます。 幸いにも、本コースで色々な事をやっていく中で、 この唯一の見苦しいキャストについて知っておけば十分です。というわけで、 このプログラムをコンパイルすると、Java の警告が出ます。 unchecked or unsafe operations と警告しています。-Xlint オプションを付けて コンパイルしなおして unchecked の詳細を見てみます。すると、コード内に 未チェックのキャストがあると警告が出ます。 未チェックのキャストはすべきでないということです。まあ、それで構いません。 このようなコードをコンパイルすると目にすることになります。私が思うには 彼らはこの警告に「こんなことをさせて申し訳ない」と付け加えていたかもしれませんね。 私たちの誤りではなくて、そうせざるを得なかったのは ジェネリック型の配列を宣言できないためですから。そういうわけで、 あなたのコードに問題があるとは思わないでください。我々の規範に沿って この警告文が出たとしても。いいでしょう、それでは Java に関する詳細になりますが、 プリミティブ型ではどうでしょうか？ [cough] ジェネリック型は オブジェクトに対してのものなので、Object 型の配列からキャストします。 すなわちジェネリック型を扱うには、Object 型のラッパーを使う必要があります。 大文字で始める表記の Integer は int 型をラップします。多くの方々が おそらく馴染みがありますね。そして、オートボクシングと呼ばれる、 自動的にプリミティブ型とラッパーを変換する仕組みがあり、 言うならば見えないところで、プリミティブ型を扱う問題を調整してくれます。 結果的に、ジェネリック型のスタックによる API であらゆる型が使えると言えます。 そして連結リストと配列による二つの実装があり、 それらは [cough] あらゆるデータ型に対して、これまでに説明してきたリサイズや 連結リストを使って、とてもうまく動作します。