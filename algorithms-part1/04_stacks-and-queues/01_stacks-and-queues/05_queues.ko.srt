1
00:00:02,501 --> 00:00:07,071
그러면, 이제 간단히 같은 기본적인 기저 자료구조를 활용한

2
00:00:07,071 --> 00:00:10,182
큐 구현을 살펴보도록 합시다.

3
00:00:10,182 --> 00:00:14,552
StackOfStrings와 대응되는 QueueOfStrings라는 API가 있는데요.

4
00:00:14,552 --> 00:00:20,723
스택과 똑같은 API를 제공합니다만, 연산의 이름이 다릅니다.

5
00:00:20,723 --> 00:00:25,827
push 대신 enqueue를, pop 대신 dequeue를 쓰고 있죠.

6
00:00:25,827 --> 00:00:31,593
그 의미(sementics)도 다른데,
 enqueue는 큐 끝에 아이템을 넣는 것이고요.

7
00:00:31,593 --> 00:00:37,089
dequeue는 큐 시작에서 아이템을 제거하는 겁니다.

8
00:00:37,089 --> 00:00:41,122
실생활의 유사 사례를 들어보면, 티켓을 사기 위해 줄서있는 상황인데,

9
00:00:41,122 --> 00:00:43,339
enqueue를 하면 여러분이 줄 끝에 서는 거죠.

10
00:00:43,339 --> 00:00:47,044
반면 dequeue의 대상은
 그 줄에서 가장 오래 기다렸던 사람인 거고요.

11
00:00:47,044 --> 00:00:54,072
이를 어떻게 구현할 지를 처음엔
 연결 리스트로 다음엔 배열으로 살펴봅시다.

12
00:00:54,072 --> 00:00:58,377
먼저 연결 리스트 기반의 큐 표현을 살펴볼건데요.

13
00:00:58,377 --> 00:01:02,144
두 개의 포인터, 즉 참조를 유지합니다.

14
00:01:02,144 --> 00:01:07,243
하나느 리스트의 첫 아이템을, 다른 하나는
 리스트의 마지막 아이템을 가리킵니다.

15
00:01:07,243 --> 00:01:08,126
아이템을 삽입하면,

16
00:01:08,126 --> 00:01:12,108
리스트의 시작점이 아니라
 리스트의 끝에 아이템을 삽입하고요.

17
00:01:12,108 --> 00:01:17,050
제거를 할 때는, 기존과 똑같이 시작점에서 제거를 합니다.

18
00:01:17,050 --> 00:01:22,234
여기에 dequeue의 구현이 있습니다.

19
00:01:22,234 --> 00:01:26,688
스택에서의 pop과 코드가 동일합니다.

20
00:01:26,688 --> 00:01:32,583
아이템을 떼어서 저장해두고,
 참조를 진전시켜 first가 가리키던 노드를 삭제하고,

21
00:01:32,583 --> 00:01:35,677
그 뒤에 아이템을 리턴합니다. 그러니 똑같죠.

22
00:01:35,677 --> 00:01:40,580
노드를 삽입하려면, 즉 enqueue하려면,
 즉 연결 리스트에 새 노드를 삽입하는 걸 말하는 건데

23
00:01:40,580 --> 00:01:48,016
리스트의 끝에 넣어야 할테고,
 따라서 참조 last가 마지막에 갱신되어야 합니다.

24
00:01:48,016 --> 00:01:50,666
따라서 마지막에 아이템을 넣기 위해서는

25
00:01:50,666 --> 00:01:55,555
처음 해야 할 것은 마지막 노드의
 참조를 oldlast에 저장하는 겁니다.

26
00:01:55,555 --> 00:02:00,264
oldlast를 저장해야 하는 이유는, 기존 마지막 노드의 next 변수,

27
00:02:00,264 --> 00:02:02,802
즉 null 상태로 되어 있을 참조가
 새 노드를 가리키게 해야 하기 때문입니다.

28
00:02:02,802 --> 00:02:07,964
그럼 이제 연결 리스트 끝에 새 노드를 만듭시다.

29
00:02:07,964 --> 00:02:13,448
새 마지막 노드에 아이템을 삽입하고
 참조 next를 null로 초기화를 했다면

30
00:02:13,448 --> 00:02:19,609
기존 마지막 노드 oldlast의 참조 next가
 새 노드를 가리키도록 변경합니다.

31
00:02:19,609 --> 00:02:23,151
다시 말해, 몇 줄의 코드이지만

32
00:02:23,151 --> 00:02:28,002
이것이 기본적인 연결 리스트 처리 과정입니다.

33
00:02:28,002 --> 00:02:33,779
사실 몇 년 전에 (C언어 등을 사용하는)
 알고리즘과 자료구조를 가르칠 때에는

34
00:02:33,779 --> 00:02:38,867
많은 강의들이 이런 포인터의 교묘한 처리에 집중했었습니다.

35
00:02:38,867 --> 00:02:45,159
하지만 요즘은 스택과 큐 같은 몇몇 구현이나 기본 자료 구조에서만

36
00:02:45,159 --> 00:02:49,431
사용되고 있습니다.

37
00:02:49,431 --> 00:02:55,701
이 수업에서는 연결 리스트를 취급하는
 더 일반적인 프로그램을 그리 다루진 않을 겁니다.

38
00:02:55,701 --> 00:03:00,531
지금처럼 기본 데이터 타입이
 연결 리스트를 취급하는 캡슐화를 할 겁니다.

39
00:03:00,531 --> 00:03:06,089
좋습니다. 이제 전체 구현으로 가서

40
00:03:06,089 --> 00:03:12,997
기존 슬라이드의 코드를 살펴모아 봅시다.

41
00:03:12,997 --> 00:03:19,045
큐가 비어있는 특별한 경우를 고려해야 하기도 하고요.

42
00:03:19,045 --> 00:03:23,902
dequeue를 한 뒤에 큐가 비어있다면, 이를 명확하게
 하기 위해 last를 null로 설정해야 합니다.

43
00:03:23,902 --> 00:03:26,141
그래서 last를 null로 설정했고요.

44
00:03:26,141 --> 00:03:30,461
first와 last가 우리가 기대하는
 바대로 동작하도록 하기 위함이죠.

45
00:03:30,461 --> 00:03:35,451
상세는 여러분 스스로 체크하실 수 있을 겁니다.

46
00:03:35,451 --> 00:03:36,729
배열은 어떨까요?

47
00:03:36,729 --> 00:03:39,229
상세는 다루지 않겠습니다만,

48
00:03:39,229 --> 00:03:44,079
배열 리사이징을 이용한 큐를
 만드는 게 그리 어렵진 않을 겁니다.

49
00:03:44,079 --> 00:03:45,365
어렵지 않아요.

50
00:03:45,365 --> 00:03:50,139
하지만 여러분들이 해볼 만한,
 까다로운 프로그래밍 연습문제임은 분명합니다.

51
00:03:50,139 --> 00:03:54,584
두 포인터 (인덱스), 즉 큐의 처음 아이템을 가리키는 head와

52
00:03:54,584 --> 00:03:58,800
다음 아이템이 들어갈 장소를 가리키는 tail을 유지해야 합니다.

53
00:03:58,800 --> 00:04:01,765
enqueue 연산에서는 tail에 새 아이템을 삽입합니다.

54
00:04:01,765 --> 00:04:04,501
dequeue 연산에서는 head가 가리키는 아이템을 삭제합니다.

55
00:04:04,501 --> 00:04:08,681
까다로운 부분은 연산 과정에서
 인덱스가 배열의 용량을 넘어섰을 때

56
00:04:08,681 --> 00:04:11,152
인덱스가 0으로 초기화되어야 한다는 점입니다.

57
00:04:11,152 --> 00:04:14,584
약간의 추가 코드가 필요한데요.

58
00:04:14,584 --> 00:04:19,264
스택과 같은 자료구조로 구현하기 위해서

59
00:04:19,264 --> 00:04:23,851
배열 리사이징을 추가할 수도 있을 겁니다.

60
00:04:23,851 --> 00:04:27,498
이런 부분은 연습문제로 남겨두겠습니다.