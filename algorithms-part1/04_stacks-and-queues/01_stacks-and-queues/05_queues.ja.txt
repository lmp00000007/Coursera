では次は、キューの実装を手短に考えてみましょう。同じように 基本的なデータ構造です。これが文字列のキューに対応する API です。 スタックの API と同じようなものですが、命名が異なっています。 push の代わりに enqueue、pop の代わりに dequeue を用います。 意味も異なります。enqueue ではキューの終端に要素を追加することを指し、 dequeue は先頭から要素を削除します。チケットを買うために列に並んでるような感じです。 enqueue 時点で、列の一番最後にいます。そこにいるときは 出るまでに一番長く待つ人なわけですね。では、どうやって実装するか、まず連結リストを使った場合、 それから配列の場合で見てみましょう。これが連結リストを使ったキューの図です。 二つのポインタを保持することが必要です。一つはリスト内先頭要素を指し、 もう一つは終端の要素を指します。挿入する時は リストの先頭ではなく終端に要素を追加して、削除する時は これまでと同じで、先頭を取り出します。これが dequeue の実装です。 スタックの pop のコードと違いはありません。要素を退避して、 先頭ノードの参照を進めつつ元を削除して、要素を返す。全く同じです。 ノードを加える enqueue、新しいノードを連結リストに加える際は、 終端に加えれば一番最後の返り値になります。終端に加えるためには、 まず始めに終端のリンクを退避しておきます。そうしておくのは リンク先の参照を NULL から 新しいノードに変更する必要があるためです。 それからリスト終端の新しいノードを生成してフィールドを埋めて、 それから元の終端リンクの次参照を NULL から新しいノードに置き換えます。 以上が基本的な連結リストの処理です。 何年か前にアルゴリズムとデータ構造のコースを教えていた時は、このような類いの ポインタ操作を扱うコースが多くありましたが、今となっては スタックやキュー、その他基本的なデータ構造の実装に限られています。 連結リストを扱うのに苦心してプログラムする必要はありません。 このように基本データ型にカプセル化します。いいでしょう、では全実装に話を戻しましょう。 これは前のスライドの断片をかき集めたものですが、 合わせて、キューが空の場合について注意して確認してください。 要素を削除した後でキューが空なら、last は NULL にします。 first と last の両方とも、我々が得たいものに常に保つことを確認してください。 簡単ではありますが詳細は以上です。いいでしょう。では配列ではどうでしょうか？ 詳細に取りかかりたいところですが、可変長配列でのキューの実装は さして難しいものではありません。難しくはないですが、プログラミング演習として やってみてください。まず、二つのポインタを扱います。 キュー内の先頭要素と終端は次に来る要素を格納する位置です。 enqueue では、tail の位置に新しい要素を追加して、dequeue では、head の要素を削除します。 そして、容量を超える場合にトリックが必要です。ゼロに戻す必要があり、 まあ、ちょっとした追加のコードですが。それから容量を拡張する必要があります。 スタックのようなデータ構造を実装する場合と同じですね。 以上で、後は各自の練習問題としてとっておきましょう。