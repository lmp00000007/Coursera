1
00:00:01,062 --> 00:00:07,022
前面了一些基本数据结构和实现，看起来

2
00:00:07,022 --> 00:00:13,011
相当基础和简单，但马上我们就要涉及这些基本概念

3
00:00:13,011 --> 00:00:18,085
的一些非常复杂的应用，下面我们来讲这个

4
00:00:18,085 --> 00:00:27,076
首先要提到的是我们实现的数据类型和数据结构

5
00:00:27,076 --> 00:00:33,668
往往能在Java库中找到，很多编程环境都是如此

6
00:00:33,898 --> 00:00:40,698
比如在Java库中就能找到栈和队列这样的字眼

7
00:00:40,698 --> 00:00:46,728
Java集合库中所谓的List接口如这里所示

8
00:00:46,926 --> 00:00:53,203
Java对于元素序列有一个通用API

9
00:00:53,203 --> 00:01:00,099
包含从表尾添加，从表头移除之类的方法

10
00:01:00,099 --> 00:01:07,611
而且它的实现使用的是可变大小数组。我们考虑的很多原则

11
00:01:07,867 --> 00:01:15,075
LinkedList接口一样考虑了。
所以，为什么不直接用那些接口呢？为什么要用我们自己的

12
00:01:15,075 --> 00:01:22,901
实现呢？问题在于这样的库一般是

13
00:01:22,901 --> 00:01:32,367
开发组（committee phenomenon）设计的
加入了越来越多的操作

14
00:01:32,367 --> 00:01:39,679
API变得过宽和臃肿。在API中拥有非常多的操作并不好

15
00:01:39,679 --> 00:01:47,019
我们马上就会见到一个例子

16
00:01:47,019 --> 00:01:53,427
真正的问题在于你关于库代码的性能知之甚少

17
00:01:53,427 --> 00:02:01,347
或者不能对其性能很好地估计。你可能

18
00:02:01,347 --> 00:02:06,949
很快就遇到性能瓶颈，即使是很简单的客户端

19
00:02:06,949 --> 00:02:12,918
我们推荐因为我们只需要使用这么几个基本数据结构

20
00:02:12,918 --> 00:02:18,467
这些数据结构都很简单，应该直接用我们前面针对这些基础

21
00:02:18,467 --> 00:02:24,233
数据结构讲过的实现。等成为有经验的程序员以后

22
00:02:24,813 --> 00:02:30,745
知道自己在做什么了，可以高效地使用一些集合库

23
00:02:30,745 --> 00:02:36,767
但是经验不足的程序员使用库经常会遇到问题

24
00:02:36,767 --> 00:02:43,793
这是不久前学生编程作业中的“血的教训”

25
00:02:43,793 --> 00:02:50,211
我们有个作业需要你在渗滤系统中生成随机开域

26
00:02:50,211 --> 00:02:55,969
有个学生认真听讲

27
00:02:55,969 --> 00:03:01,677
使用数组实现，可以随机选取数组中的索引

28
00:03:01,863 --> 00:03:07,737
检查是否为开域，如此反复。数组是N×N的

29
00:03:07,737 --> 00:03:13,955
包含N^2个元素，需要大约N^2时间，对于这个应用实际上是

30
00:03:13,955 --> 00:03:20,113
线性时间。而另一个学生之前学过一些Java

31
00:03:20,113 --> 00:03:25,247
觉得自己是个专家，擅自决定用LinkedList

32
00:03:25,437 --> 00:03:31,615
因为觉得自己会用Java库，不想费工夫下载我们的代码

33
00:03:31,615 --> 00:03:38,121
就用了Java库，然后随机选取索引并删除

34
00:03:38,345 --> 00:03:44,094
这个程序需要平方时间。当倒霉的Kenny试着在我们要求的

35
00:03:44,094 --> 00:03:50,806
巨大实例上运行他的程序的时候，他发现程序一直跑不停

36
00:03:50,806 --> 00:03:59,050
原因在于Java中LinkedList实现访问给定索引的元素需要

37
00:03:59,050 --> 00:04:06,456
线性时间，而不是数组中的常数时间。对于Kenny

38
00:04:06,456 --> 00:04:12,800
这难以置信，他很难从实现中得出

39
00:04:12,800 --> 00:04:19,055
程序太慢的信息。用这样包含了那么多操作的

40
00:04:19,055 --> 00:04:25,623
像瑞士军刀一样的实现，很难知道你的客户端需要的

41
00:04:25,623 --> 00:04:30,682
那组操作是否是高效实现的

42
00:04:30,953 --> 00:04:38,444
我们这门课坚持的原则是我们在课上实现之前学生们

43
00:04:38,444 --> 00:04:44,551
不应该使用库，至少得能表明你理解性能指标

44
00:04:44,551 --> 00:04:50,546
下面，我们看一些栈的应用

45
00:04:50,546 --> 00:04:56,976
栈确实非常基础，很多计算基于它运行

46
00:04:56,976 --> 00:05:03,716
因为它能实现递归，所以你每天都经常使用栈

47
00:05:03,716 --> 00:05:09,860
当你使用网页浏览器上的后退按钮是，你去过的网页

48
00:05:09,860 --> 00:05:16,496
存储在栈上。马上还有两个例子，第一个

49
00:05:16,496 --> 00:05:22,377
是要处理编译一种编程语言或者解释为实际的计算

50
00:05:22,377 --> 00:05:28,544
另一个是广泛用于印刷和出版的

51
00:05:28,544 --> 00:05:35,249
PostScript语言。编译器实现函数的方式

52
00:05:35,249 --> 00:05:41,524
是使用栈。当有函数被调用时，整个局部环境和

53
00:05:41,524 --> 00:05:48,198
返回地址入栈，之后函数返回时

54
00:05:48,198 --> 00:05:53,623
返回地址和环境变量出栈

55
00:05:53,623 --> 00:05:58,917
有个栈包含全部的信息，无论函数调用的是否是它本身

56
00:05:58,917 --> 00:06:04,119
这都无关。栈就包含了递归。实际上，你总能

57
00:06:04,119 --> 00:06:09,929
显式地使用栈将递归程序非递归化。这是一个叫做gcd函数

58
00:06:09,929 --> 00:06:16,011
计算最大公约数，p与q的最大公约数

59
00:06:16,011 --> 00:06:23,402
就是q与p mod q的最大公约数

60
00:06:23,402 --> 00:06:30,425
这个函数反复调用自己直到q变成0。如图所示

61
00:06:30,425 --> 00:06:37,849
信息被保存在栈上。下面这个例子充分展示了栈的作用

62
00:06:38,087 --> 00:06:47,568
同时演示了相同的代码能够处理

63
00:06:47,568 --> 00:06:53,472
多种类型数据，例子是Dijkstra

64
00:06:53,472 --> 00:06:58,576
双栈算术表达式求值算法。目标是

65
00:06:58,576 --> 00:07:03,601
给定算术表达式，这个就像简单的程序中的中缀表达式

66
00:07:03,601 --> 00:07:08,398
这个一会再说，就叫算术表达式吧

67
00:07:08,398 --> 00:07:13,936
有操作数和操作符，你想要对这个表达式求值

68
00:07:13,936 --> 00:07:19,897
Dijkstra的算法说出来很简单。从左至右处理表达式

69
00:07:19,897 --> 00:07:25,485
维护两个栈

70
00:07:25,485 --> 00:07:31,232
如果见到数值，放在数值栈上，如果见到

71
00:07:31,232 --> 00:07:37,117
操作符，放到操作符栈上。遇到左括号略过

72
00:07:37,117 --> 00:07:43,584
遇到右括号，出栈操作符和两个数值，将运算结果入栈

73
00:07:43,584 --> 00:07:51,334
说了一堆我们来看演示。一开始数值栈和操作符栈都是空的

74
00:07:51,334 --> 00:07:57,476
然后我们准备从左到右处理。上面是

75
00:07:57,703 --> 00:08:04,319
归纳的我们会遇到的四类情况以及相应的处理

76
00:08:04,319 --> 00:08:09,608
忽略左括号，一个数值，放在数值栈上

77
00:08:09,608 --> 00:08:14,985
所以 1 直接放在数值栈上。操作符，我们放在操作符栈上

78
00:08:14,985 --> 00:08:20,066
所以加号放在操作符栈上。忽略左括号。忽略括号有点奇怪

79
00:08:20,066 --> 00:08:24,568
这个问题后面再讲。数值，放在数值栈上

80
00:08:24,568 --> 00:08:29,677
操作符，放在操作符栈上。除了往栈里放东西看起来

81
00:08:29,677 --> 00:08:35,062
我们没有做太多的事。现在，遇到右括号了

82
00:08:35,062 --> 00:08:40,322
开始变得有意思了。获取操作符栈顶的操作符和

83
00:08:40,322 --> 00:08:45,573
数值栈上的前两个数值，然后如此操作

84
00:08:45,573 --> 00:08:52,136
在两个树枝上进行操作符的运算，将结果放回到数值栈上

85
00:08:52,136 --> 00:08:57,758
所以我们取出上面两个数值，进行操作，然后将

86
00:08:57,758 --> 00:09:05,024
得到的结果放回到数值栈。这就是右括号对应的操作

87
00:09:05,024 --> 00:09:14,720
继续往下走，入栈一个乘号。左括号，忽略。4，入栈。乘号

88
00:09:14,991 --> 00:09:21,088
5 放到数值栈。现在我们在栈上有好多东西

89
00:09:21,088 --> 00:09:25,971
然后遇到右括号，就要完成计算了

90
00:09:25,971 --> 00:09:30,530
从数值栈上取下前两个数值，取下操作符栈顶的操作符

91
00:09:30,530 --> 00:09:35,400
进行操作，计算结果放回数值栈。又一个右括号

92
00:09:35,400 --> 00:09:40,392
取下两个数值，进行操作，计算结果放回数值栈

93
00:09:40,392 --> 00:09:45,696
终于，最后一个右括号，从数值栈上取下

94
00:09:45,696 --> 00:09:51,508
前两个数值，取下操作符栈顶的操作符

95
00:09:51,508 --> 00:09:56,874
进行操作，计算结果放回数值栈

96
00:09:56,874 --> 00:10:06,352
计算结束，这就是结果。算术表达式的值是101

97
00:10:06,352 --> 00:10:19,447
这里是实现Dijkstra双栈算法的代码

98
00:10:19,737 --> 00:10:26,915
有两个栈。操作符栈是字符串栈

99
00:10:26,915 --> 00:10:32,962
也可以是字符，因为只存操作符。数值栈是Double栈

100
00:10:32,962 --> 00:10:39,034
相同的栈代码，但是泛化的。我们使用两种不同的

101
00:10:39,034 --> 00:10:44,492
数据类型。然后就是进行Dijkstra算法。读取新的字符串

102
00:10:44,492 --> 00:10:50,397
如果遇到左括号，不做操作

103
00:10:50,397 --> 00:10:57,089
如果是加号或者乘号，入栈。如果遇到右括号，就将操作符

104
00:10:57,089 --> 00:11:05,216
出栈。如果是加号，将这两个数值的运算结果放在数值栈顶

105
00:11:05,216 --> 00:11:13,757
如果是乘号，将栈顶两个数值相乘

106
00:11:13,757 --> 00:11:20,392
然后将结果入栈。运算结束后就是将栈顶的数值

107
00:11:20,392 --> 00:11:26,749
打印出来。这是利用栈处理任何算术表达式的一个优雅的实现

108
00:11:26,749 --> 00:11:33,027
也很容易扩展它，处理其他的符号

109
00:11:33,027 --> 00:11:40,754
为什么这个算法是正确的呢？当算法遇到操作符时

110
00:11:40,754 --> 00:11:46,910
比如在里面，有左括号、操作数、操作符、操作数、右括号

111
00:11:47,125 --> 00:11:53,697
很容易看出在里面应该做什么

112
00:11:53,697 --> 00:11:59,647
将2和3放在数值栈顶

113
00:11:59,647 --> 00:12:05,534
加号放在操作符栈顶，当遇到右括号时

114
00:12:05,534 --> 00:12:11,089
进行运算，算法继续执行，就像原先的输入是这样的

115
00:12:11,089 --> 00:12:17,064
数值替换了括号中的表达式。从里到外

116
00:12:17,064 --> 00:12:23,314
对每个括号中包含的运算操作，像这样

117
00:12:23,314 --> 00:12:29,169
就是重写这个式子，好像原先的表达式是1+(5×20)

118
00:12:29,169 --> 00:12:34,981
然后替换为1+100，101。这就是

119
00:12:34,981 --> 00:12:41,487
为什么Dijkstra算法是正确的。实际上这挺好理解的

120
00:12:41,487 --> 00:12:48,066
你可以继续扩展这个算法，加入函数比如log和sin

121
00:12:48,066 --> 00:12:54,376
其他的操作符，给操作符分配优先级，让它们可结合

122
00:12:54,376 --> 00:13:01,602
等等多种操作。实际上这就引向了

123
00:13:01,845 --> 00:13:08,720
开发编译器或者将一个程序从一种编程语言

124
00:13:08,720 --> 00:13:16,585
翻译为计算的过程，所以使用栈的Dijkstra算法

125
00:13:16,948 --> 00:13:25,072
是通向理解计算基础的大门