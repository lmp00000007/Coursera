그러면, 이제 간단히 같은 기본적인 기저 자료구조를 활용한 큐 구현을 살펴보도록 합시다. StackOfStrings와 대응되는 QueueOfStrings라는 API가 있는데요. 스택과 똑같은 API를 제공합니다만, 연산의 이름이 다릅니다. push 대신 enqueue를, pop 대신 dequeue를 쓰고 있죠. 그 의미(sementics)도 다른데,
 enqueue는 큐 끝에 아이템을 넣는 것이고요. dequeue는 큐 시작에서 아이템을 제거하는 겁니다. 실생활의 유사 사례를 들어보면, 티켓을 사기 위해 줄서있는 상황인데, enqueue를 하면 여러분이 줄 끝에 서는 거죠. 반면 dequeue의 대상은
 그 줄에서 가장 오래 기다렸던 사람인 거고요. 이를 어떻게 구현할 지를 처음엔
 연결 리스트로 다음엔 배열으로 살펴봅시다. 먼저 연결 리스트 기반의 큐 표현을 살펴볼건데요. 두 개의 포인터, 즉 참조를 유지합니다. 하나느 리스트의 첫 아이템을, 다른 하나는
 리스트의 마지막 아이템을 가리킵니다. 아이템을 삽입하면, 리스트의 시작점이 아니라
 리스트의 끝에 아이템을 삽입하고요. 제거를 할 때는, 기존과 똑같이 시작점에서 제거를 합니다. 여기에 dequeue의 구현이 있습니다. 스택에서의 pop과 코드가 동일합니다. 아이템을 떼어서 저장해두고,
 참조를 진전시켜 first가 가리키던 노드를 삭제하고, 그 뒤에 아이템을 리턴합니다. 그러니 똑같죠. 노드를 삽입하려면, 즉 enqueue하려면,
 즉 연결 리스트에 새 노드를 삽입하는 걸 말하는 건데 리스트의 끝에 넣어야 할테고,
 따라서 참조 last가 마지막에 갱신되어야 합니다. 따라서 마지막에 아이템을 넣기 위해서는 처음 해야 할 것은 마지막 노드의
 참조를 oldlast에 저장하는 겁니다. oldlast를 저장해야 하는 이유는, 기존 마지막 노드의 next 변수, 즉 null 상태로 되어 있을 참조가
 새 노드를 가리키게 해야 하기 때문입니다. 그럼 이제 연결 리스트 끝에 새 노드를 만듭시다. 새 마지막 노드에 아이템을 삽입하고
 참조 next를 null로 초기화를 했다면 기존 마지막 노드 oldlast의 참조 next가
 새 노드를 가리키도록 변경합니다. 다시 말해, 몇 줄의 코드이지만 이것이 기본적인 연결 리스트 처리 과정입니다. 사실 몇 년 전에 (C언어 등을 사용하는)
 알고리즘과 자료구조를 가르칠 때에는 많은 강의들이 이런 포인터의 교묘한 처리에 집중했었습니다. 하지만 요즘은 스택과 큐 같은 몇몇 구현이나 기본 자료 구조에서만 사용되고 있습니다. 이 수업에서는 연결 리스트를 취급하는
 더 일반적인 프로그램을 그리 다루진 않을 겁니다. 지금처럼 기본 데이터 타입이
 연결 리스트를 취급하는 캡슐화를 할 겁니다. 좋습니다. 이제 전체 구현으로 가서 기존 슬라이드의 코드를 살펴모아 봅시다. 큐가 비어있는 특별한 경우를 고려해야 하기도 하고요. dequeue를 한 뒤에 큐가 비어있다면, 이를 명확하게
 하기 위해 last를 null로 설정해야 합니다. 그래서 last를 null로 설정했고요. first와 last가 우리가 기대하는
 바대로 동작하도록 하기 위함이죠. 상세는 여러분 스스로 체크하실 수 있을 겁니다. 배열은 어떨까요? 상세는 다루지 않겠습니다만, 배열 리사이징을 이용한 큐를
 만드는 게 그리 어렵진 않을 겁니다. 어렵지 않아요. 하지만 여러분들이 해볼 만한,
 까다로운 프로그래밍 연습문제임은 분명합니다. 두 포인터 (인덱스), 즉 큐의 처음 아이템을 가리키는 head와 다음 아이템이 들어갈 장소를 가리키는 tail을 유지해야 합니다. enqueue 연산에서는 tail에 새 아이템을 삽입합니다. dequeue 연산에서는 head가 가리키는 아이템을 삭제합니다. 까다로운 부분은 연산 과정에서
 인덱스가 배열의 용량을 넘어섰을 때 인덱스가 0으로 초기화되어야 한다는 점입니다. 약간의 추가 코드가 필요한데요. 스택과 같은 자료구조로 구현하기 위해서 배열 리사이징을 추가할 수도 있을 겁니다. 이런 부분은 연습문제로 남겨두겠습니다.