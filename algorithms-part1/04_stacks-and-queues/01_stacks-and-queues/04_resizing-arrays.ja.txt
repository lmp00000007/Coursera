さて、我々の配列実装のスタックは欠点があります。 クライアントに事前にスタックの最大容量を指定してもらう必要があります。 それでは、この問題を解決する方法を見ていきましょう。どうやって？ そもそも API に含まれていません。API では、スタックを作ることしか明記していませんので 任意のサイズに増減できるべきです。ではどうやって配列を増やしたり 減らしたりできるでしょうか？考えられそうなことは、クライアントが 新しい要素をスタックに追加した時に配列サイズを一つ増やし、pop した時には 配列サイズを一つ減らすことです。実装はとても簡単ですが、良い方法ではありません。なぜならば そのためにとても大きなコストがかかります。理由は、サイズが一つ増えた配列を新たに生成して、 全ての要素をその配列にコピーします。となると、最初から N 個の要素を追加するには 表記の N - 1 に相当する時間がかかりますので、N の時間がかかると言えます。 そして都度２回の N - 1 を繰り返すので、最初から N 個の要素を追加するには 1 から N の数列の総和、ご存知の通り N^2 / 2 の時間がかかります。 N 個の要素をスタックに積むのに二乗時間がかかるというのは、大きな問題を扱うには受け入れられる性能ではありません。 私たちが見てきた通り、そして何度も見る事になるでしょう。というわけでやるべきことは 可変長とすることです。しかしどのタイミングでどのくらいの頻度で行なえばよいでしょうか？ 出来る事は repeated doubling と呼ばれる方法で、配列が一杯になった時 新たに倍のサイズの配列を生成して、全ての要素をコピーします。 その都度、配列を生成することはしません。というわけで、これが実装になります。 サイズが 1 の配列から始めます。スタックが一杯になったら、すなわち スタックの要素数 N と実際の配列長を比較すればわかりますね、そうであれば 要素を追加する前に、配列長を倍にリサイズします。どうやって 新たな容量にリサイズすればよいでしょうか？新しい配列を生成したら、単に走査して 元スタックの内容を最初の半分の領域にコピーした後、それを返します。 以上のことで、スタック用のインスタンス変数は、新しいより大きな配列にリセットされます。 この考え方、および結論は、 N 個の要素を配列、 配列によるスタックに追加する場合、その時間は N^2 ではなく N に相当します。理由は、新たに配列を生成するタイミングは 倍のサイズに達した時だけであり、倍になった時には、多くの要素をスタックに追加するとはいえども 平均としては、それぞれの可変操作の際のコストに加わるだけです。 コストを計算するならば、N 個の要素を追加する時 1 から N の数列の総和を求めるのではなく 2 の累乗の数列の総和を求めますので、それは 大まかに 3N となります。まず一回の配列アクセス、そしてコピーの際の 二回の配列アクセス。つまり要素を追加するには、おおまかに三回の配列アクセスが起こります。 このグラフは別の視点から、push 操作時に起こる配列アクセス数を 示しています。2 の累乗となる毎に、多くの配列アクセスが起こりますが ある意味、スタックに要素を積んでいく過程ですでに清算しています。 この見方は amortized analysis と呼ばれるもので 全処理の平均による総コストで考えます。これは分かりやすく 有用な amortized analysis の例で、スタック実装の効率を確認できます。 pop はどうなるでしょうか？どうやって配列を縮小するか考えなければなりません。 一杯になった時に倍にするのだから、半分になったら、半分の目一杯で 切り出すことを考えるかもしれません。空ばかりになった配列は不要ですからね。 なのですが、その考えでは明らかにうまくいきません。なぜならば スラッシングと呼ばれる現象があります。もし push pop push pop と交互に繰り返すとして そのとき配列が一杯なら、倍にして、半分にして、倍にして、半分にしてと それぞれの操作で配列を生成しますので、その都度 N に相当する時間がかかります。 ゆえに全体で見れば二乗時間ですので、そうはしたくありません。 効果的な解決策は、４分の１が一杯になるまで待ってから行なう方法です。 そして実装はとても簡単です。単に配列の４分の１が一杯になったかチェックして、 そうであれば半分にリサイズする。すなわち、その時点では 半分が一杯になっている状態なので、追加して拡張か、削除して縮小の、どちらも出来ます。 半分になって再び一杯になるまでは、さらなる配列のリサイズは行なわれません。 不変であるのは、配列は常に 25% から 100% の間で一杯になる点です。サイズが 1 と 2 では毎回リサイズを行ないます。 push や pop 操作ですでにある意味で償却しています。 このスライドでは、小さなクライアントを例にして、配列がどうなるかを確認します。 最初のほうを見るとわかりますが、1 から 2 そして 4 で倍になりますが いったん 4 になると、8 になるまでそのままです。 操作がなんであれ、そのままです。4 に縮小するのは 要素数が二つになってからで、それから縮小したらそのままです。 配列リサイズは頻繁に起こらず、配列でのスタックAPI を実装する とても効率的な方法です。クライアントはスタック最大容量を与えることもなく、 それでいてメモリ利用量を、スタックで実際に扱う要素数の ほんの定数倍に常に収まることを保証されます。 以上をふまえた解析結果として、操作毎の平均実行時間は 操作手順が何であろうとも、平均実行時間は 定数時間に相当します。最悪のケースは スタックが倍になる時で、N 相当の時間がかかります。 よいとは言えない性能ですが、それとは引き換えに 配列へのアクセスとインデックス増減だけの、とても高速な push と pop を実現でき ほとんどの処理で効率的です。多くのクライアントにとって有益なトレードオフです。 メモリ利用量はどうでしょうか？これがスタックのメモリ利用量の解析についてです。 文字列であればその利用量は、配列がどのくらい一杯かによって 8N と 32N の間で容量が確保されるので、実質それ以下になります。単に手っ取り早く Java で確保される配列サイズでの解析ですが。そして繰り返しますが この解析はスタック自身のものでクライアントが保持する文字列には関与しません。以上が 可変長配列と連結リストのトレードオフです。二つは異なる実装であるものの 同じ API を持ち、クライアントは相互に使い分けができます。 どちらがより良いでしょう？あらゆる状況で、私たちは複数の API 実装を持つことになりますし、 クライアントプログラムの特性に応じて、どちらが良いかは 選択しなければならないでしょう。連結リストでは全ての処理は 最悪のケースでも定数時間が保証されますが リンクを扱うためにやや余計な時間と容量がかかります。つまりより遅くなります。 可変長配列の実装では、うまく時間の償却ができますので、総体的にみた平均では 良い結果となります。容量の浪費も抑えられ、おそらく 各処理でもより速い実装になります。いくつかのクライアントでは効果はあるでしょう。 あるいは、可変長配列の実装を使いたいとは思わないこともあるでしょう。 着陸のために飛行機が侵入してくる時とか 不意にいくつかの処理がつっかかるのを避けたいとか。このような場合や 大量のパケットが流れつづけるネットワークスイッチ等では、 突然重くなって、いくつかのデータを失うような事は避けたいでしょう。 というわけで、以上がトレードオフというもので クライアントが決定できます。私の場合なら、全ての処理で安定した速さが必要なら、 連結リストを使います。そのような保証は不要で、単に 全体の実行時間が気になるなら、おそらく可変長配列を使うでしょう。 個々の処理は速いので、全体的にはより短い時間になるからです。 このように簡単なデータ構造ですら、本当に重要なトレードオフがあり、 実際に多くの現場で違いが出てきます。