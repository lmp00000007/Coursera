おかえりなさい。今回はいくつかの基本的なデータ構造 バッグ、キュー、そしてスタックの実装についてお話します。 どんなものかは知っているかもしれませんが、今回はこれらを注意深く掘り下げてみましょう。 多くのアプリケーションにおいて、コレクションを扱う機会があります。 操作はとてもシンプルです。何かをコレクションに加えたいとか 何かをコレクションから取り除きたいとか コレクションの要素を一つづつ取り出して何かしたいとか そう、もちろん空であるかどうかも。というわけで目的はとてもはっきりしています。 要素を取り除く時に、どの要素を取り除くか？ このための二つの基本的なデータ構造、スタックとキューは 取り除く要素の選択方法が異なります。スタックでは 一番最後に加えた要素を取り出します。専門的な用語で言えば、追加を push（プッシュ）、 最後に追加した要素を取り出すことを pop（ポップ）と言います。 Last-In-First-Out 後入れ先出しで LIFO とも言います。一方、キューでは一番最初に追加した要素を走査します。 区別するために要素を追加することを enqueue（エンキュー） 要素を取り出すことを dequeue（デキュー）と言います。またの名を FIFO、 つまり First-In-First-Out（先入れ先出し） ですね。それでは、これらをどうやって実装するか見て行きましょう。 まずモジュラープログラミングについて話しましょう。 本コースを通じて、後々もこの規律に沿っていきます。 考え方は、インターフェイスと実装を完全に分けるということです。 これからも、スタックやキューのように明確に定義されたデータ構造やデータ型が出てきます。 やりたいことは、どうやって実装しているかの詳細を クライアントからは分けるということ。クライアントはあらゆる実装が選択できて なおかつクライアント側のコードは基本操作だけで済むように。 対して実装については、クライアントがやりたいことはわからないので、 こちらで出来る事はそれらの処理を実装することです。 そうすることで、多くのクライアントが同じ実装を再利用できます。 このことは、組み替えや再利用が可能なアルゴリズムとデータ構造のライブラリを作り さらに複雑なアルゴリズムとデータ構造を組むのに利用できることに繋がります。 場合に応じて、性能を調べることもできます。繰り返すと これがモジュラープログラミングで、Java のようなオブジェクト指向言語で実現できます。 このやり方に従って、私たちはしっかりと規律を守っていきましょう。 いいでしょう。ではスタックからいきましょう。[cough] スタックは身近で、 プログラミング入門段階でおそらく多くの皆さんが実装したでしょうが 今からは、実装について徹底的に見ていきましょう。手始めに 文字列のコレクションを扱うとしましょう。 そのサイズは小さいかもしれないし、大きいかもしれません。出来ればよいことは 文字列のコレクションを保存できて、最後に追加した文字列を取り除いて、それを一つ一つ返す。 また空であるかも調べることです。というわけで API は 空のスタックを作るコンストラクタと、追加のための push と呼ばれる 一つの文字列を引数にとるメゾッドを持ちます。そして削除のためには pop メゾッドを持ち 一番最後に追加した文字列を返します。空かどうかは Boolean を返します。 いくつかのアプリケーションでは、size メゾッドも含めることになるでしょう。 それではいつものように、最初にクライアントプログラムを読んでから、実装を見ていきましょう。 この簡単なプログラムは、標準入力から文字列を受け取って ハイフンを pop コマンドとみなします。そう、このプログラムは文字列を 標準入力から読み込んで、もし文字列がハイフンなら スタックから文字列を pop して表示します。そうではなくて ハイフンではない文字列なら、単にスタックに push するだけです。 下の方の例は、tobe.txt というファイルがあるとして プログラムがやることは  "to, be, or, not, to" とスタックに push して そして次のハイフンが一番最後に追加された要素を pop します。この場合は "to" ですね。 それから "be" をスタックに追加して、それからスタックの先頭要素を pop します。 これは今の "be" ですね。それからまた一番最後に追加された要素を取り出します。"be" そして "to" まで取り出されていますから、 次にくるのは "not" ですね、後も同じように続けます。というわけで、このような簡単なテストプログラムで 実装をテストするのに使えます。ではスタックの実装コードを見てみましょう。 最初に見ていく実装では「連結リスト」を使っています。 連結リストに馴染みがないなら、1.3 章、教則本の 1.3 章ですね。または 我々の提供している書籍 "Introduction To Programming Java" を参照する必要があるでしょう。慣れ親しんでいるにしても このコードは読むに値します。なぜならば、そのコーディングスタイルは 本コースを通じてもっと複雑なデータ構造で使うことになるからです。 考え方は、連結リストを保持することです。複数ノードで構成され、 ノード毎に文字列を持ち、次の要素をもつノードへの参照を持ちます。 スタックを実装するなら、push 操作では、新しいノードを連結リストの先頭に追加して pop 操作では連結リストの先頭から最初のノードを取り出す。 つまり一番最後に追加した要素ですね。では、コードがどうなっているか見てみましょう。 本コースを通じて、すべてのリンクするデータ構造において、連結リストを実装することになります。 Java の内部クラスと呼ばれるものを用いて 取り扱うノード内オブジェクトの構成を示しています。 それぞれのノードは文字列と他ノードへの参照を持ちます。つまり 連結リストの pop 操作はとても簡単に実装できます。[cough]  必要なことは リスト内の先頭要素を返すために、それを退避しておくことが必要です。まず先頭要素を取り出して 変数 item にセットしておきます。それから先頭ノードを取り除きます。 先頭要素を指していたポインタを次の要素に進めるだけです。 それで先頭ノードはガベージコレクタにより回収されるようになります。 そして最後にやることは、退避しておいた要素を返すだけです。いいですね、 これが pop 操作です。push 操作はどうなるでしょうか？ [cough] 連結リストの先頭に新しいノードを追加したいので まず最初に先頭のポインタを退避します。 "oldfirst = first" の箇所です。それから新しいノードを生成して リストの先頭に追加します。"first = new Node" の箇所です。 それからインスタンス変数をセットします。item は文字列で リストの先頭に追加するものですね。このケースでは "not" です。そして next は旧先頭ポインタ、 すなわち二番目の要素になります。この操作後に first ポインタはリストの先頭を指していますので、リスト内の要素は スタックに push すると降順となるわけです。これらの４行のコードが スタックの push の実装になります。それでこれが完全な連結リスト実装の 全てのコードです。Java で文字列スタックのための連結リストを実装しています。 コンストラクタは何もすることはないクラスなので コンストラクタはありません。この内部クラスは連結リストの要素を組み立てるためのもので 直接インスタンス変数を参照できるように内部クラスにしています。 それで、唯一のスタックのインスタンス変数は リストの先頭ノードへの参照で、初期値は NULL です。 そして isEmpty は先頭ノードが NULL であるかどうかをチェックします。 push は前のスライドで見せた４行のコードで、pop は さらに前で見せた３行のコードです。以上が完全な 連結リストの実装で、スタックを扱うあらゆるクライアントプログラムで問題なく動作します。 これで性能を計測できるようになりましたので どれくらいうまくアルゴリズムとデータ構造が動くのかの情報を利用者に伝える事が出来ます。 今回のケースでは、見ればすぐに分かる通り、全ての操作は 最悪のケースでも定数時間で済みます。それぞれの操作は数行程で ループ処理もありません。明らかに望ましい特性ですね。 メモリの利用量はどうでしょうか？これに関しては、かなりの面で マシン毎の実装に依存します。今回は典型的な Java 実装ですので 異なる環境で比較する事はせずに、単にここに書いているケースで検証します。 Java での内部クラスは、どのオブジェクトにも 16 バイトのオーバーヘッドがあります。さらに追加の 8 バイトのオーバーヘッドがあり それは内部クラスであるためです。それから二つの参照がノードのクラス内にあります。 一つは文字列、もう一つはノードへの参照で、それぞれ 8 バイトです。すなわちスタックのノードあたり 40 バイトで、スタックのサイズを N とするなら 約 40N バイトになります。わずかに先頭ノード参照の分もありますが スタック自体のオーバーヘッドなので、N が大きければ、40N は必要量の見込値に十分近づきます。 文字列そのものの容量が含まれていませんが、これはクライアントプログラム側が持つものです。 なのですが、本実装ではこのメモリ利用量の求め方で、 異なるクライアントプログラムであっても正しく評価できます。さて、これまでの実装は定数時間の計算量でしたが より速いスタックの実装があります。スタックはさまざまなアルゴリズムの内部ループで使われますので より速い実装について考えることはとても重要です。 もう一つのスタック実装の自然な方法は、スタック要素の格納に配列を使うことです。 では見てみましょう。リンク構造と配列のどちらを選択するかは 大事なことです。何度も何度も もっと複雑なアルゴリズムを考える時に出てきます。 それでは、スタックの簡単なケースで計測してみて 後のより複雑なアプリケーションに備えたいと思います。いいでしょう。配列を使う場合は 配列内のスタックに N 個の要素があることを保持しておきます。N の配列位置は 次の要素を格納する場所、すなわちスタックの先頭です。push するためには s(N) の位置に新しい要素を追加して、pop するためには s(N) を取り除いて N を一つ減らします。さて、配列を使う際に根本的な欠点があります。それは 配列のサイズを事前に決めておく必要がある点で、すなわちスタックは 一定容量になります。そうなると、容量を超える要素がある場合に なんとかする必要があります。この問題は あらゆる種類のアルゴリズムとデータ構造で配列を使う時に、避けて通れません。 まずは簡単なケースで考えて、後で片付けましょう。いいでしょう、それでは これが配列を使ったスタックの全ての実装です。 インスタンス変数は、文字列の配列、そして N は スタックのサイズと次の配列インデックスを兼ねています。次に空いている スタックの位置ですね。この実装ではコンストラクタがあり、コンストラクタは 配列を生成します。簡単にするために、これはとりあえずの実装です。 クライアントプログラムからスタック容量を指定してもらえると考えておきましょう。 ちょっとしたアプリケーションならこれでもいいでしょうが、 大規模なアプリケーションでは、複数人がかかわることになります。利用者は 厳密にはスタックの大きさを知る事ができません。多くのスタックを 同時に扱うような場合に、違ったタイミングや様々な原因で、最大容量に達してしまうかもしれません。 このとりあえずの実装は削除する必要がありますので後でやります。 容量が決まっているなら、コードはさしたるものではありません。空かどうかは N がゼロかどうか調べます。要素を push するには、配列インデックスとして N を使って要素を追加し N を増やします。この記述は最近の多くのプログラミング言語で使われているショートカットです。 まずインデックスとして使い、その後にインクリメントしています。pop するには、インデックスを減らしてから そのまま戻り値のインデックスとして使います。それぞれの操作は一行で 誰にとってもわかりやすい実装ですね。以上が配列によるスタックの実装ですが クライアントプログラムから容量を指定してもらう点が API に則していません。 ではどうすればよいでしょうか？まず、今まで考慮してこなかった事が数点あります。 空のスタックを pop しようとした場合に、例外を投げるコードを書いていませんでしたね。 これはやるべきでしょう。そしてオーバーフローについて クライアントプログラム次第で起こりますが、これからお話する「可変長」と呼ばれる手法で オーバーフローは回避できます。さらなる問題に NULL の要素を追加できるかどうかがあります。今回の実装では NULL の追加を許可しています。しかし Java において気にかけておく必要があるのは ロイタリングと呼ばれる物で、オブジェクト参照を 配列による実装やスタック配列に保持しているが、それらを実際には利用していないことを指します。 N 値を減らした時も、スタックから取り出した要素へのポインタは、配列内にまだ残っています。 もう使っていないと分かっていても。Java 側では そのことは分かりません。これを回避してもっとメモリを効率良く使うには このようにするのが一番です。 [cough] 取り除いた要素があった配列エントリに NULL をセットすれば 使わなくなった要素への参照はなくなるので、ガベージコレクタは どこからも参照がないとみなして、メモリを回収できます。細かいですが 注視すべき重要な点です。また実装を確認しておくことで 最大限の効率でメモリを活用できます。