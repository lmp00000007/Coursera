1
00:00:01,010 --> 00:00:06,509
좋아요. Java가 제공하는 또 다른 기능으로는 우리의 기본 데이터 유형에

2
00:00:06,509 --> 00:00:11,759
추가할 가치가 확실히 있는 매우 우아한 소형 클라이언트 코드를 이끌고

3
00:00:11,759 --> 00:00:17,058
그것은 반복이고, 이제 우리가 이야기할 내용입니다. 그래서, 우리가

4
00:00:17,058 --> 00:00:23,176
하려는 것은 클라이언트가 컬렉션의 항목들을 통해 반복하기를 허용하는 것입니다. 하지만

5
00:00:23,364 --> 00:00:28,286
우리는 우리가 배열 또는 링크 목록이나 무엇이든 우리가 염두할 수도 있는

6
00:00:28,286 --> 00:00:34,620
내부 표현을 사용하는지 여부를 아는 클라이언트가 없습니다. 클라이언트와 관련이

7
00:00:34,620 --> 00:00:41,189
없습니다. 그리고 많은 클라이언트들이 단지 하고 싶은 것은 컬렉션에 있는 것들을 통해

8
00:00:41,189 --> 00:00:47,304
반복하는 것입니다. 하지만 Java는 반복이라 불리는 좋은 해결책을 제공합니다. 그래서

9
00:00:47,304 --> 00:00:53,523
우리가 하려는 것은 우리의 스택, 그리고 큐, 그리고 우리가

10
00:00:53,523 --> 00:00:58,914
Iterable 인터페이스라 불리는 도구를 고려하는 다른 데이터 구조들을 어떻게 만드는지 살펴보고

11
00:00:59,108 --> 00:01:05,662
그리고 우리가 사용한 어떤 도구를 사용했는지에 상관없이 클라이언트 코드에 작동될 것이므로

12
00:01:05,662 --> 00:01:13,497
그것의 자세한 내용을 살펴보겠습니다. 그럼 Iterable은 뭘까요? 음, Java 용어로

13
00:01:13,497 --> 00:01:20,914
Iterable이라는 것은, 그것은, 그것은 반복자를 되돌리는 방법을 가진 분류입니다. 그래서

14
00:01:21,182 --> 00:01:29,271
반복자는 무엇일까요? 음 반복자는 어떤, hasNext와 next() 방법을 가진

15
00:01:29,271 --> 00:01:37,519
분류입니다. Java는 또한 remove()를 허용합니다.
우리는 그건 나쁜 소식이라 생각하고, 우리가 사용하지 않으면

16
00:01:37,519 --> 00:01:45,861
버그 디버깅 문제인, 디버그가 확산될 수 있습니다. 따라서, 이것은 hasNext()와

17
00:01:45,861 --> 00:01:52,828
next() 이고 그래서 데이터 구조 도관가능하게 하기 위해, 우리는 그것들을 실행할

18
00:01:52,828 --> 00:01:58,837
것입니다. 이동 운반하기에 짐이 많아 보이는데, 우리가 그렇게 하는데 이유는,

19
00:01:58,837 --> 00:02:04,768
우리가 할 수 있는 것을 우리가 문제를 일으키는 이유는, 만약 우리가 도관가능한 데이터 구조를 우리가 가진다면,

20
00:02:04,768 --> 00:02:10,795
우리는 Java에서 각 항목을 요구하는 매우 간편하고 우아한 클라이언트 코드를

21
00:02:10,795 --> 00:02:16,185
사용할 수 있습니다. 그래서 만약 우리가 스택이 있다면 우리는 말할 수 있습니다 - (for String s : stack).

22
00:02:16,185 --> 00:02:22,587
그것은 스택에서 각 줄을 의미합니다 - 출력하세요. 그리고 만약 우리가 지금

23
00:02:22,587 --> 00:02:29,442
그것이 없었다면, 만약 우리가 반복자를 사용한다면, 우리는 진행하고

24
00:02:29,442 --> 00:02:35,550
이 수기 코드를 쓸 수 있지만 그것은 속기와 같은 것이기 때문에 아무도 그러지 않을

25
00:02:35,550 --> 00:02:42,710
것이거나 우리는 이런 반복을 하기 위해서 많은 불필요한 푸시와 팝들을 하는

26
00:02:42,710 --> 00:02:48,386
클리이언트 코드를 써야할지도 모릅니다. 그래서 핵심은 데이터 구조 안의 아이템을 통해

27
00:02:48,386 --> 00:02:53,928
반복하기 위해서 꽤 작은 클라이언트 코드를 가질 수 있는 것이고

28
00:02:53,928 --> 00:02:59,370
그래서 우리는 우리의 모든 기본적인 데이터 구조들에 반복을 제공할

29
00:02:59,370 --> 00:03:05,712
것이고 그런 노력을 할 만한 가치가 있는 일을 하는 건 그리 어렵지 않습니다. 그래서

30
00:03:05,712 --> 00:03:12,877
여기 링크 목록은 다음과 같습니다. 그렇다면 iterable을 실행해야하면

31
00:03:12,877 --> 00:03:19,470
실행 iterable은 무슨 뜻일까요? 그것은 반복자를 돌리는 iterator() 방법을

32
00:03:19,470 --> 00:03:25,017
갖고 있어야 합니다. 그럼 반복자는 무엇일까요? 그럼, 우리는 내부 분류를

33
00:03:25,017 --> 00:03:30,926
사용하겠습니다. 이 경우에, 우리는 그것을 반복자를 구현하는 ListIterator라고 부르고

34
00:03:30,926 --> 00:03:36,498
그것은 일반적입니다. 그리고 기본적으로 이것은 이런 hasNext() and next()

35
00:03:36,498 --> 00:03:42,158
방법으로 실행해야합니다. 그리고 의미론은 이름에서 정말 명확하게 나옵니다. hasNext()는 우리가

36
00:03:42,365 --> 00:03:47,917
한 것이 거짓으로 돌아온다면 하게 되어 있습니다. 만약 우리가 진실로 되돌아 와야

37
00:03:47,917 --> 00:03:53,462
하는 것을 하지 않는다면 next()는 반복되면서 다음 항목을 주게 되어있습니다. 그래서 만약

38
00:03:53,462 --> 00:03:58,973
이것이 연계된 목록잉라면 우리는 처음에 시작할 것입니다. 이것이 목록에서

39
00:03:58,973 --> 00:04:04,896
우리가 가진 첫번째 항목이고 우리는 우리가 반복하는 현재의 것인

40
00:04:04,896 --> 00:04:10,461
변동이 심한 현재 이 내부 반복자 사례를 유지할 것입니다. 따라서, 우리가 첫번째를

41
00:04:10,461 --> 00:04:15,439
지우고 싶다면 다음 것도 똑같은 방법으로 하세요. 우리는 현재 항목을 끌어내고

42
00:04:15,439 --> 00:04:21,073
그런 다음 현재 참조와 반환 항목을 발전시켰습니다. 현재에서 다음 위치로

43
00:04:21,073 --> 00:04:27,483
이동합니다. 제가 보여준 대로 클라이언트는 항상 hasNext()를 테스트할 것이고

44
00:04:27,483 --> 00:04:35,069
그 이전 남은 코드와 그리고 그것이 아무 가치 없게 될 때 그것은 반복의 정지에서

45
00:04:35,069 --> 00:04:41,084
거짓으로 돌아올 것입니다. 하지만 우리의 반복을 위해, 우리는 단지 next() and hasNext() 실행과

46
00:04:41,084 --> 00:04:47,952
어쩌면 완료하기 위한 현지 사례 변수 사용에 대해 걱정해야 합니다. 우리는 아마도

47
00:04:47,952 --> 00:04:54,457
방탄 코드를 만들어야 합니다 - 예외를 두면 만약 클라이언트가

48
00:04:54,457 --> 00:05:01,339
항목이 없는 상태에서 next()를 부르려고 시도하고 remove()를 부르기 위해 시도한다면, 우리는

49
00:05:01,339 --> 00:05:07,326
reomove()를 지지하지 않을 것입니다. 배열의 경우, 훨씬 간단합니다. 그럼 이제 이 반복자로 우리는

50
00:05:07,326 --> 00:05:13,041
우리가 아이템을 통한 순서에 대한 통제를 갖고 그래서 그것은

51
00:05:13,041 --> 00:05:18,834
의미론과 데이터 구조에 동의할 것이고 그래서 아마도 스택 내에서 여러분은

52
00:05:18,834 --> 00:05:24,504
스택에서 나오는 순서 같은 스택 순서에서 그것들을 가져오길 원해서

53
00:05:24,504 --> 00:05:31,686
그것은 배열에서 역순이고 그래서 이 경우에 next()는 그냥 감소하고 다음 것을

54
00:05:31,686 --> 00:05:37,522
반환하고 우리의 예시 변수는 배열에서의 색인입니다. 그리고나서 hasNext()는

55
00:05:37,522 --> 00:05:48,052
그것이 긍정적인 것이라면 괜찮습니다. 그래서 이 작은 Java [기침] 코드는 이

56
00:05:48,052 --> 00:05:55,229
반복 기능을 제공하지만 실제로 이 프레임워크 내에서 너무 많은 작업을 하지 않고

57
00:05:55,229 --> 00:06:02,108
여러분은 여러분 고유의 데이터 유형에 대해 이 방법을 구현하는 방법을 확인할 수 있고 우리는

58
00:06:02,108 --> 00:06:07,873
우리가 마주할 객체의 집합을 포함하는 모든 기본적인 데이터 유형에 이 패러다임을 사용할

59
00:06:07,873 --> 00:06:14,633
것입니다. 좋아요, 그리고 사실, 그것은 우리가 많은 클라이언에게 실제로

60
00:06:14,633 --> 00:06:20,905
어떤 주문을 받을지는 중요하지 않게 우리를 이끌었습니다. 실제로 우리가 종종

61
00:06:20,905 --> 00:06:27,275
하는 것은 그냥 아이템들을 콜렉션에 삽입하고나서, 나중에, 우리가 가진 아이템들을

62
00:06:27,275 --> 00:06:34,410
통해 반복하는 것입니다. 그 데이터 구조는 가방이라 불리고 이제 API가 어떻게

63
00:06:34,410 --> 00:06:40,680
생겼는지 살펴보겠습니다. 순서는 중요하지 않으므로 우리가 하고자 하는 것은 아마도

64
00:06:40,913 --> 00:06:47,303
여러분이 사이즈를 알고싶은 아이템을 추가하고 우리는 가방 안에 있는 모든 아이템을 통해 반복하기를

65
00:06:47,303 --> 00:06:53,986
원합니다. 따라서 이것은 간단하고 좁은 API지만 여전히 운영의 중요하고

66
00:06:53,986 --> 00:07:00,370
작은 컬렉션을 표시하고, 그리고 우리는 이것을 사용할 것이고 우리는 이미

67
00:07:00,370 --> 00:07:06,512
구현을 보았습니다. 여러분은 그냥 스택을 쌓아서 팝, 또는 큐를 제거하고

68
00:07:09,792 --> 00:07:13,072
데큐를 제거하고 [기침] 그리고 여러분은 유용한 데이터 구조의 좋은 반복을 가질 것입니다.