Java が提供する、もう一つの便利な機能があります。とてもエレガントで 簡潔なコードが書けます。基本データ型に、ぜひ付け加える価値のあるもので、 それはイテレーションです。それについてお話します。やりたいことは、 クライアントがコレクション内の要素を一つ一つ取り出せるようにすることです。 とはいっても、クライアントには、配列が連結リストのどちらを使っているかとか、 見せない内部構造はなんであれ、知らせません。クライアントには関係ない事です。 多くのクライアントは、単にコレクション内の中身を一つづつ取り出せればよいだけです。 Java にはイテレーションと呼ばれる良い解決策があります。 これから行なうことは、スタック、キュー、今後検討するデータ構造に どうやって Iterable と呼ばれるインターフェイスを実現するかです。 それにより施した実装に関係なく、クライアントのコードで使えます。 詳細を見てみましょう。Iterable とは何でしょうか？ Iterable は Java の用語で Iterator を返すメゾッドを持つクラスであることを指します。 Iterator とは何でしょうか？ Iterator とはクラスで、hasNext() と next() メゾッドを持ちます。Java では remove() もありますが、これは粗悪なものだと思います。 このメゾッドは使いません。深刻なバグを起こしやすくデバッグも大変です。というわけで hasNext() と next() です。データ構造を Iterable にするべく、これらを実装して行きましょう。 持ち運ぶ荷物が多そうな感じに思えますし、なぜわざわざ そんなことをするかというと、データ構造が Iterable であれば Java においては、クライアントはとても簡潔でエレガントなコードが書けます。 for-each 記法と呼ばれるもので、スタックを扱うとすると for (String s : stack) で このコードは、スタックから一つづつ文字列を取り出して表示させています。 もしそのような機能がないとしたら、Iterator 使う際は、なんとか この長たらしいコードを書けばよいことですが、もう誰もそんなことはしません。 なぜなら短縮表記のコードも同じものですから。もしくは、このイテレーションのためだけに たくさんの push や pop を書くことになりかねません。鍵となるのは データ構造での要素の取り出しのためのクライアントコードを簡潔にすることなので、 基本データ構造にはイテレーションの機能を与えようと思います。 さほど難しくありませんし、やる価値は明らかにあります。 それで、連結リストだとこんな感じです。Iterable を実装とは言っても どういう意味でしょうか？それは iterator() というイテレータを返す メゾッドを持っているということです。我々は内部クラスを使います。 このケースでは、ListIterator としていますが、これが  Iterator を実装しています。 ジェネリクスですね。基本的にやるべき事は、これらのメゾッド、 hasNext()  と next() の実装です。意味は名前でわかりますね。hasNext() は 完了していれば false、完了していなければ true を返しそうです。 next() は繰り返し次の要素を与えてくれそうですね。 そして連結リストということで、まず first から見ていきます。 それはリスト内先頭要素ですね。このイテレータ内のインスタンス変数 current で 取り出し中の現在位置を管理します。 次の要素を得る、すなわち first を取り出すためには、現在位置の要素を抜き出して、 現在位置の参照を進めた後、要素を返します。current を次に移動しています。 先にコード例で見せた通り、クライアントは hasNext() を常にチェックします。 NULL になったら、取り出し終端の意味で false が返ります。 とはいえ、ここまでのイテレーション実装で注力しているのは、 next() と hasNext() の実装に関してのみで、単にインスタンス変数を使っているだけです。 おそらく、エラーを考慮したコードを書かなければなりません。 要素が無いのに next() を呼んだら例外を投げる必要があります。remove() は常にですね。 remove() はサポートしませんので。配列の場合はもっと簡単です。 イテレータにおいて、どの順番でも要素を走査できますので、 意味的な面とデータ構造に合わせて考えましょう。おそらくスタックであれば、 スタックにあるものは、スタックが返す順番で得たいですよね。 ですから配列なら逆順です。このケースでは next() は配列インデックスを一つ減らして、 次の要素を返すだけです。このインスタンス変数は配列インデックスです。hasNext() は それが正の値なら真です。このイテレーション機能を提供する Java コードは [cough] この程度ですが、 実体としてはこの内部にあります。することは多くはありません。 あなた自身のデータ型でも、どうやって実装すれば良いか確認できますし、このやり方を これから取り組んでいくコレクション系の基本データ型で模範にしていきましょう。 いいでしょう。実のところ、多くのクライアントで該当しますが、 要素を取り出す順番はどうでもよかったりします。頻繁にやることは コレクションに要素を追加して、そして後になって、持っていた要素を 取り出すだけです。このデータ構造はバッグと呼ばれます。 API を見てみましょう。取り出し順は気にしません。やりたい事は 要素を追加することです。サイズも知りたいですね、そしてバッグ内の全ての要素を取り出したい。 より簡素な API ですが、それでも主要なコレクション操作を わずかながら網羅していますので、使っていきましょう。 すでに実装はご存知ですね。スタックから pop を削除、あるいはキューから dequeue を削除するだけです。[cough]  使いやすいデータ構造の実装がつかめましたね。