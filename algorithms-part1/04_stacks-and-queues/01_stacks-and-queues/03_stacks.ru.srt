1
00:00:02,173 --> 00:00:03,420
И снова здравствуйте.

2
00:00:03,420 --> 00:00:06,550
Сегодня будем говорить
об алгоритмах и структурах данных

3
00:00:06,550 --> 00:00:11,330
для реализации фундаментальных типов данных —
мультимножества, очереди и стека.

4
00:00:11,330 --> 00:00:13,290
Может быть вы немного знакомы с ними,

5
00:00:13,290 --> 00:00:15,710
но сегодня мы рассмотрим их подробно.

6
00:00:16,820 --> 00:00:21,020
Идея в том, что во многих приложениях
есть множества

7
00:00:21,020 --> 00:00:25,010
объектов для обработки.
Это простые операции.

8
00:00:25,010 --> 00:00:28,320
Нужно добавлять элементы к коллекции,
удалять элементы

9
00:00:28,320 --> 00:00:31,890
из неё, проходить по всем объектам,

10
00:00:31,890 --> 00:00:36,060
проводя над ними какие-либо операции,
проверять, не пуста ли она.

11
00:00:36,060 --> 00:00:39,130
Намерения вполне понятные.

12
00:00:39,130 --> 00:00:44,380
Ключевой момент: когда нужно удалить
элемент коллекции, какой именно удалять?

13
00:00:44,380 --> 00:00:49,680
Есть две классические
структуры данных: стек

14
00:00:49,680 --> 00:00:55,958
и очередь. Они различаются выбором
элемента для удаления.

15
00:00:55,958 --> 00:01:00,450
В стеке мы удаляем последний
добавленный элемент.

16
00:01:02,270 --> 00:01:05,605
Термины, которые мы используем:
push для вставки элемента

17
00:01:05,605 --> 00:01:08,350
и pop для удаления последнего
добавленного элемента.

18
00:01:08,350 --> 00:01:12,238
Подход называется LIFO (last in first out)—
последний зашел - первый вышел

19
00:01:12,238 --> 00:01:16,109
Для очереди мы берем добавленный
раньше всех элемент.

20
00:01:16,109 --> 00:01:19,642
Чтобы не путаться в операциях,

21
00:01:19,642 --> 00:01:23,870
добавление элемента назовем NQ,
а удаление — DQ.

22
00:01:23,870 --> 00:01:28,400
Этот способ называется FIFO (first in first out) —
первый пришел - первый вышел.

23
00:01:28,400 --> 00:01:31,649
Посмотрим, как всё это реализовать.

24
00:01:32,890 --> 00:01:37,100
Подтемой сегодня будет
модульное программирование.

25
00:01:37,100 --> 00:01:40,890
Эта тема будет освещаться в ходе всего

26
00:01:40,890 --> 00:01:42,220
в этом курсе.

27
00:01:42,220 --> 00:01:47,200
Идея в том, что бы полностью разделять
интерфейс и реализацию.

28
00:01:47,200 --> 00:01:52,280
При наличии четко определенной структуры

29
00:01:52,280 --> 00:01:57,570
и типов данных, как стек или очередь,
мы полностью

30
00:01:57,570 --> 00:02:02,590
скрываем детали реализации от клиента.

31
00:02:02,590 --> 00:02:06,780
Клиент может выбрать
различные реализации

32
00:02:06,780 --> 00:02:10,380
но код должен использовать
 только базовые операции.

33
00:02:11,410 --> 00:02:12,610
С другой стороны,

34
00:02:12,610 --> 00:02:16,030
реализация не может знать
детально потребности клиента.

35
00:02:16,030 --> 00:02:20,470
Код должен лишь реализовать операции.

36
00:02:20,470 --> 00:02:24,560
В этом случае, многие клиенты
могут использовать одну реализацию.

37
00:02:24,560 --> 00:02:28,040
Мы можем создавать модульные,

38
00:02:28,040 --> 00:02:32,620
многократно используемые библиотеки
 алгоритмов и структур данных,

39
00:02:32,620 --> 00:02:36,260
из которых строятся более сложные алгоритмы
и структуры данных.

40
00:02:36,260 --> 00:02:41,350
Это позволяет при необходимости
сосредоточиться на быстродействии.

41
00:02:41,350 --> 00:02:45,710
Это модульный стиль программирования,
который возможен

42
00:02:45,710 --> 00:02:48,790
благодаря объектно-ориентированным языкам,
как Java.

43
00:02:48,790 --> 00:02:53,790
Будем придерживаться этого стиля.

44
00:02:53,790 --> 00:02:56,460
Начнем разговор со стеков.

45
00:02:58,440 --> 00:03:00,100
Они вам знакомы.

46
00:03:00,100 --> 00:03:04,560
Многие из вас реализовывали
стеки на начальных уроках по программированию,

47
00:03:04,560 --> 00:03:08,900
но мы тщательно разберем их
реализацию прямо сейчас.

48
00:03:09,910 --> 00:03:16,390
Для разминки предположим,
что у нас есть коллекция строк.

49
00:03:16,390 --> 00:03:18,420
Они могут быть короткими или длинными.

50
00:03:18,420 --> 00:03:24,680
Мы хотим иметь возможность
сохранять коллекцию строк,

51
00:03:24,680 --> 00:03:28,790
удалять и выводить
последние добавленные строки,

52
00:03:28,790 --> 00:03:30,010
проверять, пуста ли она.

53
00:03:31,250 --> 00:03:33,070
Так вот наше API.

54
00:03:33,070 --> 00:03:36,319
Есть конструктор для создания
пустого стека.

55
00:03:37,880 --> 00:03:44,930
Для вставки используется метод push,
аргумент которого — строка,

56
00:03:44,930 --> 00:03:50,460
для удаления — метод pop, который выводит
строку, добавленную последней.

57
00:03:50,460 --> 00:03:53,598
Метод isEmpty возвращает
логическое значение.

58
00:03:53,598 --> 00:03:57,440
В некоторых приложениях, 
мы будет включать метод Size.

59
00:03:58,450 --> 00:04:05,245
Как обычно, сначала напишем клиент,
а затем разберем реализацию.

60
00:04:05,245 --> 00:04:12,210
Наш клиент читает строки
из стандартного ввода

61
00:04:12,210 --> 00:04:17,870
и использует команду pop, 
которую обозначим дефисом.

62
00:04:17,870 --> 00:04:23,620
Итак, этот клиент читает строки
из стандартного ввода.

63
00:04:23,620 --> 00:04:27,560
Если строка равна знаку дефис,

64
00:04:27,560 --> 00:04:32,870
берем строку сверху стека и печатаем её.

65
00:04:32,870 --> 00:04:36,978
В противном случае,
если строка не равна дефису,

66
00:04:36,978 --> 00:04:38,976
она добавляется наверх стека.

67
00:04:38,976 --> 00:04:42,498
Рассмотрим пример.

68
00:04:42,498 --> 00:04:46,629
Есть файл tobe.text,

69
00:04:46,629 --> 00:04:53,316
клиент будет вставлять строки
 "to be or not to" в стек.

70
00:04:53,316 --> 00:04:55,362
Затем, когда дело доходит до дефиса,

71
00:04:55,362 --> 00:05:00,090
он выдаст последний 
добавленный элемент, в данном случае это "to".

72
00:05:00,090 --> 00:05:04,480
Затем добавит "be" наверх стека
и выдаст верхний

73
00:05:04,480 --> 00:05:09,035
элемент стека, то есть "be" и элемент,
добавленный последним.

74
00:05:09,035 --> 00:05:12,530
Т.е. "Be" уйдет, "to" тоже, 
 за ними идет "not" и так далее.

75
00:05:12,530 --> 00:05:17,860
Этот простой тестовый клиент можно
использовать для проверки наших реализаций.

76
00:05:17,860 --> 00:05:21,660
Посмотрим код для реализации стека.

77
00:05:23,000 --> 00:05:27,240
Первая реализация использует
односвязный список.

78
00:05:27,240 --> 00:05:30,432
Если вы не знакомы
с односвязными списками,

79
00:05:30,432 --> 00:05:35,780
то посмотрите разделы 1.1 - 1.3 книги

80
00:05:35,780 --> 00:05:40,600
или введение к книге
по программированию и Java.

81
00:05:40,600 --> 00:05:45,290
Даже если вы знакомы с односвязными 
списками, стоит взглянуть

82
00:05:45,290 --> 00:05:50,170
на код, потому что этот стиль мы будем
использовать на протяжении всего курса

83
00:05:50,170 --> 00:05:52,440
для более сложных структур данных.

84
00:05:52,440 --> 00:05:58,360
Нужно хранить односвязный список,
который состоит из узлов, состоящих

85
00:05:58,360 --> 00:06:03,911
из строки и ссылки на следующий
элемент списка.

86
00:06:05,260 --> 00:06:11,030
В реализации стека,
когда мы делаем добавление (push),

87
00:06:11,030 --> 00:06:15,570
то вставляем новый узел в начало списка.

88
00:06:15,570 --> 00:06:17,380
Когда извлекаем элемент,

89
00:06:17,380 --> 00:06:21,130
то удаляем первый элемент списка.

90
00:06:21,130 --> 00:06:23,640
Это последний добавленный элемент.

91
00:06:23,640 --> 00:06:25,454
Посмотрим, как выглядит этот код.

92
00:06:25,454 --> 00:06:30,720
Мы используем реализацию
односвязного списка

93
00:06:30,720 --> 00:06:34,510
во всех связных структурах, 
на протяжении курса. Используем внутренний класс Java.

94
00:06:34,510 --> 00:06:39,770
То есть будем манипулировать
объектами "узел",

95
00:06:39,770 --> 00:06:46,350
каждый из которых состоит
из строки и ссылки на другой объект "узел".

96
00:06:46,350 --> 00:06:53,880
Таким образом операция pop для списка
реализуется очень просто.

97
00:06:53,880 --> 00:07:00,140
Во-первых нужно вывести
первый элемент в списке,

98
00:07:00,140 --> 00:07:01,510
поэтому сохраняем его.

99
00:07:01,510 --> 00:07:04,119
Возьмем first.item и сохраним
в переменную item.

100
00:07:05,150 --> 00:07:10,020
Чтобы избавиться от первого узла,
просто сдвигаем указатель

101
00:07:10,020 --> 00:07:15,270
первого элемента списка
на следующий за ним элемент.

102
00:07:15,270 --> 00:07:19,900
Теперь первый элемент готов
быть удаленным сборщиком мусора.

103
00:07:19,900 --> 00:07:25,460
Остается только вывести элемент,
который мы сохранили.

104
00:07:27,200 --> 00:07:30,480
Это была операция pop. Что насчет 
push операции?

105
00:07:33,110 --> 00:07:37,360
Мы хотим добавить новый элемент
в начало списка.

106
00:07:37,360 --> 00:07:41,815
Первое: сохраняем
указатель на начало списка.

107
00:07:41,815 --> 00:07:45,350
Это oldfirst = first.

108
00:07:45,350 --> 00:07:48,180
Затем создаем новый узел,
который поместим

109
00:07:48,180 --> 00:07:49,535
в начало списка.

110
00:07:49,535 --> 00:07:52,260
Это: first = new Node.

111
00:07:52,260 --> 00:07:54,760
Затем присваиваем ему значения.

112
00:07:54,760 --> 00:07:59,770
В поле item — строку, которую 
хотим вставить в начало списка

113
00:07:59,770 --> 00:08:01,440
В этом случае "not".

114
00:08:01,440 --> 00:08:04,500
И в поле next вставим указатель oldfirst,

115
00:08:04,500 --> 00:08:06,590
который теперь второй элемент списка.

116
00:08:06,590 --> 00:08:10,400
Так после этой операции,
"first" указывает на начало списка.

117
00:08:10,400 --> 00:08:14,130
Элементы списка расположены в обратном

118
00:08:14,130 --> 00:08:15,560
порядке относительно
их добавления в стек.

119
00:08:16,880 --> 00:08:23,020
Эти 4 строки реализуют
стековую операцию push().

120
00:08:23,020 --> 00:08:27,970
Итак, вот полная реализация
на базе связного списка

121
00:08:27,970 --> 00:08:34,310
всего кода для реализации
стека строк в Java.

122
00:08:34,310 --> 00:08:39,590
В этом классе конструктор ничего
не делает, поэтому его нет.

123
00:08:40,670 --> 00:08:47,700
Вот внутренний класс, который мы
используем для элементов списка.

124
00:08:47,700 --> 00:08:53,140
Делаем его внутренним,
чтобы ссылаться напрямую на него.

125
00:08:53,140 --> 00:08:58,058
И тогда единственной переменной
стека является ссылка

126
00:08:58,058 --> 00:09:02,421
на первый узел в списке,
и она на старте равна null.

127
00:09:02,421 --> 00:09:09,964
Тогда isEmpty просто
проверка first на null.

128
00:09:09,964 --> 00:09:15,452
Push — это четыре строки
кода, которые я уже показывал,

129
00:09:15,452 --> 00:09:21,140
pop — это 3 строки кода,
которые были даны раньше.

130
00:09:21,140 --> 00:09:25,290
Это полный код односвязного списка,
который является

131
00:09:25,290 --> 00:09:28,940
хорошей реализацией спускающегося списка
для любого клиента.

132
00:09:30,120 --> 00:09:35,070
Можно проанализировать алгоритм
и предоставить информацию

133
00:09:35,070 --> 00:09:40,710
о его быстродействии клиентам.

134
00:09:40,710 --> 00:09:41,900
В этом случае

135
00:09:41,900 --> 00:09:47,030
видно, что каждая операция
в худшем случае тратит постоянное время.

136
00:09:47,030 --> 00:09:49,720
Всего несколько инструкций
 для каждой из операций.

137
00:09:49,720 --> 00:09:50,420
Тут нет циклов.

138
00:09:51,610 --> 00:09:54,610
Это, очевидно,
весьма желательная характеристика.

139
00:09:55,710 --> 00:09:57,920
Что насчет памяти?

140
00:09:59,140 --> 00:10:02,720
Зависит от реализации и компьютера,

141
00:10:02,720 --> 00:10:08,330
здесь проанализирована
типичная java реализация.

142
00:10:08,330 --> 00:10:10,393
Вы можете проверить её

143
00:10:10,393 --> 00:10:15,617
для различных сред выполнения,
так что она показательна.

144
00:10:15,617 --> 00:10:19,305
Для каждого объекта в Java

145
00:10:19,305 --> 00:10:23,407
16 байт идет на заголовок.

146
00:10:23,407 --> 00:10:27,615
Дополнительно 8 байт,
потому что это внутренний класс.

147
00:10:27,615 --> 00:10:32,408
В классе Node есть
2 встроенные ссылки:

148
00:10:32,408 --> 00:10:37,740
одна на строку, другая на узел,
каждая из них — 8 байт.

149
00:10:37,740 --> 00:10:40,810
Итак 40 байт для записи стека.

150
00:10:40,810 --> 00:10:44,600
Если у нас есть стек размером N, 
он займет 40 N байт.

151
00:10:44,600 --> 00:10:48,320
Ещё немного занимает first элемент,
это около N

152
00:10:48,320 --> 00:10:49,050
для целого стека.

153
00:10:49,050 --> 00:10:55,130
При большом N значение 40*N
точно оценивает требуемую память.

154
00:10:55,130 --> 00:10:56,620
Оно не учитывает место

155
00:10:56,620 --> 00:11:00,370
для самих строк внутри клиента.

156
00:11:00,370 --> 00:11:04,290
Но с этим мы можем правильно оценить

157
00:11:04,290 --> 00:11:08,300
затраты ресурсов реализацией
для различных клиентских программ.

158
00:11:10,090 --> 00:11:15,290
Время постоянное,
но есть и более быстрые реализации стека.

159
00:11:15,290 --> 00:11:20,650
Если стек используется
во внутренних циклах неких алгоритмов,

160
00:11:20,650 --> 00:11:25,350
то важно поискать
более быстрые реализации.

161
00:11:25,350 --> 00:11:29,600
Другой способ реализации стека —
 это использование массива

162
00:11:29,600 --> 00:11:31,810
для хранения элементов.
Посмотрим на него.

163
00:11:33,380 --> 00:11:37,470
Выбор между связанными структурами

164
00:11:37,470 --> 00:11:40,380
и массивами является фундаментальным
и будет возникать снова

165
00:11:40,380 --> 00:11:45,390
и снова при разборе более продвинутых
структур данных и алгоритмов.

166
00:11:45,390 --> 00:11:49,650
Рассмотрим массив применительно к стеку,

167
00:11:49,650 --> 00:11:54,150
чтобы быть готовыми к более продвинутым
приложениям в дальнейшем.

168
00:11:55,920 --> 00:12:01,325
При использовании массива,
 мы просто держим N элементов стека в массиве.

169
00:12:02,435 --> 00:12:07,425
И позиция массива c индексом N —
 это место расположения

170
00:12:07,425 --> 00:12:10,745
вершины стека, куда должен быть
помещен следующий элемент.

171
00:12:10,745 --> 00:12:16,455
Таким образом, для push(),
 мы просто добавляем новый элемент в s[N].

172
00:12:16,455 --> 00:12:21,075
А для pop() удаляем элемент s[N-1]
и уменьшаем N.

173
00:12:22,460 --> 00:12:26,000
Есть большой минус
при использовании массива —

174
00:12:26,000 --> 00:12:31,210
его размер должен быть объявлен заранее,

175
00:12:31,210 --> 00:12:34,070
значит стек имеет
ограниченную вместимость.

176
00:12:34,070 --> 00:12:37,650
С этим придется считаться,
если количество элементов

177
00:12:37,650 --> 00:12:39,390
стека превышает размеры массива.

178
00:12:39,390 --> 00:12:43,320
Это фундаментальная проблема,
с которой приходится иметь дело

179
00:12:43,320 --> 00:12:48,320
при любых структурах данных алгоритмов.

180
00:12:48,320 --> 00:12:53,920
В данном простом примере это окупится.

181
00:12:55,980 --> 00:13:03,530
Итак, вот полная реализация стека,
 использующая массив для представления структуры стека.

182
00:13:03,530 --> 00:13:08,690
Здесь переменная экземпляра,
представляющая собой массив строк.

183
00:13:08,690 --> 00:13:12,490
А также наша переменная N,
 которая представляет собой как размер стека,

184
00:13:12,490 --> 00:13:17,000
так и индекс следующей свободной позиции.

185
00:13:18,430 --> 00:13:23,530
У этого класса есть конструктор.
Он создает массив.

186
00:13:23,530 --> 00:13:26,940
Здесь мы немного сжульничали
для упрощения,

187
00:13:26,940 --> 00:13:29,290
займемся этим позже.

188
00:13:29,290 --> 00:13:34,170
Обман состоит в требовании
указывать размер стека.

189
00:13:34,170 --> 00:13:37,350
Это нормально для некоторых приложений,

190
00:13:37,350 --> 00:13:41,740
но слишком обременительно
для многих других.

191
00:13:41,740 --> 00:13:44,130
Клиент не знает размеров стека.

192
00:13:44,130 --> 00:13:48,540
Ему может потребоваться
множество стеков одновременно.

193
00:13:48,540 --> 00:13:52,110
Они могут достичь максимальной вместимости

194
00:13:52,110 --> 00:13:53,040
в разное время.

195
00:13:53,040 --> 00:13:56,540
Нужно избавиться от такого требования,
 и мы это сделаем.

196
00:13:56,540 --> 00:14:01,870
Но, код становится почти тривиальным,
 если мы явно используем вместимость.

197
00:14:01,870 --> 00:14:04,390
Для проверки на пустоту мы проверяем,
равен ли N нулю.

198
00:14:04,390 --> 00:14:08,720
Для размещения элемента
используем N как индекс массива,

199
00:14:08,720 --> 00:14:10,580
помещаем туда элемент и увеличиваем N.

200
00:14:10,580 --> 00:14:15,380
Вот это, N++, используется
во многих языках программирования как сокращение

201
00:14:15,380 --> 00:14:17,650
для "используй индекс и увеличь его на 1".

202
00:14:17,650 --> 00:14:20,140
А для pop() мы уменьшаем индекс,

203
00:14:20,140 --> 00:14:23,020
затем используем его
для возврата элемента массива.

204
00:14:23,020 --> 00:14:26,580
Таким образом, каждая из операций
является однострочной.

205
00:14:26,580 --> 00:14:30,035
Это прекрасная реализация
для некоторых клиентов.

206
00:14:30,035 --> 00:14:32,475
Это реализация стека с помощью массива,

207
00:14:32,475 --> 00:14:36,575
но она ломает API, требуя от клиента
указания вместимости стека.

208
00:14:37,875 --> 00:14:39,835
Итак, что с этим делать?

209
00:14:39,835 --> 00:14:42,765
Есть пара вещей,
которые мы не рассмотрели.

210
00:14:42,765 --> 00:14:46,505
Мы не написали кода для выброса исключения,
если клиент

211
00:14:46,505 --> 00:14:48,045
пытается извлечь элемент из пустого стека.

212
00:14:48,045 --> 00:14:50,000
Вероятно, следует это сделать.

213
00:14:50,000 --> 00:14:54,150
А что случится, если клиент поместит
слишком много элементов?

214
00:14:54,150 --> 00:14:57,570
Поговорим об изменении размера,

215
00:14:57,570 --> 00:15:01,380
которое позволяет избежать переполнения.

216
00:15:03,710 --> 00:15:06,600
Вопрос ещё в том,

217
00:15:06,600 --> 00:15:11,770
могут ли клиенты вставлять null 
элементы в структуру данных.

218
00:15:11,770 --> 00:15:15,810
В данном случае мы это позволяем.

219
00:15:15,810 --> 00:15:21,505
Но нужно позаботиться
о проблеме лойтеринга,

220
00:15:21,505 --> 00:15:26,900
когда в массиве хранится ссылка на объект,

221
00:15:26,900 --> 00:15:32,080
который на самом деле не используется.

222
00:15:32,080 --> 00:15:35,110
Когда мы удаляем значение стека,

223
00:15:35,110 --> 00:15:39,990
то в массиве остается ссылка на него.

224
00:15:39,990 --> 00:15:43,350
Мы знаем, что больше не используем его,
 а Java нет.

225
00:15:44,470 --> 00:15:51,201
Для более эффективного
использования памяти

226
00:15:51,201 --> 00:15:57,040
нужно устанавливать
удаленные элементы в Null.

227
00:15:57,040 --> 00:16:01,800
Так, чтобы не оставалось ссылок
 на старые элементы, и сборщик мусора

228
00:16:01,800 --> 00:16:06,730
мог освободить память, так как
на неё больше никто не ссылается.

229
00:16:06,730 --> 00:16:13,640
Это деталь,
но для максимально эффективного

230
00:16:13,640 --> 00:16:17,332
использования памяти
необходимо это

231
00:16:17,332 --> 00:16:24,346
учесть.