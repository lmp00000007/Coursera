1
00:00:01,010 --> 00:00:06,509
Java が提供する、もう一つの便利な機能があります。とてもエレガントで

2
00:00:06,509 --> 00:00:11,759
簡潔なコードが書けます。基本データ型に、ぜひ付け加える価値のあるもので、

3
00:00:11,759 --> 00:00:17,058
それはイテレーションです。それについてお話します。やりたいことは、

4
00:00:17,058 --> 00:00:23,176
クライアントがコレクション内の要素を一つ一つ取り出せるようにすることです。

5
00:00:23,364 --> 00:00:28,286
とはいっても、クライアントには、配列が連結リストのどちらを使っているかとか、

6
00:00:28,286 --> 00:00:34,620
見せない内部構造はなんであれ、知らせません。クライアントには関係ない事です。

7
00:00:34,620 --> 00:00:41,189
多くのクライアントは、単にコレクション内の中身を一つづつ取り出せればよいだけです。

8
00:00:41,189 --> 00:00:47,304
Java にはイテレーションと呼ばれる良い解決策があります。

9
00:00:47,304 --> 00:00:53,523
これから行なうことは、スタック、キュー、今後検討するデータ構造に

10
00:00:53,523 --> 00:00:58,914
どうやって Iterable と呼ばれるインターフェイスを実現するかです。

11
00:00:59,108 --> 00:01:05,662
それにより施した実装に関係なく、クライアントのコードで使えます。

12
00:01:05,662 --> 00:01:13,497
詳細を見てみましょう。Iterable とは何でしょうか？ Iterable は Java の用語で

13
00:01:13,497 --> 00:01:20,914
Iterator を返すメゾッドを持つクラスであることを指します。

14
00:01:21,182 --> 00:01:29,271
Iterator とは何でしょうか？ Iterator とはクラスで、hasNext() と

15
00:01:29,271 --> 00:01:37,519
next() メゾッドを持ちます。Java では remove() もありますが、これは粗悪なものだと思います。

16
00:01:37,519 --> 00:01:45,861
このメゾッドは使いません。深刻なバグを起こしやすくデバッグも大変です。というわけで hasNext() と

17
00:01:45,861 --> 00:01:52,828
next() です。データ構造を Iterable にするべく、これらを実装して行きましょう。

18
00:01:52,828 --> 00:01:58,837
持ち運ぶ荷物が多そうな感じに思えますし、なぜわざわざ

19
00:01:58,837 --> 00:02:04,768
そんなことをするかというと、データ構造が Iterable であれば

20
00:02:04,768 --> 00:02:10,795
Java においては、クライアントはとても簡潔でエレガントなコードが書けます。

21
00:02:10,795 --> 00:02:16,185
for-each 記法と呼ばれるもので、スタックを扱うとすると for (String s : stack) で

22
00:02:16,185 --> 00:02:22,587
このコードは、スタックから一つづつ文字列を取り出して表示させています。

23
00:02:22,587 --> 00:02:29,442
もしそのような機能がないとしたら、Iterator 使う際は、なんとか

24
00:02:29,442 --> 00:02:35,550
この長たらしいコードを書けばよいことですが、もう誰もそんなことはしません。

25
00:02:35,550 --> 00:02:42,710
なぜなら短縮表記のコードも同じものですから。もしくは、このイテレーションのためだけに

26
00:02:42,710 --> 00:02:48,386
たくさんの push や pop を書くことになりかねません。鍵となるのは

27
00:02:48,386 --> 00:02:53,928
データ構造での要素の取り出しのためのクライアントコードを簡潔にすることなので、

28
00:02:53,928 --> 00:02:59,370
基本データ構造にはイテレーションの機能を与えようと思います。

29
00:02:59,370 --> 00:03:05,712
さほど難しくありませんし、やる価値は明らかにあります。

30
00:03:05,712 --> 00:03:12,877
それで、連結リストだとこんな感じです。Iterable を実装とは言っても

31
00:03:12,877 --> 00:03:19,470
どういう意味でしょうか？それは iterator() というイテレータを返す

32
00:03:19,470 --> 00:03:25,017
メゾッドを持っているということです。我々は内部クラスを使います。

33
00:03:25,017 --> 00:03:30,926
このケースでは、ListIterator としていますが、これが  Iterator を実装しています。

34
00:03:30,926 --> 00:03:36,498
ジェネリクスですね。基本的にやるべき事は、これらのメゾッド、

35
00:03:36,498 --> 00:03:42,158
hasNext()  と next() の実装です。意味は名前でわかりますね。hasNext() は

36
00:03:42,365 --> 00:03:47,917
完了していれば false、完了していなければ true を返しそうです。

37
00:03:47,917 --> 00:03:53,462
next() は繰り返し次の要素を与えてくれそうですね。

38
00:03:53,462 --> 00:03:58,973
そして連結リストということで、まず first から見ていきます。

39
00:03:58,973 --> 00:04:04,896
それはリスト内先頭要素ですね。このイテレータ内のインスタンス変数 current で

40
00:04:04,896 --> 00:04:10,461
取り出し中の現在位置を管理します。

41
00:04:10,461 --> 00:04:15,439
次の要素を得る、すなわち first を取り出すためには、現在位置の要素を抜き出して、

42
00:04:15,439 --> 00:04:21,073
現在位置の参照を進めた後、要素を返します。current を次に移動しています。

43
00:04:21,073 --> 00:04:27,483
先にコード例で見せた通り、クライアントは hasNext() を常にチェックします。

44
00:04:27,483 --> 00:04:35,069
NULL になったら、取り出し終端の意味で false が返ります。

45
00:04:35,069 --> 00:04:41,084
とはいえ、ここまでのイテレーション実装で注力しているのは、

46
00:04:41,084 --> 00:04:47,952
next() と hasNext() の実装に関してのみで、単にインスタンス変数を使っているだけです。

47
00:04:47,952 --> 00:04:54,457
おそらく、エラーを考慮したコードを書かなければなりません。

48
00:04:54,457 --> 00:05:01,339
要素が無いのに next() を呼んだら例外を投げる必要があります。remove() は常にですね。

49
00:05:01,339 --> 00:05:07,326
remove() はサポートしませんので。配列の場合はもっと簡単です。

50
00:05:07,326 --> 00:05:13,041
イテレータにおいて、どの順番でも要素を走査できますので、

51
00:05:13,041 --> 00:05:18,834
意味的な面とデータ構造に合わせて考えましょう。おそらくスタックであれば、

52
00:05:18,834 --> 00:05:24,504
スタックにあるものは、スタックが返す順番で得たいですよね。

53
00:05:24,504 --> 00:05:31,686
ですから配列なら逆順です。このケースでは next() は配列インデックスを一つ減らして、

54
00:05:31,686 --> 00:05:37,522
次の要素を返すだけです。このインスタンス変数は配列インデックスです。hasNext() は

55
00:05:37,522 --> 00:05:48,052
それが正の値なら真です。このイテレーション機能を提供する Java コードは [cough] この程度ですが、

56
00:05:48,052 --> 00:05:55,229
実体としてはこの内部にあります。することは多くはありません。

57
00:05:55,229 --> 00:06:02,108
あなた自身のデータ型でも、どうやって実装すれば良いか確認できますし、このやり方を

58
00:06:02,108 --> 00:06:07,873
これから取り組んでいくコレクション系の基本データ型で模範にしていきましょう。

59
00:06:07,873 --> 00:06:14,633
いいでしょう。実のところ、多くのクライアントで該当しますが、

60
00:06:14,633 --> 00:06:20,905
要素を取り出す順番はどうでもよかったりします。頻繁にやることは

61
00:06:20,905 --> 00:06:27,275
コレクションに要素を追加して、そして後になって、持っていた要素を

62
00:06:27,275 --> 00:06:34,410
取り出すだけです。このデータ構造はバッグと呼ばれます。

63
00:06:34,410 --> 00:06:40,680
API を見てみましょう。取り出し順は気にしません。やりたい事は

64
00:06:40,913 --> 00:06:47,303
要素を追加することです。サイズも知りたいですね、そしてバッグ内の全ての要素を取り出したい。

65
00:06:47,303 --> 00:06:53,986
より簡素な API ですが、それでも主要なコレクション操作を

66
00:06:53,986 --> 00:07:00,370
わずかながら網羅していますので、使っていきましょう。

67
00:07:00,370 --> 00:07:06,512
すでに実装はご存知ですね。スタックから pop を削除、あるいはキューから

68
00:07:09,792 --> 00:07:13,072
dequeue を削除するだけです。[cough]  使いやすいデータ構造の実装がつかめましたね。