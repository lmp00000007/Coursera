Als nächstes werden wir kurz Implementierungen von Queues (Warteschlangen) betrachten, indem wir die gleichen zugrundeliegenden Datenstrukturen nutzen. Hier ist die zugehörige API für eine Queue aus Strings, es ist die gleiche wie für Stacks, nur die Namen sind unterschiedlich. Statt "push" haben wir "enqueue", statt "pop" haben wir "dequeue". Und die Semantik ist anders für Enqueue, wir fügen ein Element am Ende der Schlange an und bei Dequeue nehmen wir es am Anfang der Schlange weg. Es ist etwa so wie in einer Warteschlange für einen Fahrkartenkauf. Wenn man sich hinten anstellt, ist man am Ende der Schlange und der, der am längsten ansteht, kommt dran. Also sehen wir uns an, wie wir das implementieren, erst mit einer verketteten Liste und dann mit Feldern. Hier ist also unsere Darstellung mit einer verketteten Liste, wir brauchen zwei Zeigerreferenzen. Eine auf das erste Element in der Liste und eine auf das letzte Element. Wenn wir etwas einfügen, hängen wir das Element ans Ende der Liste statt an den Anfang und wenn wir ein Element  entfernen, machen wir das Gleiche und nehmen es am Anfang weg. Hier ist also die Implementierung von Dequeue. Sie ist identisch zum Code für Pop bei einem Stack. Wir speichern das Element, entfernen den ersten Knoten, indem wir die Referenz um ein Element weiterrücken und dann geben wir das Element zurück, also gleich. Um einen Knoten hinzuzufügen, also Enqueue, wollen wir ihn ans Ende der verketteten Liste setzen, so dass er der letzte ist, der zurückgegeben wird. Um ihn also ans Ende zu setzen, brauchen wir zuerst eine Verkettung mit dem letzten Knoten, und zwar weil wir die Referenz auf den letzten Knoten im neuen Knoten speichern werden. Dann erzeugen wir einen neuen Knoten für das Ende der Liste, befüllen seine Felder und dann wird der alte Zeiger von Null auf den neuen Knoten gesetzt. Also auch nur ein paar Zeilen Code. Das ist das grundsätzliche Verkettete-Listen-Vorgehen. Vor Jahren dachten wir tatsächlich, dass Kurse in Algorithmen und Datenstrukturen so wie dieser vor allem von dieser Art Zeigermanipulation handeln würden, aber heutzutage geht es da nur um ein paar Implementierungen wie Stack und Queue und ein paar andere fundamentale Datenstrukturen. Wir werden also nicht viel mehr Programme brauchen, um eine verkettete Liste zu manipulieren. Wir kapseln sie in Basisdatentypen so wie diesen. Also gehen wir zurück zu unserer Implementierung und das soll nur noch einmal den Code der vorhergehenden Bilder zeigen, aber auch Spezialfälle behandeln, wie den einer leeren Warteschlange oder dass wir bei einer Warteschlange, die nach der Entfernung eines Elements leer ist, den Zeiger "last" auf null setzen und sicherstellen, dass "first" und "last" immer so sind, wie wir es wollen. Diese Details sind leicht zu prüfen. Was ist nun mit Feldern? Wir werden hier nicht die Details behandeln, aber es ist nicht schwierig, Warteschlangen zu implementieren, indem man Felder in der Größe verändert, nicht schwierig, aber definitiv eine verzwickte Programmierübung, die gerne versucht werden kann. Wir haben also zwei Zeiger. Es gibt das erste Element in der Schlange und das Ende, das die Position für das nächste Element ist. Für "Enqueue" hängen wir also ein Element an das Ende an und für "Dequeue" nehmen wir eins am Anfang weg. Und der Trick ist, dass wenn man über die Länge des Feldes hinauskommt, man auf 0 zurücksetzt und das ist ein bisschen Extracode, und dann muss man die Veränderung der Feldgröße ebenfalls implementieren, genau wie beim Stack. Das werden wir als Übung lassen.