1
00:00:01,062 --> 00:00:07,022
さて、これまでのものはいわゆる基本のデータ型や実装で、

2
00:00:07,022 --> 00:00:13,011
初歩的で簡単すぎるように思えます。ですが、実際に大変洗練された

3
00:00:13,011 --> 00:00:18,085
これらの基本コンセプトに沿ったアプリケーションを得られるのです。それを考えるのが次のステップです。

4
00:00:18,085 --> 00:00:27,076
では、最初に言っておきますが、我々が実装するデータ型やデータ構造の類いは、

5
00:00:27,076 --> 00:00:33,668
Java ライブラリ内に存在します。多くのプロラミング環境でもそのことが言えます。

6
00:00:33,898 --> 00:00:40,698
例えば、スタックとキューはその用語そのままで、

7
00:00:40,698 --> 00:00:46,728
Java ライブラリ内に見つけられます。Java コレクションライブラリというものがあり、

8
00:00:46,926 --> 00:00:53,203
お見せするのは List インターフェイスと呼ばれるものです。Java は連続要素のための一般 API を持っていて、

9
00:00:53,203 --> 00:01:00,099
終端への追加や、先頭位置からの削除等々があります。

10
00:01:00,099 --> 00:01:07,611
可変長配列を使ったものがありますね、我々が考える原理と多く絡みます。

11
00:01:07,867 --> 00:01:15,075
連結リストのインターフェイスもそうですね。ではなぜ単にそれらを使わないのでしょうか？

12
00:01:15,075 --> 00:01:22,901
なぜ自分で実装したものを使うのでしょう？問題はライブラリのコードにあり、

13
00:01:22,901 --> 00:01:32,367
委員会が決めたような作りで、継ぎ足しで操作が加えられ、

14
00:01:32,367 --> 00:01:39,679
API は広大で膨れ上がっています。同じ API に様々な操作があるのは

15
00:01:39,679 --> 00:01:47,019
良いアイデアではありません。のちほど例をみましょう。

16
00:01:47,019 --> 00:01:53,427
本当の問題は、そういうものを使う時に、あなた自身が性能について詳しくわからない、

17
00:01:53,427 --> 00:02:01,347
または想定できないという点です。ちょっとしたクライアントでも

18
00:02:01,347 --> 00:02:06,949
どの程度のパフォーマンスなのかすぐに明らかにできます。

19
00:02:06,949 --> 00:02:12,918
推奨する一番のやり方は、使う基本のデータ構造の数は絞って、

20
00:02:12,918 --> 00:02:18,467
やることもシンプルして、実装についても、これまでに我々が

21
00:02:18,467 --> 00:02:24,233
これらの基本データ構造に対して議論してきたものを採用することです。

22
00:02:24,813 --> 00:02:30,745
後々になって、自分が何をしているのかわかっている経験豊かなプログラマは

23
00:02:30,745 --> 00:02:36,767
これらのライブラリを効率よく使えるかもしれません。しかし経験の浅いプログラマは

24
00:02:36,767 --> 00:02:43,793
しばしば問題を抱えることがあります。これは、生徒のプログラム課題で

25
00:02:43,793 --> 00:02:50,211
起こった話です。そんなに昔のことではありません。パーコレーションで

26
00:02:50,211 --> 00:02:55,969
ランダムに通過枠を作って行く課題がありますが、ある生徒は注意深く話を聞き

27
00:02:55,969 --> 00:03:01,677
配列をつかってインデックスをランダムに選択して、

28
00:03:01,863 --> 00:03:07,737
空きかどうかをチェックして、それを繰り返しました。配列サイズは N 対 N なので

29
00:03:07,737 --> 00:03:13,955
N^2 ですね。N^2 の時間がかかります。このアプリケーションでは比例時間で済みます。

30
00:03:13,955 --> 00:03:20,113
しかし、もう一方の生徒は、以前に Java の経験があって

31
00:03:20,113 --> 00:03:25,247
自分をエキスパートだと思っており、連結リストを使うと言いました。

32
00:03:25,437 --> 00:03:31,615
Java ライブラリが使えるんだから、そんな間抜けなコードはダウンロードしてられない。

33
00:03:31,615 --> 00:03:38,121
それを使ってインデックスをランダムに取り出して削除するだけだと。

34
00:03:38,345 --> 00:03:44,094
そのプログラムは二乗時間がかかりました。みじめなケニーは

35
00:03:44,094 --> 00:03:50,806
膨大なインスタンスのためにプログラムを実行してみた時に、処理が終わらないことに気付きました。

36
00:03:50,806 --> 00:03:59,050
理由は、Java の連結リストの実装は、要素の取得に比例時間がかかります。

37
00:03:59,050 --> 00:04:06,456
配列のように定数時間ではありません。ケニーにとっては

38
00:04:06,456 --> 00:04:12,800
そう考える事が難しく、実装から情報を得ることも難しく、

39
00:04:12,800 --> 00:04:19,055
そういうわけで、とても遅いプログラムになるのです。

40
00:04:19,055 --> 00:04:25,623
スイスアーミーナイフな実装、すなわち出来る事が多すぎると、

41
00:04:25,623 --> 00:04:30,682
クライアント側の操作で求められる物が、効率よく実装されているかを知る事は困難です。

42
00:04:30,953 --> 00:04:38,444
そういうわけで、本コースの方針は、生徒はライブラリは使うべきではない。

43
00:04:38,444 --> 00:04:44,551
すでに授業で実装するまでは。最低限、あなたが

44
00:04:44,551 --> 00:04:50,546
性能の特徴を理解していることの証です。それでは、スタックのアプリケーションをいくつか見てみましょう。

45
00:04:50,546 --> 00:04:56,976
スタックはまさにコンピュータ処理の根幹をなすものです。

46
00:04:56,976 --> 00:05:03,716
再帰処理を実装したりとか、頻繁にスタックを使います。

47
00:05:03,716 --> 00:05:09,860
Web ブラウザの「戻る」ボタンを使う時は、元いた場所を

48
00:05:09,860 --> 00:05:16,496
スタックに保存します。では二つの例を見てみましょう。

49
00:05:16,496 --> 00:05:22,377
一つはプログラムのコンパイルや実際の処理への置換えをどう扱うか、

50
00:05:22,377 --> 00:05:28,544
もう一つは、PostScript 言語です。印刷や出版関連で

51
00:05:28,544 --> 00:05:35,249
広く使われています。では、コンパイラの実装について、

52
00:05:35,249 --> 00:05:41,524
関数でスタックを使っています。関数コール時に、すべての

53
00:05:41,524 --> 00:05:48,198
ローカル領域が push されます。戻り先アドレスと合わせて。そして

54
00:05:48,198 --> 00:05:53,623
関数から戻る際は、戻り先アドレスとローカル領域を pop します。

55
00:05:53,623 --> 00:05:58,917
スタックがすべての情報を持っているわけです。関数が自らを

56
00:05:58,917 --> 00:06:04,119
呼んでいるかどうかは関係ありません。スタックは再帰も含まれます。

57
00:06:04,119 --> 00:06:09,929
事実上、明示的にスタックを使えば、再帰プログラムを再帰なしにすることもできます。

58
00:06:09,929 --> 00:06:16,011
gcd 関数があるとして、最大公約数を求めるものです。

59
00:06:16,011 --> 00:06:23,402
p と q の最大公約数は、q  と p を q で割った余りの最大公約数です。

60
00:06:23,402 --> 00:06:30,425
q がゼロになるまで繰り返すだけです。この図がまとめているように、

61
00:06:30,425 --> 00:06:37,849
スタックに情報を保存するだけです。では、具体例で見ましょう。

62
00:06:38,087 --> 00:06:47,568
この点をうまく見せて、同じコードであらゆるデータを処理できるやり方を

63
00:06:47,568 --> 00:06:53,472
示しています。この例は、ダイクストラの 2-stack アルゴリズムで

64
00:06:53,472 --> 00:06:58,576
計算式を評価します。目標は、計算式があるとして

65
00:06:58,576 --> 00:07:03,601
まさにプログラムの元になるものです。

66
00:07:03,601 --> 00:07:08,398
話を進めましょう。計算式ですね。

67
00:07:08,398 --> 00:07:13,936
オペランドと演算子があって、それを評価したい。

68
00:07:13,936 --> 00:07:19,897
ダイクストラのアルゴリズムはとても簡単な表現です。

69
00:07:19,897 --> 00:07:25,485
左から右に処理していきます。値なら加えます。

70
00:07:25,485 --> 00:07:31,232
二つのスタックを使って、値であれば値のスタックに追加して、

71
00:07:31,232 --> 00:07:37,117
演算子であれば演算子のスタックに追加します。左の括弧は無視します。

72
00:07:37,117 --> 00:07:43,584
右括弧なら演算子と二つの値を pop して、結果を push します。

73
00:07:43,584 --> 00:07:51,334
あれこれ言いましたがデモを見ましょう。空の値スタックと

74
00:07:51,334 --> 00:07:57,476
演算子スタックから始めます。左から右に見ていきます。

75
00:07:57,703 --> 00:08:04,319
必要な場合に思い出せるように、上に４つの手順を要約しています。

76
00:08:04,319 --> 00:08:09,608
左括弧は無視して、値は値スタックに追加します。

77
00:08:09,608 --> 00:08:14,985
ですので 1 は値スタックに入れます。演算子は演算子スタックに追加します。

78
00:08:14,985 --> 00:08:20,066
+ は演算子スタックに入れます。左括弧は無視します。

79
00:08:20,066 --> 00:08:24,568
括弧を無視するのは不思議に思えますが、すぐにその理由は分かります。

80
00:08:24,568 --> 00:08:29,677
値は値スタックに追加します。演算子は演算子スタックに追加します。

81
00:08:29,677 --> 00:08:35,062
なんだかスタックに追加してばかりですね。そして右括弧に来ました。

82
00:08:35,062 --> 00:08:40,322
ここで面白いことが起こります。つまり

83
00:08:40,322 --> 00:08:45,573
最優先順位の演算子と値を持っていて、それがやりたい事です。

84
00:08:45,573 --> 00:08:52,136
演算子を値に適用して、その結果を値スタックに戻します。

85
00:08:52,136 --> 00:08:57,758
二つの値を取り出して、演算を行なって

86
00:08:57,758 --> 00:09:05,024
それを値スタックに戻します。それが右括弧でやることです。

87
00:09:05,024 --> 00:09:14,720
続けましょう。* を追加します。左括弧は無視、4 を追加、そして * 。

88
00:09:14,991 --> 00:09:21,088
5 を値スタックに追加します。スタックにたくさん入っていますね。

89
00:09:21,088 --> 00:09:25,971
右括弧が残っていますので、計算を終わらせましょう。

90
00:09:25,971 --> 00:09:30,530
先頭の二つの値をスタックから取り出して、先頭の演算子を演算子スタックから取り出して

91
00:09:30,530 --> 00:09:35,400
計算して、結果を値スタックに戻します。さらに右括弧で

92
00:09:35,400 --> 00:09:40,392
先頭の二つの値を取り出します。計算します。その値を値スタックに戻します。

93
00:09:40,392 --> 00:09:45,696
そしてついに、最後の右括弧です。

94
00:09:45,696 --> 00:09:51,508
二つの値を値スタックから取り出して、演算子を演算子スタックから取り出して、

95
00:09:51,508 --> 00:09:56,874
計算して、結果を値スタックに戻す。これで計算が終わりました。

96
00:09:56,874 --> 00:10:06,352
これが結果です。計算結果は

97
00:10:06,352 --> 00:10:19,447
101 です。よろしいですか？これがダイクストラの 2-stack アルゴリズムを実装したコードです。

98
00:10:19,737 --> 00:10:26,915
二つの異なるスタックがあります。演算子スタックは String 型で

99
00:10:26,915 --> 00:10:32,962
演算子の記号だけです。値スタックは Double 型です。

100
00:10:32,962 --> 00:10:39,034
同じコードのスタックですがジェネリクスを使っています。

101
00:10:39,034 --> 00:10:44,492
二つの異なるデータ型を使っています。それからダイクストラのアルゴリズムを走らせます。

102
00:10:44,492 --> 00:10:50,397
読み込んだ文字が左括弧なら何もしません。

103
00:10:50,397 --> 00:10:57,089
プラスまたは倍記号なら push します。右括弧なら次にすすんで

104
00:10:57,089 --> 00:11:05,216
演算子を pop します。+ 記号なら値スタックの先頭の二つの値を加算し、

105
00:11:05,216 --> 00:11:13,757
* 記号なら、スタックの先頭の二つの値を乗算します。

106
00:11:13,757 --> 00:11:20,392
そして結果を push します。そして終わったら、スタックにある値を表示するだけです。

107
00:11:20,392 --> 00:11:26,749
計算式にスタックを使った、明瞭でエレガントな実装です。

108
00:11:26,749 --> 00:11:33,027
他のデータ型でも簡単に拡張できます。

109
00:11:33,027 --> 00:11:40,754
なぜこれがうまくいくのでしょうか？アルゴリズムが演算子に出会った時、

110
00:11:40,754 --> 00:11:46,910
言うならば、その内部に、括弧、値、演算子、値、括弧とあるわけです。

111
00:11:47,125 --> 00:11:53,697
括弧内で起こる事を、スタックに積むと捉えるとわかりやすいですね。

112
00:11:53,697 --> 00:11:59,647
中身はともかく、2 と 3 を値スタックに加えて、

113
00:11:59,647 --> 00:12:05,534
プラスを演算子スタックに加えて、右括弧になったら

114
00:12:05,534 --> 00:12:11,089
演算を行なうことになります。そして続行します。あたかも

115
00:12:11,089 --> 00:12:17,064
元から値が置き換えた場所にあったかのように。

116
00:12:17,064 --> 00:12:23,314
括弧で括られた全ての演算に対して内側から見ていくだけです。

117
00:12:23,314 --> 00:12:29,169
元の式が (1 + 5 * 20) であるかのように、繰り返すだけです。

118
00:12:29,169 --> 00:12:34,981
それからもう一度、 1 + 100 に置き換えて、101 になります。

119
00:12:34,981 --> 00:12:41,487
以上が、ダイクストラのアルゴリズムが動く理由です。なぜ動くか理解するのはそれなりに簡単ですよね。

120
00:12:41,487 --> 00:12:48,066
さらに進んで、このアルゴリズムを拡張して、対数関数や

121
00:12:48,066 --> 00:12:54,376
サイン関数、その他の演算子を加えて、優先順位を持たせたり

122
00:12:54,376 --> 00:13:01,602
それらを連携させて複数演算を行なったり等々できます。

123
00:13:01,845 --> 00:13:08,720
以上は、実際にコンパイラ開発において通る道であり、プログラムを

124
00:13:08,720 --> 00:13:16,585
言語表現から計算処理に変換する方法の一つです。スタックを使うダイクストラのアルゴリズムは、

125
00:13:16,948 --> 00:13:25,072
計算処理の基礎を知り、理解する一つの方法です。