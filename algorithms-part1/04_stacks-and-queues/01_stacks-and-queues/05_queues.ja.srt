1
00:00:01,086 --> 00:00:07,708
では次は、キューの実装を手短に考えてみましょう。同じように

2
00:00:07,708 --> 00:00:13,663
基本的なデータ構造です。これが文字列のキューに対応する API です。

3
00:00:13,890 --> 00:00:19,964
スタックの API と同じようなものですが、命名が異なっています。

4
00:00:20,162 --> 00:00:25,926
push の代わりに enqueue、pop の代わりに dequeue を用います。

5
00:00:25,926 --> 00:00:32,201
意味も異なります。enqueue ではキューの終端に要素を追加することを指し、

6
00:00:32,390 --> 00:00:38,301
dequeue は先頭から要素を削除します。チケットを買うために列に並んでるような感じです。

7
00:00:38,512 --> 00:00:44,758
enqueue 時点で、列の一番最後にいます。そこにいるときは

8
00:00:44,758 --> 00:00:50,892
出るまでに一番長く待つ人なわけですね。では、どうやって実装するか、まず連結リストを使った場合、

9
00:00:50,892 --> 00:00:56,168
それから配列の場合で見てみましょう。これが連結リストを使ったキューの図です。

10
00:00:56,168 --> 00:01:02,441
二つのポインタを保持することが必要です。一つはリスト内先頭要素を指し、

11
00:01:02,441 --> 00:01:08,328
もう一つは終端の要素を指します。挿入する時は

12
00:01:08,328 --> 00:01:13,761
リストの先頭ではなく終端に要素を追加して、削除する時は

13
00:01:13,761 --> 00:01:19,704
これまでと同じで、先頭を取り出します。これが dequeue の実装です。

14
00:01:19,704 --> 00:01:27,231
スタックの pop のコードと違いはありません。要素を退避して、

15
00:01:27,231 --> 00:01:35,403
先頭ノードの参照を進めつつ元を削除して、要素を返す。全く同じです。

16
00:01:35,403 --> 00:01:43,298
ノードを加える enqueue、新しいノードを連結リストに加える際は、

17
00:01:43,298 --> 00:01:50,921
終端に加えれば一番最後の返り値になります。終端に加えるためには、

18
00:01:50,921 --> 00:01:58,085
まず始めに終端のリンクを退避しておきます。そうしておくのは

19
00:01:58,085 --> 00:02:06,459
リンク先の参照を NULL から 新しいノードに変更する必要があるためです。

20
00:02:06,459 --> 00:02:14,577
それからリスト終端の新しいノードを生成してフィールドを埋めて、

21
00:02:14,577 --> 00:02:22,331
それから元の終端リンクの次参照を NULL から新しいノードに置き換えます。

22
00:02:22,331 --> 00:02:31,418
以上が基本的な連結リストの処理です。

23
00:02:31,418 --> 00:02:37,517
何年か前にアルゴリズムとデータ構造のコースを教えていた時は、このような類いの

24
00:02:37,517 --> 00:02:44,035
ポインタ操作を扱うコースが多くありましたが、今となっては

25
00:02:44,035 --> 00:02:50,580
スタックやキュー、その他基本的なデータ構造の実装に限られています。

26
00:02:50,580 --> 00:02:56,139
連結リストを扱うのに苦心してプログラムする必要はありません。

27
00:02:56,139 --> 00:03:02,754
このように基本データ型にカプセル化します。いいでしょう、では全実装に話を戻しましょう。

28
00:03:02,754 --> 00:03:09,029
これは前のスライドの断片をかき集めたものですが、

29
00:03:09,029 --> 00:03:16,030
合わせて、キューが空の場合について注意して確認してください。

30
00:03:16,030 --> 00:03:22,669
要素を削除した後でキューが空なら、last は NULL にします。

31
00:03:22,669 --> 00:03:29,535
first と last の両方とも、我々が得たいものに常に保つことを確認してください。

32
00:03:29,797 --> 00:03:36,069
簡単ではありますが詳細は以上です。いいでしょう。では配列ではどうでしょうか？

33
00:03:36,069 --> 00:03:41,096
詳細に取りかかりたいところですが、可変長配列でのキューの実装は

34
00:03:41,096 --> 00:03:47,030
さして難しいものではありません。難しくはないですが、プログラミング演習として

35
00:03:47,030 --> 00:03:52,761
やってみてください。まず、二つのポインタを扱います。

36
00:03:52,761 --> 00:03:58,411
キュー内の先頭要素と終端は次に来る要素を格納する位置です。

37
00:03:58,576 --> 00:04:03,087
enqueue では、tail の位置に新しい要素を追加して、dequeue では、head の要素を削除します。

38
00:04:03,087 --> 00:04:10,554
そして、容量を超える場合にトリックが必要です。ゼロに戻す必要があり、

39
00:04:10,554 --> 00:04:18,058
まあ、ちょっとした追加のコードですが。それから容量を拡張する必要があります。

40
00:04:18,058 --> 00:04:25,077
スタックのようなデータ構造を実装する場合と同じですね。

41
00:04:25,077 --> 00:04:28,013
以上で、後は各自の練習問題としてとっておきましょう。