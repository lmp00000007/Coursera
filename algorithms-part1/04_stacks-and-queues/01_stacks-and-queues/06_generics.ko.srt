1
00:00:01,082 --> 00:00:06,475
다음으로, 지금까지의 구현들이 문자열에만 적용된다는

2
00:00:06,475 --> 00:00:11,664
또다른 근본적인 결함을 해결하기 위해 고민해봅시다.

3
00:00:11,664 --> 00:00:16,503
만약 다른 데이터를 포함한 큐나
 스택이 필요하면 어떻게 해야 할까요?

4
00:00:16,503 --> 00:00:22,573
이런 측면에서 JAVA의
 제네릭(generic)이란 주제를 다루게 됩니다.

5
00:00:22,573 --> 00:00:29,075
기존엔 문자열 스택을 구현해 왔지만,
 응용들에서는 또다른 종류의 데이터를

6
00:00:29,075 --> 00:00:35,675
다루어야 해서 정수형, URL, 자동차, 승합차(van)
 등의 스택을 다루어야 할 수 있죠.

7
00:00:35,887 --> 00:00:41,386
그 대상이 어떠한 데이터든 처리해야 한다면요.
 그럼 그런 타입의 큐와 스택을 어떻게 구현할까요?

8
00:00:41,386 --> 00:00:46,796
음, 처음 우리가 고려해야 하는 것을

9
00:00:46,796 --> 00:00:51,869
많은 프로그래밍 환경에서 다룰 때에는

10
00:00:51,869 --> 00:00:57,135
사용하는 데이터 타입 마다 스택 클래스를 따로 구현하는 겁니다.

11
00:00:57,135 --> 00:01:02,900
불만족스럽지만요. 배열 리사이징 등의
 기능을 사려깊게 코드로 작성했음에도

12
00:01:02,900 --> 00:01:09,348
그 코드를 복사해서 데이터 타입을

13
00:01:09,348 --> 00:01:15,129
스트링 타입에서 승합차 데이터 타입 또는
 정수형 등으로 모든 곳을 고쳐야 합니다.

14
00:01:15,129 --> 00:01:21,039
처리하고 있는 수백가지 다른 타입의 데이터가
 있다면 어떨까요. 우리는 수백 가지의 다른

15
00:01:21,039 --> 00:01:26,470
(타입만 다른) 구현을 가져야 합니다.
 불행히도 이 문제는 JAVA의 초기에서부터 대두된 문제이며

16
00:01:26,470 --> 00:01:31,424
다른 많은 프로그래밍 언어들에서도
 기본적으로 발생하는 문제입니다.

17
00:01:31,424 --> 00:01:36,425
그래서 여기서 다루려는 내용은 데이터 타입만 바꾸어
 API를 따로 구현하는 불편을 피하기 위한

18
00:01:36,425 --> 00:01:42,509
현대적인 접근 방법 중 하나입니다.
 사실 (이외에) 쉽게 시도할 수 있는 방법은

19
00:01:42,509 --> 00:01:51,399
다른 데이터 타입으로 작성된 코드를 재사용하기 위해서
 (타입) 캐스팅을 사용하는 것입니다.

20
00:01:51,704 --> 00:01:59,435
JAVA의 모든 데이터 타입은 Object 클래스의 하위 타입임에 주목해서,
 Object 타입으로 스택 구현을 해둔 뒤

21
00:01:59,435 --> 00:02:07,050
사용자가 그 구현을 사용할 때, 그저 대응하는 타입으로

22
00:02:07,050 --> 00:02:13,491
단순히 타입 캐스팅을 하는 겁니다.
 이 방법은 제 생각엔 그리 만족스런 답이 아니므로

23
00:02:13,491 --> 00:02:19,643
시간을 더 쓰고 싶지는 않습니다만, 이 예시에서는
 이름만 다른 두 개의 스택을 생각하려는데요.

24
00:02:19,643 --> 00:02:25,878
하나는 오렌지(Orange) 타입을 저장하고 다른 하나는
 사과(Apple) 타입을 저장하기 위해 선언되었습니다. 이 때, 사용자는

25
00:02:25,878 --> 00:02:32,007
사과(Apple) 스택 a에서 pop 연산을 할 때, 타입 체킹 시스템이
 편하도록 pop의 리턴값을 Apple 타입으로 캐스팅합니다.

26
00:02:32,007 --> 00:02:37,103
이 문제는 사용자의 코드가
 이런 역할을 해주어야 한다는 점입니다.

27
00:02:37,270 --> 00:02:43,100
이러한 캐스팅이 제대로 되지 않는다면, 발견하기 쉽지 않은, 
즉 서서히 프로그램을 고장내는 버그(insidious bug)가 될 겁니다.

28
00:02:43,100 --> 00:02:51,458
이제부터 말할 세 번째 접근법은, 제네릭을 사용하는 겁니다.

29
00:02:51,458 --> 00:03:00,357
이를 이용하면 사용자 코드가 캐스팅을 할 필요가 없습니다.
 타입 상의 불일치를 컴파일 타입에 발견할 수 있으며,

30
00:03:00,652 --> 00:03:08,018
이는 앞의 방법이 런타임에서 타입 상의
 불일치가 발생하는 점과 구분됩니다.

31
00:03:08,018 --> 00:03:16,698
제네릭을 이용할 때는, 클래스를 표기할 때
 타입 파라미터(type parameter)를 같이 표기해야 하는데,

32
00:03:17,011 --> 00:03:24,080
이처럼 앵글 브라켓(<, >) 사이에 표기합니다.
 만약 사과 타입의 스택을 만들었을 때,

33
00:03:24,378 --> 00:03:32,980
만약 사과 타입의 스택에 오렌지를 push하면
 컴파일 타임 오류가 발생합니다.

34
00:03:32,980 --> 00:03:38,027
우리가 이미 그 스택을 애플만으로 구성하겠다고
 선언을 하였음을 컴파일러가 아니까요.

35
00:03:38,027 --> 00:03:44,492
모듈 프로그래밍(modular programming)을 작성할 때에는

36
00:03:44,492 --> 00:03:51,730
컴파일 타임 에러보다는 런타임 에러를 반기게 됩니다.
 만약 컴파일 타임에 에러를 발견하게 되면

37
00:03:51,730 --> 00:03:58,323
이를 수정하면 되니까, 수정을 마친
 우리의 API 구현을 제품화하고 배포할 때,

38
00:03:58,323 --> 00:04:04,310
여러분은 어떤 사용자에게 그 제품이 주어져도
 잘 동작하리라 어느 정도 확신할 수 있게 됩니다.

39
00:04:04,310 --> 00:04:09,664
어떤 사용자 환경에서만 발생하는 런타임 에러의의 경우
 실행을 해볼 때까지 발견되지 않으므로

40
00:04:09,853 --> 00:04:16,082
수 년이 지난 뒤에, 모든 사람들에게 소프트웨어를
 다시 배포해야 할 수 있으며

41
00:04:16,347 --> 00:04:23,849
이는 매우 끔찍하게 어려운 일입니다. 자, 사실

42
00:04:23,849 --> 00:04:32,268
(JAVA처럼) 좋은 제네릭 구현을 가지고 있다면,
 우리가 String 클래스를 활용해 구현한 Stack 구현에서

43
00:04:32,268 --> 00:04:40,637
String 타입을 제네릭 타입으로 변경하는 작업은
 여기에 있듯 어렵지 않습니다.

44
00:04:40,637 --> 00:04:48,018
좌측에는 String을 쓴 리스트 기반 스택 구현이있고요.

45
00:04:48,018 --> 00:04:53,095
오른쪽에는 이를 수정해 제네릭을 쓰는
 리스트 기반 스택 구현입니다. 좌측에서 String 타입이 쓰인 모든 부분이

46
00:04:53,095 --> 00:04:59,520
우측에서는 Item이라는 단어로 바뀌었음을 볼 수 있고,
 맨 위에 클래스 선언에서

47
00:04:59,520 --> 00:05:05,539
Item이 우리가 쓰려는 제네릭 타입의 이름임을
 앵글 브라켓 안에서 살펴볼 수 있습니다.

48
00:05:05,746 --> 00:05:11,836
이 구현은 더 이상 쉬울 수 없을 정도로 아주 명확하고,

49
00:05:11,836 --> 00:05:18,862
한 구현을 통해 여러 종류의 데이터 타입을
 다루는 문제를 멋지게 풀어냅니다.

50
00:05:19,298 --> 00:05:29,269
배열을 이용하는 구현의 경우엔, 앞과 같은 방법이
 모든 프로그래밍 언어에서 통용되진 않습니다.

51
00:05:29,269 --> 00:05:35,404
요즈음의 많은 프로그래밍 언어가 배열과
 제네릭을 결합하는 문제에 어려움이 있으며,

52
00:05:35,404 --> 00:05:41,231
특히 JAVA에서 문제가 됩니다. 예를 들어, 앞의 변환 방법을 적용하면 단순히

53
00:05:41,443 --> 00:05:48,057
흰 색으로 강조된 라인에 String 대신 제네릭 명칭인
 Item으로 바꾸어서 새로운 배열을 선언하면 될 것 같습니다.

54
00:05:48,057 --> 00:05:55,059
하지만 문제는, JAVA는 제네릭 타입의 배열 생성을 허용하지 않습니다.

55
00:05:55,059 --> 00:06:02,125
이렇게 하는 이유는 매우 다양한 기술적 이유들이 존재하고,
 웹에서 다양한 논쟁을 살펴볼 수 있을 겁니다.

56
00:06:02,125 --> 00:06:08,718
이러한 논쟁은 우리의 논의 범위를 넘어가고요.
 따라서 우리가 해야 할 것은

57
00:06:08,718 --> 00:06:15,322
프로그램이 동작할 수 있도록 캐스팅을 하는 겁니다.
 즉, Object 클래스의 배열을 만든 뒤

58
00:06:15,322 --> 00:06:22,461
Item의 배열로 이를 캐스팅을 하는 것입니다.
 제 관점에선 좋은 코드는 캐스팅이 없어야 하고,

59
00:06:22,461 --> 00:06:28,622
캐스팅을 하는 건 우리 코드에 어떤 약점을 만드는 일과
 같기 때문에 최대한 캐스팅을 피하고 싶은 겁니다만,

60
00:06:28,622 --> 00:06:35,306
이 경우에는 어쩔 수 없이 한 번의 캐스팅을 해야 합니다.

61
00:06:35,306 --> 00:06:41,647
때문에 이 구현은 보기 싫은 캐스팅이라는 평가를 들을 수 밖에 없습니다.

62
00:06:41,647 --> 00:06:47,734
이 코드에 기분이 좋을 수 없지요.
 이러한 것이 불필요한 기능이라고, 견딜 수 없어할 수 있는데

63
00:06:47,734 --> 00:06:52,789
저는 코드는 이처럼 간결한 게 좋다고 봅니다.

64
00:06:52,789 --> 00:06:58,276
다만 불행히도, 우리가 모든 걸 좋게 만들 수는 없고, 이 강의에서는

65
00:06:58,276 --> 00:07:04,297
이런 보기 싫은 캐스팅을 알아야 되는 상황이라는 겁니다.
 이제, 이 코드를 컴파일하면

66
00:07:04,297 --> 00:07:10,490
JAVA로부터 경고(Warning) 메시지를 받게 될 겁니다.
 이는 컴파일러가 체크하지 않았거나 안전하지 않은 연산을 했음을 알려줍니다.

67
00:07:10,490 --> 00:07:15,610
따라서 이 프로그램을 -Xlint:unchecked라는 옵션을 주어 재컴파일 해서
 정확히 무엇이 체크되지 않았는지를 확인해야 합니다.

68
00:07:15,610 --> 00:07:21,787
여기서 실제 재컴파일한 결과를 살펴보면,

69
00:07:21,787 --> 00:07:27,247
체크되지 않은 캐스트가 코드에 있으며, 체크되지 않은 캐스트를 코드에 삽입하지 않는 게 필요함을

70
00:07:27,247 --> 00:07:33,428
경고했음을 알려줍니다.
 이 정도 경고는 괜찮지만

71
00:07:33,428 --> 00:07:40,014
이와 같은 코드를 컴파일 할 때에는 계속 보게 될 겁니다.
 제 생각엔 컴파일러 개발자들이

72
00:07:40,014 --> 00:07:45,494
이 경고 문구에 "이런 결과를 초래해서 죄송합니다"를 추가해야 할 것 같아요.

73
00:07:45,494 --> 00:07:51,770
이런 결과가 나온 건 우리가 잘못 짠 것이 아니라
 제네릭 타입을 지원하면서 제네릭 배열의 선언을 허용하지 않는

74
00:07:51,770 --> 00:07:57,908
JAVA의 요구사항 때문이니까요. 덧붙이자면

75
00:07:57,908 --> 00:08:03,915
지금까지의 관점을 여러분이 따른다면, 이런 경고 메시지를 보더라도
 여러분의 코드에 문제가 있다고 생각할 필요는 없습니다.

76
00:08:03,915 --> 00:08:10,596
이제, 다른 JAVA에 관한 문제를 살펴볼건데요.

77
00:08:10,596 --> 00:08:19,274
제네릭에서 원시 타입(premitive type)은 어떻게 쓰느냐입니다.

78
00:08:19,274 --> 00:08:26,636
우리가 쓴 제네릭 타입은 객체에 관한 것이어고,
 객체의 배열을 캐스팅했던 것이죠.

79
00:08:26,876 --> 00:08:34,517
만약 제네릭 타입에 원시 타입을 쓰고 싶다면,
 JAVA가 지원하는 Wrapper 객체 타입을 쓰면 됩니다.

80
00:08:34,782 --> 00:08:40,751
예를 들어 int 원시 타입은 시작이 대문자인
 Integer Wrapper 타입을 쓰면 되겠죠.

81
00:08:40,751 --> 00:08:46,419
여러분들은 아마 이런 것에 익숙하리라 보는데,
 이를 Auto-boxing이라고 부릅니다.

82
00:08:46,419 --> 00:08:51,827
제네릭 처음에만 명확하게 Wrapper 타입을 써주면,
 원시 타입과 그 래퍼 간에 자동적으로 캐스팅이 일어나거든요.

83
00:08:51,827 --> 00:08:57,633
즉, 원시 타입을 다루는 문제는 장막의
 뒷편에서 처리되는 문제의 일종입니다.

84
00:08:57,633 --> 00:09:04,693
이제 정리하면, 지금까지 어느 데이터 타입에도
 잘 동작하는 제네릭 기반의 스택 API를 다루었다는 거고요.

85
00:09:04,693 --> 00:09:10,665
그 스택 API의 두 가지 구현,
 즉 리스트 기반과 배열 기반 구현을 다루었는데

86
00:09:10,665 --> 00:09:20,867
각 구현은 어느 데이터 타입에서도 잘 동작하고, 배열 리사이징이나 리스트 링크를 하는 데

87
00:09:20,867 --> 00:09:26,035
문제가 없다는 것입니다.