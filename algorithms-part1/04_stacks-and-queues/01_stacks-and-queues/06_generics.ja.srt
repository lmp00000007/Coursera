1
00:00:01,082 --> 00:00:06,475
次に、実装時の別の根本問題に目を向けてみましょう。

2
00:00:06,475 --> 00:00:11,664
これまでの実装は、文字列のみに絞って考慮してきました。

3
00:00:11,664 --> 00:00:16,503
他のデータ型のキューやスタックが必要な時はどうなるでしょうか？

4
00:00:16,503 --> 00:00:22,573
ここでジェネリクスの出番です。ではいきましょう。

5
00:00:22,573 --> 00:00:29,075
文字列のスタックは実装しましたが、アプリケーションではあらゆるデータ型を扱いますし、

6
00:00:29,075 --> 00:00:35,675
Int や  URL や Car や Van など扱うデータに関わらず、スタック等を実装したいわけです。

7
00:00:35,887 --> 00:00:41,386
ではそのような型のスタックやキューを実装するには

8
00:00:41,386 --> 00:00:46,796
どうするでしょうか？最初に思いつきそうなことは、

9
00:00:46,796 --> 00:00:51,869
まあ実のところ多くのプログラミング環境ではそう考えてしまうのですが、

10
00:00:51,869 --> 00:00:57,135
利用するデータ型毎にスタックのクラスを分けることです。

11
00:00:57,135 --> 00:01:02,900
なんとなく厳しそうですね。配列リサイズ等のコードを注意深く書いて、

12
00:01:02,900 --> 00:01:09,348
コードをコピーして、データ型を文字列から

13
00:01:09,348 --> 00:01:15,129
Van や Int へ、全ての箇所にわたって書き換えるわけです。何百もの

14
00:01:15,129 --> 00:01:21,039
異なるデータ型を扱う時はどうなるでしょう？何百もの異なる実装が必要ですね。

15
00:01:21,039 --> 00:01:26,470
不運にも、初期の Java では我々はこの問題に悩まされ、

16
00:01:26,470 --> 00:01:31,424
多くのプログラミング言語でも基本的には同じです。

17
00:01:31,424 --> 00:01:36,425
というわけで、これから見ていくモダンな手法により

18
00:01:36,425 --> 00:01:42,509
データ型ごとに複数の実装を持つことを避けます。手っ取り早い方法として、

19
00:01:42,509 --> 00:01:51,399
異なるデータ型に対しては、型キャストを用いてコードを再利用する方法が広く使われています。

20
00:01:51,704 --> 00:01:59,435
Java では全ては Object 型のサブクラスですので、Object 型で実装します。

21
00:01:59,435 --> 00:02:07,050
クライアントがそれを使う時点で、単に対応する型に

22
00:02:07,050 --> 00:02:13,491
キャストするだけです。私はこんな事には時間を割きたくないですね。

23
00:02:13,491 --> 00:02:19,643
いまいちの解決策だと思います。この例では、二つの型を

24
00:02:19,643 --> 00:02:25,878
スタックに積んでいます。一つは Apple 型で、もう一つは Orange 型です。

25
00:02:25,878 --> 00:02:32,007
Apple のスタックから pop で取り出したら、クライアント次第で Apple 型にキャストして、

26
00:02:32,007 --> 00:02:37,103
型チェックが働くように保ちます。ここでの問題は、クライアント側のコードが

27
00:02:37,270 --> 00:02:43,100
型キャストの責務を負うので、それがうまくいかない場合にバグとなる危険が潜んでいます。

28
00:02:43,100 --> 00:02:51,458
三度目の試みでは、ジェネリクスについてお話しましょう。

29
00:02:51,458 --> 00:03:00,357
この場合、クライアントはキャストすることはありません。型が合っていなれば

30
00:03:00,652 --> 00:03:08,018
実行時ではなくコンパイル時に間違いを見つけることができます。この場合は

31
00:03:08,018 --> 00:03:16,698
ジェネリクスを使っていて、型パラメータをクラス名に含めています。

32
00:03:17,011 --> 00:03:24,080
このコードのブラケット内ですね。それで、 [cough] もし Apple 型のスタックがあって

33
00:03:24,378 --> 00:03:32,980
Orange 型の要素を Apple 型のスタックに追加しようとすれば、

34
00:03:32,980 --> 00:03:38,027
コンパイルエラーになります。スタックは Apple 型であると宣言されていたからです。

35
00:03:38,027 --> 00:03:44,492
良質のモジュラープログラミングの指針は

36
00:03:44,492 --> 00:03:51,730
コンパイルエラーを活用し、実行時エラーは避けることにあります。なぜならば

37
00:03:51,730 --> 00:03:58,323
コンパイル時にエラーが検出できるならば、製品として出荷したり

38
00:03:58,323 --> 00:04:04,310
API 実装を公開したりと、あらゆるクライアントで動作する事に自信が持てます。

39
00:04:04,310 --> 00:04:09,664
一方で、エラーが実行時にならないと検出できないなら

40
00:04:09,853 --> 00:04:16,082
ソフトウェアを公開した後の数年後に、クライアント側での開発時にエラーが起こるかもしれませんし、

41
00:04:16,347 --> 00:04:23,849
誰にとっても極めて困難でしょう。いいでしょう。そして実際のところ

42
00:04:23,849 --> 00:04:32,268
良いジェネリック実装とはいっても難しいものではありません。単に [cough]

43
00:04:32,268 --> 00:04:40,637
String としていた箇所を、全てジェネリック型名に置き換えます。ここにあるコードのように。

44
00:04:40,637 --> 00:04:48,018
左側が連結リストを使った String 型のスタック実装です。右側が

45
00:04:48,018 --> 00:04:53,095
ジェネリック実装ですね。左側で String 型を使っている全ての箇所で、

46
00:04:53,095 --> 00:04:59,520
右側では Item を使っています。先頭のクラス宣言では

47
00:04:59,520 --> 00:05:05,539
ブラケット内の Item をジェネリック型として利用することを宣言しています。

48
00:05:05,746 --> 00:05:11,836
実装はこれ以上ないくらい簡潔で

49
00:05:11,836 --> 00:05:18,862
一つの実装で複数の型を扱う問題を解決するのに優れた方法です。

50
00:05:19,298 --> 00:05:29,269
配列の場合は、完全にはできません。全てのプログラミング言語、

51
00:05:29,269 --> 00:05:35,404
というか今日では多くのプログラミング言語がこの課題を抱えていて、

52
00:05:35,404 --> 00:05:41,231
Java は特に顕著です。やれたらよい事は、単に配列生成の箇所を

53
00:05:41,443 --> 00:05:48,057
ハイライトされた行にあるように、ジェネリック名にすることです。さもなければ

54
00:05:48,057 --> 00:05:55,059
同じ事です。不運にも Java では、ジェネリック型の配列生成は許可されていません。

55
00:05:55,059 --> 00:06:02,125
さまざまな技術的な理由によるもので、関連する広範囲な議論をウェブ上で読めますが

56
00:06:02,125 --> 00:06:08,718
それはそれとしておきましょう。今必要なのは動かすことで、それにはキャストを使います。

57
00:06:08,718 --> 00:06:15,322
すなわち、いったんオブジェクト型の配列を生成してからキャストします。

58
00:06:15,322 --> 00:06:22,461
私の判断では、良いコードには型キャストはありません。ですので

59
00:06:22,461 --> 00:06:28,622
可能な限りキャストは避けたいわけです。何かよろしくない事をやっていますよと

60
00:06:28,622 --> 00:06:35,306
宣言しているわけですからね。ですが、この場合は、この唯一のキャストを含めなければいけません。

61
00:06:35,306 --> 00:06:41,647
ご存知の通り、見苦しいキャストです。コードを見ていい気はしませんね。

62
00:06:41,647 --> 00:06:47,734
こうすることは、あなた自身の思いつきではなく、

63
00:06:47,734 --> 00:06:52,789
望ましくない仕様なのだと、このコードについては、私は割り切って考えます。

64
00:06:52,789 --> 00:06:58,276
幸いにも、本コースで色々な事をやっていく中で、

65
00:06:58,276 --> 00:07:04,297
この唯一の見苦しいキャストについて知っておけば十分です。というわけで、

66
00:07:04,297 --> 00:07:10,490
このプログラムをコンパイルすると、Java の警告が出ます。

67
00:07:10,490 --> 00:07:15,610
unchecked or unsafe operations と警告しています。-Xlint オプションを付けて

68
00:07:15,610 --> 00:07:21,787
コンパイルしなおして unchecked の詳細を見てみます。すると、コード内に

69
00:07:21,787 --> 00:07:27,247
未チェックのキャストがあると警告が出ます。

70
00:07:27,247 --> 00:07:33,428
未チェックのキャストはすべきでないということです。まあ、それで構いません。

71
00:07:33,428 --> 00:07:40,014
このようなコードをコンパイルすると目にすることになります。私が思うには

72
00:07:40,014 --> 00:07:45,494
彼らはこの警告に「こんなことをさせて申し訳ない」と付け加えていたかもしれませんね。

73
00:07:45,494 --> 00:07:51,770
私たちの誤りではなくて、そうせざるを得なかったのは

74
00:07:51,770 --> 00:07:57,908
ジェネリック型の配列を宣言できないためですから。そういうわけで、

75
00:07:57,908 --> 00:08:03,915
あなたのコードに問題があるとは思わないでください。我々の規範に沿って

76
00:08:03,915 --> 00:08:10,596
この警告文が出たとしても。いいでしょう、それでは Java に関する詳細になりますが、

77
00:08:10,596 --> 00:08:19,274
プリミティブ型ではどうでしょうか？ [cough] ジェネリック型は

78
00:08:19,274 --> 00:08:26,636
オブジェクトに対してのものなので、Object 型の配列からキャストします。

79
00:08:26,876 --> 00:08:34,517
すなわちジェネリック型を扱うには、Object 型のラッパーを使う必要があります。

80
00:08:34,782 --> 00:08:40,751
大文字で始める表記の Integer は int 型をラップします。多くの方々が

81
00:08:40,751 --> 00:08:46,419
おそらく馴染みがありますね。そして、オートボクシングと呼ばれる、

82
00:08:46,419 --> 00:08:51,827
自動的にプリミティブ型とラッパーを変換する仕組みがあり、

83
00:08:51,827 --> 00:08:57,633
言うならば見えないところで、プリミティブ型を扱う問題を調整してくれます。

84
00:08:57,633 --> 00:09:04,693
結果的に、ジェネリック型のスタックによる API であらゆる型が使えると言えます。

85
00:09:04,693 --> 00:09:10,665
そして連結リストと配列による二つの実装があり、

86
00:09:10,665 --> 00:09:20,867
それらは [cough] あらゆるデータ型に対して、これまでに説明してきたリサイズや

87
00:09:20,867 --> 00:09:26,035
連結リストを使って、とてもうまく動作します。