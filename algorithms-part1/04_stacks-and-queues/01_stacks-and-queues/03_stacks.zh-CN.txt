欢迎回来。今天我们要讲的是用来实现包、队列和栈等 一些基本数据类型的算法和数据结构。你也许 或多或少知道一些，但今天我们要仔细地讲一讲 在很多应用中，我们需要 维护多个对象的集合，这种操作非常简单。我们可能想要向集合中 加入某个元素，去掉某个元素，以及遍历 集合中的元素并对他们执行某种操作，当然还有 检查集合是否为空。对于大多数操作来说，目的都很明确 关键是当需要去掉一个元素时，去掉哪一个元素呢？处理这类问题 有两个经典基础数据结构，栈和队列。它们的区别就在于 去除元素的选择方式。在栈中，我们取出 最近加入的元素。插入元素对应的术语是入栈（push） 去掉最近加入的元素叫做出栈（pop）。这也叫做 后进先出原则。在队列中，我们关注最先加入队列的元素 为了和栈的操作区分，队列加入元素的操作叫做入队（enqueue） 去除元素的操作叫做出队（dequeue）。这也叫做先入先出原则 今天我们来看如何实现这些操作 我们今天隐含的主题是模块式编程。这也将是 在这门课程我们需要特别遵守的原则 这一原则主要思想是将接口与实现完全分离 比如我们精确定义了一些如栈、队列等数据结构的时候 和数据类型，我们想要的是实现的细节与客户端的 完全分离。客户端可以选择不同的实现 但是客户端代码只能执行基本操作 另一方面，实现部分无法知道客户端需求的细节 它所要做的只是实现这些操作 这样，很多客户端能够共用同一个实现 这使得我们能够用模块式可复用的算法与数据结构库 来构建更复杂的算法和数据结构 也能使我们在必要的时候更关注效率 Java这样的面向对象编程语言使得我们能够使用 这种模块化编程风格，这门课中我们会严格遵守这样的风格 好的，下面我们开始讲栈。栈大家都很熟悉 你们当中很多人可能在编程入门课中已经实现过栈 但我们现在要对栈的实现做一个全面的介绍。先热个身 假设我们有一个字符串的集合。可能很短 也可能很长。我们想要实现对字符串集合的存储 定期取出并返回最后加入的字符串 并检查集合是否为空。那么这就是我们的API。我们有一个创建 空栈的构造函数；一个实现插入操作的，以一个字符串为参数的入栈函数； 一个实现移除操作的出栈函数来返回 最近加入的字符串；以及一个检查为空与否，返回布尔值的函数； 在有些应用中，我们可能还会包括栈大小函数 像往常一样，我们先写一个客户端程序，然后再看实现 这个客户端很简单，从标准输入中获取一些字符串 连字符表示出栈操作。这个客户端读取标准输入 字符串，如果字符串是连字符，客户端将栈顶的 字符串出栈并打印。否则，输入为 不是连字符的字符串时，则将它入栈到栈顶 所以下面这个例子中，输入文件为tobe.txt 客户端将to be or not to几个字符串全部入栈，遇到 这个连字符时将最近入栈的元素to出栈 然后将be置于栈顶。接下来将栈顶元素出栈 现在栈顶元素是be。最近入栈的元素出栈，be和to都已经去掉了 那么被去掉的栈顶元素是not，等等。我们可以用这个很简单的客户端 测试我们的实现。现在，我们来看实现栈的代码 我们要看的第一个实现使用链表。如果你对 链表不熟悉，你需要看第1.3节来复习一下 我们的Java编程入门书里也有讲链表。即使你熟悉 链表，看看这个代码也是很值得的，因为这是我们整个课程中 会用来实现复杂得多的数据结构的代码风格 好，我们想保存一个由节点组成用来存储字符串的链表 节点包含指向链表中下一个元素的引用。实现栈的时候 执行入栈操作时，我们在链表头插入一个新的节点 执行出栈操作时，我们去掉链表头处第一个节点 这就是最近加入的元素。好，我们来看代码 这门课中所有的链式数据结构中 我们使用Java中内部类来实现，这只是 描述我们要操作的节点对象的一种方法 节点对象由一个字符串和指向另一个节点的引用组成。所以，链表的 出栈操作非常容易实现。首先，我们需要 返回链表中第一个元素，所以先将它存在变量item中 然后，要去掉第一个节点，我们只需要将 链表指向第一个元素的指针指向下一个元素 然后第一个节点就等着被垃圾回收处理 最后，返回保存的元素 好，这是出栈操作。入栈操作呢？ 我们要在链表头加入新的节点 首先，将指向链表头的指针存起来，oldfirst = first 然后创建新节点，这是我们要插入链表头 的新节点。first = new Node() 这是个实例变量，它的元素就是我们想要插入链表头 的字符串，这个例子中是“not”，它的next指针指向链表oldfirst元素 现在成了链表第二个元素。在这个操作之后 first指向链表头处的元素，链表中的元素依照 入栈时间降序排列。实现入栈操作 只需要四行代码。好，这就是Java写的 用链表实现字符串栈的全部代码 这个类中构造函数不做任何操作 也就不用写构造函数。内部类用来构成链表中的元素 将它写成了内部类，这样我们能够直接访问这些实例变量 栈唯一的实例变量是 链表中第一个节点的引用，初始化为空指针null isEmpty就是检查链表第一个节点是否为null 入栈函数是我之前ppt中给出的那四行代码 出栈函数是再之前给出的那三行代码 这就是能够为任一个客户端服务的作为栈完美工作的 链表的完整实现。现在，我们分析实现的性能 这样我们就能提供给客户算法数据结构的 性能信息。这个例子中，很容易就能看出每个操作 最坏情况下只需要常数时间。每个操作都只有几个命令 没有循环，这显然是我们很想要的特性 那么空间需求呢？这和机器具体 实现有关。这是个典型Java实现，我们能够对它进行分析 并且很容易能在不同环境中测试这个例子 Java中，每个对象会有16字节的 额外空间，因为有内部类，所以还有8字节的额外空间 在类Node中有两个引用 一个指向字符串，另一个指向Node类 各需要8字节，每个栈节点需要40字节，如果栈大小为N 需要大约40N字节。引用first还会占一些额外空间，对于整个栈 只是很少的额外空间，当N很大时，40N是对空间需求非常接近的估计 这不包括字符串本身的空间，这些空间在客户端上 加上那些信息，就能正确评估这个实现对于不同客户端程序的 资源使用量。链表实现的时间复杂度是常数的 但是栈还有更快的实现，因为有些算法中内循环 中用到了栈，想出更快的实现是很重要的 另一种实现栈的自然的方式是使用数组来储存栈上的元素 我们来看这个。这种在链式结构和数组之间的选择 是很基本的。我们在考虑算法中更复杂的 数据结构时会反复遇到。所以，我们想要 现在栈这种简单情况中确认这一点 为后续更复杂的应用做铺垫。使用数组 我们将栈中N个元素保存在数组中，索引为N的 数组位置对应栈顶的位置，即下一个元素加入的地方。好，要入栈 我们只需要将心元素加入s[N]，要出栈则移除s[N-1]处的元素 并将N减1。那么能看到使用数组一个根本性的缺点 必须事先声明数组的大小，所以栈会有 确定的容量。如果栈上的元素个数比栈的容量多，就 必须处理这个问题。这是数组实现的 所有算法和数据结构必须处理的基本问题 再一次地，我们先考虑简单情形，之后再来处理这个问题 那么，这就是用数组表示栈的完整实现 我们有一个字符串数组的实例变量，以及变量N 它既是栈的大小，又是下一个元素位置的索引 栈中下一个开放的位置。这个类有构造函数，创建那个数组 为了简单表示，我们这个实现中做了个弊 我们先让客户端提供栈的容量，一会再来处理这个问题 个别应用中这也许没有问题，但是在非常多的应用中 这个要求就很不合适，客户端确实不知道 需要多大的栈。有可能客户端需要同时维护很多栈 那些栈在不同时间达到最大容量 还有很多其他因素。所以我们不能作弊 但如果我们已知所需的容量，代码基本上不值一提。检查是否为空即 检查N是否等于0。将元素入栈，我们将元素放在N索引的位置 并将N增加1。这是现在很多编程语言表示使用索引N 并增加1的简洁表示。将元素出栈，我们将索引N减1并用它 返回数组中的元素。每个操作都只需要一行代码 对于有些客户端这是个不错的实现。这是个栈的 数组实现，但是它破坏了API，需要客户端提供容量 怎么来处理这个问题呢？有几点我们没有考虑 如果客户端从空栈中出栈我们没有抛出异常 也许我们应该这么做。对于当客户端入栈过多发生溢出时 我们来讲一个调整大小的方法 这种方法能够让我们为客户端避免溢出。还有一个问题 客户端是否能向数据结构中插入空元素。这种情况中，我们 确实允许客户端插入空元素，但在Java中我们需要操心一个问题 叫做对象游离（loitering）,即在栈的数组 实现中有对象的引用，而我们并没有真正使用它 所以当减小N时，在数组中仍然有我们已经出栈 的对象的指针。尽管我们知道我们不再使用它了，但是Java系统 不知道。所以为了避免这个问题，最有效地使用内存 最好将去除的元素对应的项设为null，这样就不会剩下 旧元素的引用。因为不存在引用了接下来垃圾回收器 会收回那些内存。这个问题比较细节，但是很重要 我们必须在实现中要确保充分利用内存。 处理这个问题