Java还提供了另一种能够使客户端代码保持优雅紧凑 绝对值得添加到我们的基本数据类型的特性 这就是我们马上要讲到的迭代器 我们想要做的是允许客户端遍历集合中的元素 但不必让客户端知道我们是用数组还是链表 还是我们考虑的任何内部表示，这对于客户端是不相关的 大多数客户端想做的只是遍历集合中的元素 而Java的确提供了一个美妙的解决方式，就是遍历机制 下面我们要做的是看看如何使我们的栈、队列和后面 要讲到的其他数据结构实现所谓的Iterable（可遍历类）接口 无论我们使用哪种实现，对于客户端都能正常使用 好，我们来具体看看。那么什么是Iterable呢？在Java语言中 Iterable是具有返回迭代器的方法的一种类 那么什么是迭代器？迭代器是具有hasNext()和 next()方法的类。Java还允许remove()方法
我们认为这个不是好特性 我们不用这个特性，它有可能成为调试隐患
那么，只要有hasNext()和 next()方法就使得数据结构是可遍历的，我们要实现这两个方法 这看起来好像有点累赘，我们要这么自找麻烦的原因是 如果我们的数据结构是可遍历的 在Java中可以使用非常紧凑优雅的客户端代码 即所谓的for-each语句。所以如果我们有一个栈 stack
可以写(for String s: stack) 表示对栈中每个字符串，执行打印输出。如果我们 用迭代器，我们也可以写成这种完整形式的代码 但不会有人这么做，因为它和这种简写形式是等价的 不使用迭代器的话要实现遍历客户端代码中就要执行 非常多不必要的入栈出栈操作。所以这是能够让遍历 数据结构中的元素的客户端代码变得这么紧凑的关键所在 我们要给我们所有的基本数据结构提供遍历机制 实现这个功能并不特别难，而且绝对值得投入精力 这是基于链表的栈的代码。接下来我们要实现Iterable接口 实现Iterable接口意味着什么呢？这个类需要有iterator()方法 返回迭代器。什么是迭代器呢？我们要用一个内部类 这个例子中，命名为ListIterator的内部类实现Iterator接口 并且是泛化（generic）的。这个类主要完成的是实现这些方法 hasNext()和next()。从名字就能清楚知道它们的语义。hasNext() 在完成遍历之后会返回“假”。如果还没有完成，应该 返回“真”。next()方法应当提供要遍历的下一个元素 所以如果是基于链表的数据结构，我们要从表头first元素开始 这是处于表头的元素，我们要维护迭代器中的实例变量current 存储当前正在遍历的元素 获取下一个元素，就像要移除表头一样。我们取出current元素 current引用指向下一个元素，并返回item。也就将current 移动到了下一个元素上。客户端会一直测试hasNext()，就像 前面那段代码里，所以当current变成空指针，hasNext返回“否” 终止遍历。在我们的遍历中，我们只需要关注实现 next()和hasNext()方法，使用一个局部实例变量就能完成 我们应该让代码能“防弹”—如果遍历已经终止客户端试图 调用next()或者任何时候试图调用remove()时抛出异常 我们不提供remove()方法。对于基于数组的实现，就更简单了 使用迭代器我们能控制遍历顺序，使其 符合语义和数据结构。遍历栈时你要让元素 以出栈的顺序返回，即对于数组是逆序的 那么这种情况下next() 就将索引减1，返回下一个元素 而我们的实例变量是数组的索引。只要该变量为正，hasNext() 返回“真”。要实现这个遍历机制只需要写几行Java代码 而实际上在这个框架下不需要做很多事 当你实现你自己的数据类型的时候就会看到。以后会遇到的 涉及对象集合的基本数据类型中我们都会用这种编程范式 好，这就引出实际上很多客户端 并不关心我们返回元素的顺序。我们经常做的是 直接向集合中插入元素，接下来遍历已有的元素 这样的数据结构叫做背包，我们来看看它的API 顺序并不重要所以我们想要能直接添加元素 也许还想知道集合大小，我们想遍历背包中所有的元素 这个API更简单，功能更少，但依然提供了几个 重要的操作。使用这个API，我们已经看过实现了 只需要将栈的出栈操作或者队列的出队操作去掉 就能获得这个有用的数据结构的良好的实现