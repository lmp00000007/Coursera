さて、これまでのものはいわゆる基本のデータ型や実装で、 初歩的で簡単すぎるように思えます。ですが、実際に大変洗練された これらの基本コンセプトに沿ったアプリケーションを得られるのです。それを考えるのが次のステップです。 では、最初に言っておきますが、我々が実装するデータ型やデータ構造の類いは、 Java ライブラリ内に存在します。多くのプロラミング環境でもそのことが言えます。 例えば、スタックとキューはその用語そのままで、 Java ライブラリ内に見つけられます。Java コレクションライブラリというものがあり、 お見せするのは List インターフェイスと呼ばれるものです。Java は連続要素のための一般 API を持っていて、 終端への追加や、先頭位置からの削除等々があります。 可変長配列を使ったものがありますね、我々が考える原理と多く絡みます。 連結リストのインターフェイスもそうですね。ではなぜ単にそれらを使わないのでしょうか？ なぜ自分で実装したものを使うのでしょう？問題はライブラリのコードにあり、 委員会が決めたような作りで、継ぎ足しで操作が加えられ、 API は広大で膨れ上がっています。同じ API に様々な操作があるのは 良いアイデアではありません。のちほど例をみましょう。 本当の問題は、そういうものを使う時に、あなた自身が性能について詳しくわからない、 または想定できないという点です。ちょっとしたクライアントでも どの程度のパフォーマンスなのかすぐに明らかにできます。 推奨する一番のやり方は、使う基本のデータ構造の数は絞って、 やることもシンプルして、実装についても、これまでに我々が これらの基本データ構造に対して議論してきたものを採用することです。 後々になって、自分が何をしているのかわかっている経験豊かなプログラマは これらのライブラリを効率よく使えるかもしれません。しかし経験の浅いプログラマは しばしば問題を抱えることがあります。これは、生徒のプログラム課題で 起こった話です。そんなに昔のことではありません。パーコレーションで ランダムに通過枠を作って行く課題がありますが、ある生徒は注意深く話を聞き 配列をつかってインデックスをランダムに選択して、 空きかどうかをチェックして、それを繰り返しました。配列サイズは N 対 N なので N^2 ですね。N^2 の時間がかかります。このアプリケーションでは比例時間で済みます。 しかし、もう一方の生徒は、以前に Java の経験があって 自分をエキスパートだと思っており、連結リストを使うと言いました。 Java ライブラリが使えるんだから、そんな間抜けなコードはダウンロードしてられない。 それを使ってインデックスをランダムに取り出して削除するだけだと。 そのプログラムは二乗時間がかかりました。みじめなケニーは 膨大なインスタンスのためにプログラムを実行してみた時に、処理が終わらないことに気付きました。 理由は、Java の連結リストの実装は、要素の取得に比例時間がかかります。 配列のように定数時間ではありません。ケニーにとっては そう考える事が難しく、実装から情報を得ることも難しく、 そういうわけで、とても遅いプログラムになるのです。 スイスアーミーナイフな実装、すなわち出来る事が多すぎると、 クライアント側の操作で求められる物が、効率よく実装されているかを知る事は困難です。 そういうわけで、本コースの方針は、生徒はライブラリは使うべきではない。 すでに授業で実装するまでは。最低限、あなたが 性能の特徴を理解していることの証です。それでは、スタックのアプリケーションをいくつか見てみましょう。 スタックはまさにコンピュータ処理の根幹をなすものです。 再帰処理を実装したりとか、頻繁にスタックを使います。 Web ブラウザの「戻る」ボタンを使う時は、元いた場所を スタックに保存します。では二つの例を見てみましょう。 一つはプログラムのコンパイルや実際の処理への置換えをどう扱うか、 もう一つは、PostScript 言語です。印刷や出版関連で 広く使われています。では、コンパイラの実装について、 関数でスタックを使っています。関数コール時に、すべての ローカル領域が push されます。戻り先アドレスと合わせて。そして 関数から戻る際は、戻り先アドレスとローカル領域を pop します。 スタックがすべての情報を持っているわけです。関数が自らを 呼んでいるかどうかは関係ありません。スタックは再帰も含まれます。 事実上、明示的にスタックを使えば、再帰プログラムを再帰なしにすることもできます。 gcd 関数があるとして、最大公約数を求めるものです。 p と q の最大公約数は、q  と p を q で割った余りの最大公約数です。 q がゼロになるまで繰り返すだけです。この図がまとめているように、 スタックに情報を保存するだけです。では、具体例で見ましょう。 この点をうまく見せて、同じコードであらゆるデータを処理できるやり方を 示しています。この例は、ダイクストラの 2-stack アルゴリズムで 計算式を評価します。目標は、計算式があるとして まさにプログラムの元になるものです。 話を進めましょう。計算式ですね。 オペランドと演算子があって、それを評価したい。 ダイクストラのアルゴリズムはとても簡単な表現です。 左から右に処理していきます。値なら加えます。 二つのスタックを使って、値であれば値のスタックに追加して、 演算子であれば演算子のスタックに追加します。左の括弧は無視します。 右括弧なら演算子と二つの値を pop して、結果を push します。 あれこれ言いましたがデモを見ましょう。空の値スタックと 演算子スタックから始めます。左から右に見ていきます。 必要な場合に思い出せるように、上に４つの手順を要約しています。 左括弧は無視して、値は値スタックに追加します。 ですので 1 は値スタックに入れます。演算子は演算子スタックに追加します。 + は演算子スタックに入れます。左括弧は無視します。 括弧を無視するのは不思議に思えますが、すぐにその理由は分かります。 値は値スタックに追加します。演算子は演算子スタックに追加します。 なんだかスタックに追加してばかりですね。そして右括弧に来ました。 ここで面白いことが起こります。つまり 最優先順位の演算子と値を持っていて、それがやりたい事です。 演算子を値に適用して、その結果を値スタックに戻します。 二つの値を取り出して、演算を行なって それを値スタックに戻します。それが右括弧でやることです。 続けましょう。* を追加します。左括弧は無視、4 を追加、そして * 。 5 を値スタックに追加します。スタックにたくさん入っていますね。 右括弧が残っていますので、計算を終わらせましょう。 先頭の二つの値をスタックから取り出して、先頭の演算子を演算子スタックから取り出して 計算して、結果を値スタックに戻します。さらに右括弧で 先頭の二つの値を取り出します。計算します。その値を値スタックに戻します。 そしてついに、最後の右括弧です。 二つの値を値スタックから取り出して、演算子を演算子スタックから取り出して、 計算して、結果を値スタックに戻す。これで計算が終わりました。 これが結果です。計算結果は 101 です。よろしいですか？これがダイクストラの 2-stack アルゴリズムを実装したコードです。 二つの異なるスタックがあります。演算子スタックは String 型で 演算子の記号だけです。値スタックは Double 型です。 同じコードのスタックですがジェネリクスを使っています。 二つの異なるデータ型を使っています。それからダイクストラのアルゴリズムを走らせます。 読み込んだ文字が左括弧なら何もしません。 プラスまたは倍記号なら push します。右括弧なら次にすすんで 演算子を pop します。+ 記号なら値スタックの先頭の二つの値を加算し、 * 記号なら、スタックの先頭の二つの値を乗算します。 そして結果を push します。そして終わったら、スタックにある値を表示するだけです。 計算式にスタックを使った、明瞭でエレガントな実装です。 他のデータ型でも簡単に拡張できます。 なぜこれがうまくいくのでしょうか？アルゴリズムが演算子に出会った時、 言うならば、その内部に、括弧、値、演算子、値、括弧とあるわけです。 括弧内で起こる事を、スタックに積むと捉えるとわかりやすいですね。 中身はともかく、2 と 3 を値スタックに加えて、 プラスを演算子スタックに加えて、右括弧になったら 演算を行なうことになります。そして続行します。あたかも 元から値が置き換えた場所にあったかのように。 括弧で括られた全ての演算に対して内側から見ていくだけです。 元の式が (1 + 5 * 20) であるかのように、繰り返すだけです。 それからもう一度、 1 + 100 に置き換えて、101 になります。 以上が、ダイクストラのアルゴリズムが動く理由です。なぜ動くか理解するのはそれなりに簡単ですよね。 さらに進んで、このアルゴリズムを拡張して、対数関数や サイン関数、その他の演算子を加えて、優先順位を持たせたり それらを連携させて複数演算を行なったり等々できます。 以上は、実際にコンパイラ開発において通る道であり、プログラムを 言語表現から計算処理に変換する方法の一つです。スタックを使うダイクストラのアルゴリズムは、 計算処理の基礎を知り、理解する一つの方法です。