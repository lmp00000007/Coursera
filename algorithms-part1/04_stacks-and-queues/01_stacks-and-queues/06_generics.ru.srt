1
00:00:01,082 --> 00:00:06,475
Далее мы рассмотрим как устранить другой
фундаментальный дефект реализаций,

2
00:00:06,475 --> 00:00:11,664
которые мы рассматривали до сих пор,
состоящий в том, что эти реализации хороши только

3
00:00:11,664 --> 00:00:16,503
для строк. Что если нам нужна очередь
или стек элементов другого типа данных?

4
00:00:16,503 --> 00:00:22,573
И это подводит нас к теме Generics.
Мы реализовали

5
00:00:22,573 --> 00:00:29,075
стек строк, но в приложениях возможны различные типы данных,

6
00:00:29,075 --> 00:00:35,675
которые нам, возможно, понадобится реализовать: стек чисел, URL-ссылок, машин, грузовиков

7
00:00:35,887 --> 00:00:41,386
и любых данных, с которыми мы работаем. Как мы реализуем стек

8
00:00:41,386 --> 00:00:46,796
или очередь для таких данных? Первое решение, которое мы можем рассмотреть

9
00:00:46,796 --> 00:00:51,869
и в действительности обязаны рассмотреть во многих программных средах,

10
00:00:51,869 --> 00:00:57,135
это реализация отдельного класса стека для каждого из типов данных, который мы используем.

11
00:00:57,135 --> 00:01:02,900
Это действительно кажется неудовлетворительным решением. У нас есть аккуратно написанный код,

12
00:01:02,900 --> 00:01:09,348
который поддерживает изменение размера массива и прочее, и мы будем копировать этот код

13
00:01:09,348 --> 00:01:15,129
и менять везде тип данных со строки на число или объект грузовик.

14
00:01:15,129 --> 00:01:21,039
Что если мы работаем с сотнями типов данных? У нас будут сотни разных реализаций?

15
00:01:21,039 --> 00:01:26,470
К сожалению, на заре Java у нас не было других вариантов,

16
00:01:26,470 --> 00:01:31,424
и существует достаточно языков программирования, где у нас нет других вариантов.

17
00:01:31,424 --> 00:01:36,425
Мы хотим рассмотреть современный подход к избеганию

18
00:01:36,425 --> 00:01:42,509
повторяющихся реализаций для каждого типа данных.

19
00:01:42,509 --> 00:01:51,399
Быстрым, широко распространённым решением является приведение типов.

20
00:01:51,704 --> 00:01:59,435
Так, мы делаем нашу реализацию с типом Object, а все в Java является подтипом

21
00:01:59,435 --> 00:02:07,050
Object. А затем, когда клиент
 будет использовать её, он будет просто приводить

22
00:02:07,050 --> 00:02:13,491
результат к соответствующему типу.
 Я не хочу тратить много времени на это,

23
00:02:13,491 --> 00:02:19,643
потому что я думаю, что это неудовлетворительное решение.
 Так, в этом примере у нас два разных типа

24
00:02:19,643 --> 00:02:25,878
с двумя стеками - один для яблок, другой для апельсинов.
 И затем, заботой клиента является

25
00:02:25,878 --> 00:02:32,007
при снятии элемента с яблочного стека,
 привести полученный объект к яблокам,
 чтобы удовлетворить требования системы проверки типов.

26
00:02:32,007 --> 00:02:37,103
Проблема с этим состоит в том, что клиентский код

27
00:02:37,270 --> 00:02:43,100
обязан делать такое приведение.
 И это оказывается сортом коварной ошибки,
 когда такое приведение не удается выполнить.

28
00:02:43,100 --> 00:02:51,458
А третий подход, о котором мы сейчас поговорим, использует дженерики (обобщения).

29
00:02:51,458 --> 00:03:00,357
И на этом пути клиентскому коду
 не требуется выполнять приведения типов.
 Мы можем обнаружить ошибки несоответствия типов

30
00:03:00,652 --> 00:03:08,018
во время компиляции кода,
 а не во время его выполнения.
Таким образом, в этом случае

31
00:03:08,018 --> 00:03:16,698
при задействовании механизма обобщений,
 у нас может быть параметр типа в нашем [обобщенном] классе.
 И он располагается внутри угловых скобок

32
00:03:17,011 --> 00:03:24,080
в коде. И затем..[кашель],
 если у нас стек яблок,

33
00:03:24,378 --> 00:03:32,980
и мы попытаемся поместить в этот стек яблок апельсин,
 то мы получим ошибку времени компиляции.

34
00:03:32,980 --> 00:03:38,027
Потому что этот стек был объявлен
 как содержащий только яблоки.

35
00:03:38,027 --> 00:03:44,492
Руководящим принципом
 хорошего модульного программирования

36
00:03:44,492 --> 00:03:51,730
является то, что мы приветствуем ошибки
 времени компиляции, и стараемся избегать
 ошибок времени выполнения.

37
00:03:51,730 --> 00:03:58,323
Потому что, если мы можем обнаруживать ошибки
 во время компиляции, то мы можем поставлять и развертывать

38
00:03:58,323 --> 00:04:04,310
реализации нашего API, и иметь
 некоторую уверенность в том, что они
 будут работать с любым клиентским кодом.

39
00:04:04,310 --> 00:04:09,664
Тогда как ошибка, которую нельзя
 обнаружить до времени выполнения, может

40
00:04:09,853 --> 00:04:16,082
проявиться в какой-то клиентской разработке
 даже годы спустя развертывания нашего программного обеспечения,

41
00:04:16,347 --> 00:04:23,849
и будет исключительно сложной для всех.
 Хорошо.

42
00:04:23,849 --> 00:04:32,268
Итак, на самом деле, в хорошей
 обобщенной реализации нетрудно

43
00:04:32,268 --> 00:04:40,637
заменить тип String на обобщенный
 тип везде, где он используется.
 Как в этом коде вот здесь.

44
00:04:40,637 --> 00:04:48,018
Слева показана наша реализация стека
 строк при помощи связного списка.

45
00:04:48,018 --> 00:04:53,095
Справа расположена обобщенная реализация.
 Таким образом, везде, где мы слева используем тип String,

46
00:04:53,095 --> 00:04:59,520
мы используем слово Item с правой стороны.
 А сверху, в объявлении класса,

47
00:04:59,520 --> 00:05:05,539
мы объявляем в угловых скобках, что Item - 
 это обобщенный тип, который мы будем использовать.

48
00:05:05,746 --> 00:05:11,836
Реализация вряд ли может
 быть более прямолинейной,

49
00:05:11,836 --> 00:05:18,862
и это великолепный путь решения задачи
работы с множеством типов данных с помощью
одной реализации.

50
00:05:19,298 --> 00:05:29,269
С массивами это не совсем работает.
 И, еще раз, все языки программирования...

51
00:05:29,269 --> 00:05:35,404
Знаете, у многих языков программирования есть трудности с этим,
 и у языка программирования Java здесь специфическое затруднение.

52
00:05:35,404 --> 00:05:41,231
Так, здесь мы просто хотим объявить новый массив,
 используя наше обобщенное имя Item,

53
00:05:41,443 --> 00:05:48,057
как показано вот в этой подсвеченной строке.
 В остальном же всё то же самое.

54
00:05:48,057 --> 00:05:55,059
К сожалению, Java не разрешает
 создание обобщенных массивов.

55
00:05:55,059 --> 00:06:02,125
Для этого есть различные технические причины.
 И вы можете почитать обширные дебаты на эту тему

56
00:06:02,125 --> 00:06:08,718
в интернете. Они выходят за рамки нашего внимания.
 А пока нам нужно использовать приведение типов,

57
00:06:08,718 --> 00:06:15,322
чтобы все заработало. Мы создаем массив
 с элементами типа Object, и затем мы приводим его

58
00:06:15,322 --> 00:06:22,461
к массиву с элементами типа Item.
 Далее, на мой взгляд, хороший код
 не должен содержать приведения типов.

59
00:06:22,461 --> 00:06:28,622
Та что мы стремимся избегать приведения
 типов настолько, насколько это возможно.
 Потому что, на самом деле,

60
00:06:28,622 --> 00:06:35,306
приведение типов является признанием слабости
в том, что мы делаем. Но в данном случае

61
00:06:35,306 --> 00:06:41,647
нам придется поместить это единственное приведение типов.
 Так что мы осведомлены о том, что это приведение ужасно,

62
00:06:41,647 --> 00:06:47,734
знаем, что этот код не может быть отнесен к хорошему.
 И это не то решение, к которому мы бы пришли по собственной воле.

63
00:06:47,734 --> 00:06:52,789
И, я думаю, это нежелательная деталь
 для настолько простого кода.

64
00:06:52,789 --> 00:06:58,276
Но, к счастью, мы можем справиться почти со всем,
 что мы собираемся сделать в рамках этого курса,

65
00:06:58,276 --> 00:07:04,297
просто зная об этом единственном ужасном приведении типов.

66
00:07:04,297 --> 00:07:10,490
Так, теперь, когда мы скомпилируем эту
 программу, мы получим предупреждение

67
00:07:10,490 --> 00:07:15,610
от Java. Оно скажет, что мы используем
 непроверенные или небезопасные операции,

68
00:07:15,610 --> 00:07:21,787
и нам стоит перекомпилировать с опцией -Xlint:unchecked,
 чтобы увидеть детали. Так что мы так и поступим.

69
00:07:21,787 --> 00:07:27,247
И нам сообщат, что мы поместили непроверяемое
 приведение типов в код,
и нас об этом предупреждают,

70
00:07:27,247 --> 00:07:33,428
потому что не следует ставить в код непроверяемое
 приведение типов. Ну ладно, вы будете получать

71
00:07:33,428 --> 00:07:40,014
такое сообщение всегда при компиляции
 подобного кода. Я думаю, может быть,

72
00:07:40,014 --> 00:07:45,494
им следовало бы добавить к этому сообщению такой текст:
 "Мы приносим свои извинения за то, что заставляем вас так делать".

73
00:07:45,494 --> 00:07:51,770
Не наша вина в том, что нам пришлось так сделать.
 Мы вынуждены сделать это из-за ваших требований,

74
00:07:51,770 --> 00:07:57,908
не разрешающих нам объявлять обобщенные массивы.
Таким образом, вооружившись этим замечанием,

75
00:07:57,908 --> 00:08:03,915
пожалуйста, не думайте, что с вашим кодом
 что-то не так, если вы следуете нашим предписаниям

76
00:08:03,915 --> 00:08:10,596
и получаете такое предупреждающее сообщение.
 Хорошо. Далее, есть одна деталь,

77
00:08:10,596 --> 00:08:19,274
о которой заботится Java,
 и она касается примитивных типов. [кашель]

78
00:08:19,274 --> 00:08:26,636
Используемый нами обобщенный тип
 предназначен для использования с объектными типами.
 Мы приводим к целевому типу массив объектов.

79
00:08:26,876 --> 00:08:34,517
Поэтому,чтобы с помощью обобщенных типов 
управиться [с примитивными типами],
 мы должны использовать их объектные оболочки.

80
00:08:34,782 --> 00:08:40,751
Так, Integer с большой буквы для int, и так далее.
 Многие из вас, вероятно, знакомы с этим.

81
00:08:40,751 --> 00:08:46,419
И есть в Java процесс, называемый автоупаковкой,
 который автоматически

82
00:08:46,419 --> 00:08:51,827
проводит преобразование между примитивными
 типами и их объектными оболочками.
 Так что все это обслуживает

83
00:08:51,827 --> 00:08:57,633
задачу работы с примитивными типами как бы за сценой.

84
00:08:57,633 --> 00:09:04,693
И, в качестве итога, мы можем сформулировать API
 для обобщенных стеков, которое работает

85
00:09:04,693 --> 00:09:10,665
с любыми типами данных. И мы получили две реализации,
 с помощью связных списков и массивов, которые работают

86
00:09:10,665 --> 00:09:20,867
очень хорошо [кашель] для любого типа данных,
 используя изменение размера массивов

87
00:09:20,867 --> 00:09:26,035
или связные списки, как мы описывали.