좋아요. 그것들은 몇가지 기본적인 데이터 구조와 구현이고 그건 매우 기초적이고 간단하게 보이지만 사실 즉시 우리는 이런 기본적인 개념과 우리가 다음에 고려해야할 것들의 몇가지 매우 정교한 어플리케이션을 얻을 수 있습니다. 이제, 첫번째로 언급할 것은 우리가 Java 총서에서 구현하거나 발견하는 데이터 종류와 데이터 구조의 종류에 관한 것입니다. 자, 그것은 많은 프로그래밍 환경에서 사실입니다. 그래서, 예를 들어, Java 총서에서 언급된 여러분이 찾을 수 있는 단어인 스택과 큐가 있고, Java 모음 총서와 여기에 표시된 목록 접속기라고 소위 일컬어지는 것이 있습니다.
그래서 Java는 일련의 항목들에 대한 일반적인 API가 있고 그것은 마치, 끝에 붙이기, 처음부터 제거하기 등을 하고 있습니다. 크기 조정 배열의 사용은, 우리가 고려하는 많은 원칙이 링크 목록 인터페이스에도 사용합니다. 그럼, 왜 그것들을 그저 사용하지 않을까요? 왜 우리 고유의 구현을 사용하나요? 음, 이러한 총서 코드에서 종종 있는 문제는 점점 더 많은 작업이 추가되고 API는 너무 광범위하거나 비대해지는 위원회 현상에 의해 설계되는 경우가 있습니다. 같은 API로 많은 작업을 하는 것은, 여러분이 알다시피, 좋은 생각이 아닙니다. 그리고 잠시 후에 예시를 볼 것입니다. 문제는, 실제 문제는 여러분이 그것을 할 때 여러분이 그 성능에 대해 많이 모르거나 여러분이 그 성능에 대해 충분히 추정할 수 없다는 것입니다. 그리고 여러분은 심지어 단순한 클라이언트를 위한 성능에 즉시 도달할 수 있습니다. 그래서 우리가 추천하는 우리의 가장 좋은 연습은 우리가 사용하는 이런 기본적인 데이터 구조가 너무 적고 간단한 것은 어서 가서 우리가 막 언급한 이런 근본적인 데이터 구조의 구현을 사용하는 것입니다. 아마도 나중에, 나중에, 자신이 무엇을 하고 있는지 아는 그 또는 그녀인 경험 많은 프로그래머가 이런 총서 콜렉션을 효과적으로 사용할 수 있을 것입니다. 하지만 경험이 부족한 프로그래머들은 종종 그것에 어려움을 겪습니다. 여리 얼마 전에 있었던 학생 프로그래밍 과제의 전쟁 이야기가 있습니다. 그래서, 우리는 여러분이 무작위 추출 시스템에서 무작위로 오픈된 사이트를 만들어야 하는 과제가 있습니다. 우리는 우리가 말하는 것에 집중하고 배열을 사용하고 그 배열에 색인을 무작위로 골라 넣어 그들이 열리고, 그리고 반복되는지 확인할 수 있는 한 학생이 있습니다. 그래서 배열이 N 곱하기 N으로, N제곱 값이고 이 어플리케이션에서 실제로 선형 시간이 N제곱 시간 소요됩니다. 하지만 우리는 우리에게 오기 전에 자바를 전공하고 그 스스로 전문가라고 생각했던 또다른 학생이 있는데 말하기를 음, 저는 제가 Java 총서를 사용할 수 있고 저는 여러분의 바보같은 코드를 다운받는데 걱정이 없기 때문에 연결된 리스트를 사용할 것이라고 말했습니다. 그래서, 저는 단지 그것을 이용해서 무작위로 색인을 선택하고 지우고 우리가 요청한 큰 인스턴스에 대해 그의 프로그램이 끝나지 않았다는 것을 알아내기 위해 작동을 시도할 때 그 프로그램은 이차 시간과 가엾은 Kenny가 걸립니다. 그리고 그 이유는 Java 연결된 리스트 실행은 주어진 인덱스로 항목을 찾기 위해 선형 시간이 걸리기 때문입니다. 배열과 같은 일정한 시간이 아닙니다. 그리고 Kenny가 그것에 대해 생각하기에 어렵고 구현에서 그 정보를 이끌어 내기에 어려워서 프로그램은 매우 느립니다. 그리고 꽤 많은 작업에서 스위스 칼을 사용하여 여러분의 클라이언트의 요구인 특정 작업 세트가 효율적으로 구현했는지 아닌지를 알기가 어렵습니다. 그래서 우리가 강의에서 시행할 때까지 학생들은 총서를 이용하지 않아야 한다는 것이 이 과정에서 우리의 주장입니다. 최소한 여러분이 성능 특성을 이해하고 있다는 것이라는 말입니다. 그럼 이제,
스택의 일부 어플리케이션을 살펴보겠습니다. 스택은 정말로 실제로 기본적이고 근본적인 연산입니다 왜냐하면 그들은 상속, 재귀 등을 하는데, 종종 매일 여러분이 글을 쓰고, 여러분이 스택에 저장해 둔 장소인, 웹 브라우저에서 뒤로 가기 버튼을 사용할 때 여러분은 스택을 사용합니다. 바로 지금 우리는 두가지 예시를 보겠습니다. 하나는, 프로그래밍 언어로 편집하거나 실제 계산으로 해석해야 하는 경우이고 다른 하나는 인쇄와 게시용으로 널리 사용되는 포스트스크립트 언어입니다. 그래서, 따라서 편집자가 기능을 구현하는 방법은 스택을 사용하는 것입니다.
기능 호출을 할 때 전체 로컬 환경이 푸시되고 반환 주소와 마찬가지이고 기능 반환이 로컬 환경에서 반환 주소를 나타냅니다. 그래서 모든 정보를 포함하는 스택이 있고 기능이 스스로 호출하는지 아닌지는 의미가 없습니다. 스택은 반복을 포함합니다. 사실, 재귀 프로그램을 그렇지 않게 만들기 위해서 여러분은 항상 명시적 스택을 사용할 수 있습니다. 그래서, 이것은 우리가 GCD기능을 갖고 있을 때, 가장 큰 공통 분모, 가장 큰 공통 분모 p와 q의 계산은 q와 p모드q의 가장 큰 공통 분모이고 그것은 q가 0이 될 때까지 스스로를 단지 호출합니다.
그리고 이 그래픽을 통합함으로써, 그것은 단지 스택에 정보를 정하는 것으로 작업을 합니다. 이제 구체적인 예시인 이를 실제로 보여주고 또한 동일한 코드로 다양한 유형의 데이터를 처리할 수 있는 유용성을 보여 주는 이 예시는 산술 표현 평가를 위한 Dijkstra의 2-스택 알고리즘입니다. 그래서 목적은, 여러분이 산술식을 받은 것입니다 이것은 단지 실제로 프로그램에 대한 단순한 입장을 나타내는 것과 같고 우리는 그것에 대해 곧 이야기 하겠지만, 산술식이라 합시다. 우리는 피연산자와 연산자를 가지고 있고 여러분은 그것을 평가하고자합니다. 그리고 Dijkstra의 알고리즘은 표현하기 매우 쉽습니다. 여러분은 왼쪽에서 오른쪽으로 표현을 통해 처리합니다. 여러분이 값을 보면, 그것을 표시하고, 여러분은 스택 두개를 유지하고 여러분이 값을 보면, 여러분은 값 스택에 표시하고 여러분이 연산자를 보면, 여러분은 연산 스택에 표시합니다.
왼쪽 괄호는 무시합니다. 오른쪽 괄호는, 여러분이 연산자와 두값을 표시하고 결과를 누릅니다. 이제 많은 용어들, 데모를 살펴보겠습니다. 그럼 우리는 빈 값 스택과 연산 스택으로 시작하여 우리는 왼쪽에서 오른쪽으로 이동하겠습니다. 그래서, 위에 있는 그것들은 우리가 마지막으로 끝낼 수 있는 네가지 유형의 것들과 우리가 무시한 왼쪽 괄호, 우리가 값 스택에 넣은 값을 요약한 것입니다. 그러면, 그것은 값 스택으로 오른쪽으로 갑니다.
연산자는, 우리가 연산 스택에 추가합니다. 그리고 그것은 연산 스택에 추가됩니다.
왼쪽 괄호는 무시합니다. 괄호를 무시하는 것은 이상해 보이고 우리는 곧 그것으로 되돌아 갈 것입니다. 값은, 값 스택에 넣으세요. 연산자는, 연산 스택에 넣으세요. 우리가 스택에 일을 놓은 것을 제외하고는 별로 하는 일이 없어 보이는데 이제, 우리가 오른쪽으로 괄호에 올 때, 그것은 흥미로운 일이 될 때입니다.
그것이 말하는 것은 여러분이 상위 연산자와 상위 두가지 값이 있고 그것이 여러분이 하고 싶은 것입니다. 연산자가 그 값으로 제공하고 얻은 결과 값을 여러분이 다시 연산 스택에 추가합니다. 그래서, 우리는 상위 두가지를 떼어내고, 우리는 연산하고 나서 우리는 우리가 얻은 것을 값 스택에 넣습니다. 그리고 그것은 오른쪽 괄호입니다. 그래서 이제 계속 따라서 우리는 별을 추가합니다.
왼쪽 괄호는, 무시합니다. 별, 네개 추가. 오른쪽은 값 스택으로 가고 이제 우리는 스택에 많은 일을 두었고 우리는 오른쪽 괄호를 통해 가서 계산을 끝낼 것이고, 상위 두 항목을 스택에서 떼어내고
연산 스택에서 상위 연산자를 떼어내고, 작업을 수행하고, 값 스택의 결과에 다시 반영합니다. 또다른 오른쪽으로 괄호는, 상위 두 값을 지웁니다.
작업을 수행합니다. 값 스택에 값을 추가하고 마지막으로, 마지막 오른쪽 괄호는, 값 스택의 두 연산자, 값 스택의 연산자, 그리고 연산 스택의 연산자를 갖고, 작업을 수행하고, 값 스택의 결과를 다시 추가합니다. 그리고 우리는 계산의 끝에 있고 그것이 결과입니다.
산술식의 값은 101입니다. 됐나요? 네. 여기 Dijkstra의 2-스택 알고리즘을 구현하는 코드가 있습니다. 우리는 두가지 다른 스택이 있습니다. 피연산자 스택, 연산 스택은 문자열이고, 그건 단지 우리의 연산자인 문자가 될 수 있습니다. 그러면 우리의 값 스택은 두배가 되어서 그것은 같은 스택 코드이지만 포괄적으로, 우리는, 음, 두가지 다른 유형의 데이터를 사용하고 있습니다. 그런 다음 단순히 Dijkstra의 알고리즘을 수행하기만 하면 됩니다. 만약 우리가 왼쪽 괄호가 있다면... 새로운 문자열을 읽습니다. 만약 우리가 왼쪽 괄호를 가지고 있다면, 아무것도 하지 마세요. 만약 우리가 덧셈이나 곱이 있다면, 미세요. 만약 우리가 오른쪽 괄호가 있다면, 그러면 가서 연산을 하세요. 그리고 만약 그것이 플러스라면, 값 스택의 맨 위에 있는 두 값의 결과를 더하고 만약 그것이 별이라면, 스택의 맨 위에 있는 두 값을 곱하고, 그리고 나서 결과를 밀어넣습니다. 그래서 여러분이 작업을 끝내면 여러분은 스택에서 값을 인쇄하면 그것은 모든 산술식에 스택을 사용하여 멋지고 우아하게 구현됩니다. 그리고 다른 종류의 것들을 다루기 위해 이것을 확장하는 것은 쉽습니다 그래서 왜 이것이 작동할까요? 음, 알고리즘이 내부적으로 연산자를 직면하게 될 때, 우리는 (피연산자, 연산자, 피연산자)의 형태를 얻게되고 내부적으로 무엇이든 간에 꼭대기까지 쌓아가는 것과 쌓여진 값의 꼭대기에 두번 세번 쌓아가는 것을 확인하기가 쉽고 (피연산자, 연산자, 피연산자)를 실행했을 때 운용을 실행할 것이고 재배치된 값이 원본인 것처럼 정확히 실행할 것입니다. 그래서, 1, 1+100, 101을 대체하면서 원래의 표현이 마치 (1+5)20과 이것을 되풀이하는 논지를 반복하는 것과 같은 괄호 안의 모든 연산 안팍으로 실행하는 것입니다. 그것이, 그것이 Dijkstra의 알고리즘이 작동하는 이유입니다. 사실
이것이 왜 효과가 있는지 이해하기는 꽤 쉽습니다. 그리고 여러분은 가서 로그와 사인 또는 다른 연산자와 같은 기능을 추가하여 이 알고리즘을 확장하고 연산자들 사이에 우선순위를 지정하여, 그들을 연결하고 다양한 작업 등을 우선 할 수 있습니다. 그리고 실제로 그것은 프로그래밍 언어에서 계산까지의 프로그램을 변환하는 방법이나 컴파일러를 개발하는 과정에 있기 때문에, 그래서 스택을 사용하는 Dijkstra의 알고리즘은 연산의 기초를 입력하고 이해하는 한가지 방법입니다.