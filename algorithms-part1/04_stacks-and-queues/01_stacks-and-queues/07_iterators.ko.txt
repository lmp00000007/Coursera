좋아요. Java가 제공하는 또 다른 기능으로는 우리의 기본 데이터 유형에 추가할 가치가 확실히 있는 매우 우아한 소형 클라이언트 코드를 이끌고 그것은 반복이고, 이제 우리가 이야기할 내용입니다. 그래서, 우리가 하려는 것은 클라이언트가 컬렉션의 항목들을 통해 반복하기를 허용하는 것입니다. 하지만 우리는 우리가 배열 또는 링크 목록이나 무엇이든 우리가 염두할 수도 있는 내부 표현을 사용하는지 여부를 아는 클라이언트가 없습니다. 클라이언트와 관련이 없습니다. 그리고 많은 클라이언트들이 단지 하고 싶은 것은 컬렉션에 있는 것들을 통해 반복하는 것입니다. 하지만 Java는 반복이라 불리는 좋은 해결책을 제공합니다. 그래서 우리가 하려는 것은 우리의 스택, 그리고 큐, 그리고 우리가 Iterable 인터페이스라 불리는 도구를 고려하는 다른 데이터 구조들을 어떻게 만드는지 살펴보고 그리고 우리가 사용한 어떤 도구를 사용했는지에 상관없이 클라이언트 코드에 작동될 것이므로 그것의 자세한 내용을 살펴보겠습니다. 그럼 Iterable은 뭘까요? 음, Java 용어로 Iterable이라는 것은, 그것은, 그것은 반복자를 되돌리는 방법을 가진 분류입니다. 그래서 반복자는 무엇일까요? 음 반복자는 어떤, hasNext와 next() 방법을 가진 분류입니다. Java는 또한 remove()를 허용합니다.
우리는 그건 나쁜 소식이라 생각하고, 우리가 사용하지 않으면 버그 디버깅 문제인, 디버그가 확산될 수 있습니다. 따라서, 이것은 hasNext()와 next() 이고 그래서 데이터 구조 도관가능하게 하기 위해, 우리는 그것들을 실행할 것입니다. 이동 운반하기에 짐이 많아 보이는데, 우리가 그렇게 하는데 이유는, 우리가 할 수 있는 것을 우리가 문제를 일으키는 이유는, 만약 우리가 도관가능한 데이터 구조를 우리가 가진다면, 우리는 Java에서 각 항목을 요구하는 매우 간편하고 우아한 클라이언트 코드를 사용할 수 있습니다. 그래서 만약 우리가 스택이 있다면 우리는 말할 수 있습니다 - (for String s : stack). 그것은 스택에서 각 줄을 의미합니다 - 출력하세요. 그리고 만약 우리가 지금 그것이 없었다면, 만약 우리가 반복자를 사용한다면, 우리는 진행하고 이 수기 코드를 쓸 수 있지만 그것은 속기와 같은 것이기 때문에 아무도 그러지 않을 것이거나 우리는 이런 반복을 하기 위해서 많은 불필요한 푸시와 팝들을 하는 클리이언트 코드를 써야할지도 모릅니다. 그래서 핵심은 데이터 구조 안의 아이템을 통해 반복하기 위해서 꽤 작은 클라이언트 코드를 가질 수 있는 것이고 그래서 우리는 우리의 모든 기본적인 데이터 구조들에 반복을 제공할 것이고 그런 노력을 할 만한 가치가 있는 일을 하는 건 그리 어렵지 않습니다. 그래서 여기 링크 목록은 다음과 같습니다. 그렇다면 iterable을 실행해야하면 실행 iterable은 무슨 뜻일까요? 그것은 반복자를 돌리는 iterator() 방법을 갖고 있어야 합니다. 그럼 반복자는 무엇일까요? 그럼, 우리는 내부 분류를 사용하겠습니다. 이 경우에, 우리는 그것을 반복자를 구현하는 ListIterator라고 부르고 그것은 일반적입니다. 그리고 기본적으로 이것은 이런 hasNext() and next() 방법으로 실행해야합니다. 그리고 의미론은 이름에서 정말 명확하게 나옵니다. hasNext()는 우리가 한 것이 거짓으로 돌아온다면 하게 되어 있습니다. 만약 우리가 진실로 되돌아 와야 하는 것을 하지 않는다면 next()는 반복되면서 다음 항목을 주게 되어있습니다. 그래서 만약 이것이 연계된 목록잉라면 우리는 처음에 시작할 것입니다. 이것이 목록에서 우리가 가진 첫번째 항목이고 우리는 우리가 반복하는 현재의 것인 변동이 심한 현재 이 내부 반복자 사례를 유지할 것입니다. 따라서, 우리가 첫번째를 지우고 싶다면 다음 것도 똑같은 방법으로 하세요. 우리는 현재 항목을 끌어내고 그런 다음 현재 참조와 반환 항목을 발전시켰습니다. 현재에서 다음 위치로 이동합니다. 제가 보여준 대로 클라이언트는 항상 hasNext()를 테스트할 것이고 그 이전 남은 코드와 그리고 그것이 아무 가치 없게 될 때 그것은 반복의 정지에서 거짓으로 돌아올 것입니다. 하지만 우리의 반복을 위해, 우리는 단지 next() and hasNext() 실행과 어쩌면 완료하기 위한 현지 사례 변수 사용에 대해 걱정해야 합니다. 우리는 아마도 방탄 코드를 만들어야 합니다 - 예외를 두면 만약 클라이언트가 항목이 없는 상태에서 next()를 부르려고 시도하고 remove()를 부르기 위해 시도한다면, 우리는 reomove()를 지지하지 않을 것입니다. 배열의 경우, 훨씬 간단합니다. 그럼 이제 이 반복자로 우리는 우리가 아이템을 통한 순서에 대한 통제를 갖고 그래서 그것은 의미론과 데이터 구조에 동의할 것이고 그래서 아마도 스택 내에서 여러분은 스택에서 나오는 순서 같은 스택 순서에서 그것들을 가져오길 원해서 그것은 배열에서 역순이고 그래서 이 경우에 next()는 그냥 감소하고 다음 것을 반환하고 우리의 예시 변수는 배열에서의 색인입니다. 그리고나서 hasNext()는 그것이 긍정적인 것이라면 괜찮습니다. 그래서 이 작은 Java [기침] 코드는 이 반복 기능을 제공하지만 실제로 이 프레임워크 내에서 너무 많은 작업을 하지 않고 여러분은 여러분 고유의 데이터 유형에 대해 이 방법을 구현하는 방법을 확인할 수 있고 우리는 우리가 마주할 객체의 집합을 포함하는 모든 기본적인 데이터 유형에 이 패러다임을 사용할 것입니다. 좋아요, 그리고 사실, 그것은 우리가 많은 클라이언에게 실제로 어떤 주문을 받을지는 중요하지 않게 우리를 이끌었습니다. 실제로 우리가 종종 하는 것은 그냥 아이템들을 콜렉션에 삽입하고나서, 나중에, 우리가 가진 아이템들을 통해 반복하는 것입니다. 그 데이터 구조는 가방이라 불리고 이제 API가 어떻게 생겼는지 살펴보겠습니다. 순서는 중요하지 않으므로 우리가 하고자 하는 것은 아마도 여러분이 사이즈를 알고싶은 아이템을 추가하고 우리는 가방 안에 있는 모든 아이템을 통해 반복하기를 원합니다. 따라서 이것은 간단하고 좁은 API지만 여전히 운영의 중요하고 작은 컬렉션을 표시하고, 그리고 우리는 이것을 사용할 것이고 우리는 이미 구현을 보았습니다. 여러분은 그냥 스택을 쌓아서 팝, 또는 큐를 제거하고 데큐를 제거하고 [기침] 그리고 여러분은 유용한 데이터 구조의 좋은 반복을 가질 것입니다.