1
00:00:01,010 --> 00:00:06,509
Java还提供了另一种能够使客户端代码保持优雅紧凑

2
00:00:06,509 --> 00:00:11,759
绝对值得添加到我们的基本数据类型的特性

3
00:00:11,759 --> 00:00:17,058
这就是我们马上要讲到的迭代器

4
00:00:17,058 --> 00:00:23,176
我们想要做的是允许客户端遍历集合中的元素

5
00:00:23,364 --> 00:00:28,286
但不必让客户端知道我们是用数组还是链表

6
00:00:28,286 --> 00:00:34,620
还是我们考虑的任何内部表示，这对于客户端是不相关的

7
00:00:34,620 --> 00:00:41,189
大多数客户端想做的只是遍历集合中的元素

8
00:00:41,189 --> 00:00:47,304
而Java的确提供了一个美妙的解决方式，就是遍历机制

9
00:00:47,304 --> 00:00:53,523
下面我们要做的是看看如何使我们的栈、队列和后面

10
00:00:53,523 --> 00:00:58,914
要讲到的其他数据结构实现所谓的Iterable（可遍历类）接口

11
00:00:59,108 --> 00:01:05,662
无论我们使用哪种实现，对于客户端都能正常使用

12
00:01:05,662 --> 00:01:13,497
好，我们来具体看看。那么什么是Iterable呢？在Java语言中

13
00:01:13,497 --> 00:01:20,914
Iterable是具有返回迭代器的方法的一种类

14
00:01:21,182 --> 00:01:29,271
那么什么是迭代器？迭代器是具有hasNext()和

15
00:01:29,271 --> 00:01:37,519
next()方法的类。Java还允许remove()方法
我们认为这个不是好特性

16
00:01:37,519 --> 00:01:45,861
我们不用这个特性，它有可能成为调试隐患
那么，只要有hasNext()和

17
00:01:45,861 --> 00:01:52,828
next()方法就使得数据结构是可遍历的，我们要实现这两个方法

18
00:01:52,828 --> 00:01:58,837
这看起来好像有点累赘，我们要这么自找麻烦的原因是

19
00:01:58,837 --> 00:02:04,768
如果我们的数据结构是可遍历的

20
00:02:04,768 --> 00:02:10,795
在Java中可以使用非常紧凑优雅的客户端代码

21
00:02:10,795 --> 00:02:16,185
即所谓的for-each语句。所以如果我们有一个栈 stack
可以写(for String s: stack)

22
00:02:16,185 --> 00:02:22,587
表示对栈中每个字符串，执行打印输出。如果我们

23
00:02:22,587 --> 00:02:29,442
用迭代器，我们也可以写成这种完整形式的代码

24
00:02:29,442 --> 00:02:35,550
但不会有人这么做，因为它和这种简写形式是等价的

25
00:02:35,550 --> 00:02:42,710
不使用迭代器的话要实现遍历客户端代码中就要执行

26
00:02:42,710 --> 00:02:48,386
非常多不必要的入栈出栈操作。所以这是能够让遍历

27
00:02:48,386 --> 00:02:53,928
数据结构中的元素的客户端代码变得这么紧凑的关键所在

28
00:02:53,928 --> 00:02:59,370
我们要给我们所有的基本数据结构提供遍历机制

29
00:02:59,370 --> 00:03:05,712
实现这个功能并不特别难，而且绝对值得投入精力

30
00:03:05,712 --> 00:03:12,877
这是基于链表的栈的代码。接下来我们要实现Iterable接口

31
00:03:12,877 --> 00:03:19,470
实现Iterable接口意味着什么呢？这个类需要有iterator()方法

32
00:03:19,470 --> 00:03:25,017
返回迭代器。什么是迭代器呢？我们要用一个内部类

33
00:03:25,017 --> 00:03:30,926
这个例子中，命名为ListIterator的内部类实现Iterator接口

34
00:03:30,926 --> 00:03:36,498
并且是泛化（generic）的。这个类主要完成的是实现这些方法

35
00:03:36,498 --> 00:03:42,158
hasNext()和next()。从名字就能清楚知道它们的语义。hasNext()

36
00:03:42,365 --> 00:03:47,917
在完成遍历之后会返回“假”。如果还没有完成，应该

37
00:03:47,917 --> 00:03:53,462
返回“真”。next()方法应当提供要遍历的下一个元素

38
00:03:53,462 --> 00:03:58,973
所以如果是基于链表的数据结构，我们要从表头first元素开始

39
00:03:58,973 --> 00:04:04,896
这是处于表头的元素，我们要维护迭代器中的实例变量current

40
00:04:04,896 --> 00:04:10,461
存储当前正在遍历的元素

41
00:04:10,461 --> 00:04:15,439
获取下一个元素，就像要移除表头一样。我们取出current元素

42
00:04:15,439 --> 00:04:21,073
current引用指向下一个元素，并返回item。也就将current

43
00:04:21,073 --> 00:04:27,483
移动到了下一个元素上。客户端会一直测试hasNext()，就像

44
00:04:27,483 --> 00:04:35,069
前面那段代码里，所以当current变成空指针，hasNext返回“否”

45
00:04:35,069 --> 00:04:41,084
终止遍历。在我们的遍历中，我们只需要关注实现

46
00:04:41,084 --> 00:04:47,952
next()和hasNext()方法，使用一个局部实例变量就能完成

47
00:04:47,952 --> 00:04:54,457
我们应该让代码能“防弹”—如果遍历已经终止客户端试图

48
00:04:54,457 --> 00:05:01,339
调用next()或者任何时候试图调用remove()时抛出异常

49
00:05:01,339 --> 00:05:07,326
我们不提供remove()方法。对于基于数组的实现，就更简单了

50
00:05:07,326 --> 00:05:13,041
使用迭代器我们能控制遍历顺序，使其

51
00:05:13,041 --> 00:05:18,834
符合语义和数据结构。遍历栈时你要让元素

52
00:05:18,834 --> 00:05:24,504
以出栈的顺序返回，即对于数组是逆序的

53
00:05:24,504 --> 00:05:31,686
那么这种情况下next() 就将索引减1，返回下一个元素

54
00:05:31,686 --> 00:05:37,522
而我们的实例变量是数组的索引。只要该变量为正，hasNext()

55
00:05:37,522 --> 00:05:48,052
返回“真”。要实现这个遍历机制只需要写几行Java代码

56
00:05:48,052 --> 00:05:55,229
而实际上在这个框架下不需要做很多事

57
00:05:55,229 --> 00:06:02,108
当你实现你自己的数据类型的时候就会看到。以后会遇到的

58
00:06:02,108 --> 00:06:07,873
涉及对象集合的基本数据类型中我们都会用这种编程范式

59
00:06:07,873 --> 00:06:14,633
好，这就引出实际上很多客户端

60
00:06:14,633 --> 00:06:20,905
并不关心我们返回元素的顺序。我们经常做的是

61
00:06:20,905 --> 00:06:27,275
直接向集合中插入元素，接下来遍历已有的元素

62
00:06:27,275 --> 00:06:34,410
这样的数据结构叫做背包，我们来看看它的API

63
00:06:34,410 --> 00:06:40,680
顺序并不重要所以我们想要能直接添加元素

64
00:06:40,913 --> 00:06:47,303
也许还想知道集合大小，我们想遍历背包中所有的元素

65
00:06:47,303 --> 00:06:53,986
这个API更简单，功能更少，但依然提供了几个

66
00:06:53,986 --> 00:07:00,370
重要的操作。使用这个API，我们已经看过实现了

67
00:07:00,370 --> 00:07:06,512
只需要将栈的出栈操作或者队列的出队操作去掉

68
00:07:09,792 --> 00:07:13,072
就能获得这个有用的数据结构的良好的实现