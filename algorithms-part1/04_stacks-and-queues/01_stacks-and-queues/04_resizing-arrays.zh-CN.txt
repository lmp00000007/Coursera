那么，之前讲的栈的基本数组实现具有需要 客户端事先提供栈的最大容量的缺点。现在 我们来看解决这个问题的技术。我们没有 严格按照API的要求。API就是要求我们能够建立一个栈 并且能够增长或者缩小到任意大小。那么我们 应该怎么做呢？你首先会想到的也许是当客户端入栈新元素时 将栈的大小增加1，当出栈时 将栈的大小减小1。代码实现不难，但是不值得这么做，因为这么做 开销太大了。因为你必须创建大小大一个元素的 新的数组，然后把所有的元素复制到新的数组中。所以如果栈大小为N-1 插入N个元素需要的时间和N成正比 如果栈大小为N-2，需要正比于N-1的时间。所以前N个元素需要的时间就是对 前N个整数求和，我们知道这大约是N^2 / 2。往栈里插入N个元素 需要平方时间，我们已经看到过很多次，这样的性能对于 巨大的问题是不可接受的。那么，调整大小是个挑战 但要通过某种方式确保它并不会经常发生。处理这个问题 有个著名的方法叫反复倍增，当数组填满时 建立一个大小翻倍的新数组，然后将所有元素复制过去，我们就不会 那么频繁地创建新数组。这就是那个方法的实现。从大小为1的 数组开始。如果我们检测到N即栈中元素的个数与数组 长度相等，则栈满了，那么我们就在插入元素之前 将数组长度调整为两倍。我们如何调整为更大的数组呢？ 我们创建具有目标容量的新的数组，然后把 当前栈复制到新数组的前一半，然后返回 重新设置实例变量，我们的栈就有了更大的数组 这样做导致如果你向一个具有这种 数组表示的栈中插入N个元素，时间复杂度 与N而不是N^2成正比。因为你只有在数组大小翻倍时 才创建新的数组。而当数组翻倍时，你已经往栈里插入了 那么多的元素。所以平均下来就像每次插入只需要一个操作 所以，如果我们计算一下开销，插入前N个元素 你不需要花费从1到N之和的时间，而是 对二的幂从1到N求和 这样，总的开销大约是3N。所以，先要访问数组一次，对于复制 要访问两次。所以，要插入元素，大约需要访问数组三次 这个图标是观察时间开销的另一种方式，表示出了实现 入栈操作需要访问数组的次数。每次遇到2的幂，需要进行那么多次 数组访问，但是从宏观上来看你是将那些元素放在栈上花去了那么多时间 这叫做平摊分析。考虑开销时 将总的开销平均给所有的操作。这是一个很好而且 有用的平摊分析的例子，我们分析出了栈实现的效率 出栈呢？我们需要考虑如何缩小数组 我们也许这么考虑，当数组满了的时候将容量翻倍，那么当它 只有一半满的时候，将容量缩减一半。我们不想让数组变得太空 额，这个办法并不如我们所愿解决问题。因为有一种现象叫做 抖动（thrashing）。如果客户端刚好反复交替入栈出栈入栈出栈 当数组满了就会反复翻倍减半翻倍减半，并且 每个操作都会新建数组，都要花掉正比与N的时间 这样就会导致平方时间，我们不想这样 有效的解决方案是直到数组变为1/4满的时候才将容量减半 实现起来也很容易，我们只要测试数组是否为 1/4满，如果是，则调整大小使其为半满。然后接下来，因为是半满的 既可以插入元素让栈增长或者删除元素让栈变小 而不需要再次进行调整数组大小的操作直到数组全满 或者再次1/4满。所以这里的不变式是数组总是介于25%满与 全满之间，这是第一点；第二，每次调整大小时 开销已经在平摊给了每次入栈和出栈 这里展示了我们的小的客户端例子中数组上的操作 可以看到在开始时，数组大小从1倍增到2又到4 但一旦到8，数组的大小则维持 一段时间，直到数组中只有 2个元素时才缩小到4，等等 数组调整大小并不经常发生，但这是实现 栈API的一种很有效的方式，客户端不需要 提供栈的最大容量，但依然保证了我们使用 的内存大小总是栈中实际元素个数的常数倍 所以分析说明对于任意的操作序列，每个操作的 平均运行时间与常数成正比。这里，存在最坏情况 当栈容量翻倍时，需要正比于N的时间，所以性能 不如我们想要的那么好，但是优势在于进行 入栈出栈操作时非常快，入栈只需要访问数组 并增加栈顶索引。对于大多数操作都很高效 对于众多的客户端这是个很有效的权衡 内存使用量呢？这是栈的内存用量分析 实际上比链表使用更少的内存。内存用量在8N到 32N之间，取决于数组有多满。这里只是计算了 Java中数组占用的空间。同样地，这个分析只针对栈本身 而不包括客户端上的字符串。那么使用 可调整大小的数组与链表之间如何取舍呢？这是两种 API相同的不同的实现，客户端可以互换使用。哪个更好呢？ 很多情形中，我们会有同一API的多种实现 你需要根据客户端的性质选择 合适的实现。对于链表，每个操作最坏情况下 需要常数时间，这是有保障的。但是为了处理链接 我们需要一些额外的时间和空间。所以链表实现会慢一些 可调大小的数组实现有很好的分摊时间，所以整个过程 总的平均效率不错，浪费更少的空间，对于每个操作 也许有更快的实现，所以对于一些客户端，也许会有区别 以下这样的情形你不会想用可调大小数组实现 你有一架飞机进场等待降落 你不想系统突然间不能高效运转 或者互联网上的一个路由器，数据包以很高的速度涌进来 你不想因为某个操作突然变得很慢而丢失 一些数据。客户端就可以权衡，如果想要 获得保证每个操作能够很快完成，就使用 链表实现，如果不需要，只是关心总的时间 可能就是用可调大小数组实现，因为总的 时间会小得多，单个操作非常快 所以，尽管只有这些简单的数据结构，我们都需要 做很重要的权衡，在很多实际情形中真的会产生影响