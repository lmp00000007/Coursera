1
00:00:01,062 --> 00:00:07,022
좋아요. 그것들은 몇가지 기본적인 데이터 구조와 구현이고 그건 매우 기초적이고

2
00:00:07,022 --> 00:00:13,011
간단하게 보이지만 사실 즉시 우리는 이런 기본적인 개념과

3
00:00:13,011 --> 00:00:18,085
우리가 다음에 고려해야할 것들의 몇가지 매우 정교한 어플리케이션을 얻을 수 있습니다.

4
00:00:18,085 --> 00:00:27,076
이제, 첫번째로 언급할 것은 우리가 Java 총서에서 구현하거나 발견하는

5
00:00:27,076 --> 00:00:33,668
데이터 종류와 데이터 구조의 종류에 관한 것입니다. 자, 그것은 많은 프로그래밍 환경에서

6
00:00:33,898 --> 00:00:40,698
사실입니다. 그래서, 예를 들어, Java 총서에서 언급된 여러분이 찾을 수 있는 단어인

7
00:00:40,698 --> 00:00:46,728
스택과 큐가 있고, Java 모음 총서와 여기에 표시된 목록 접속기라고

8
00:00:46,926 --> 00:00:53,203
소위 일컬어지는 것이 있습니다.
그래서 Java는 일련의 항목들에 대한 일반적인 API가 있고

9
00:00:53,203 --> 00:01:00,099
그것은 마치, 끝에 붙이기, 처음부터 제거하기 등을 하고 있습니다.

10
00:01:00,099 --> 00:01:07,611
크기 조정 배열의 사용은, 우리가 고려하는 많은 원칙이

11
00:01:07,867 --> 00:01:15,075
링크 목록 인터페이스에도 사용합니다. 그럼, 왜 그것들을 그저 사용하지 않을까요? 왜 우리 고유의 구현을

12
00:01:15,075 --> 00:01:22,901
사용하나요? 음, 이러한 총서 코드에서 종종 있는 문제는

13
00:01:22,901 --> 00:01:32,367
점점 더 많은 작업이 추가되고 API는 너무 광범위하거나 비대해지는 위원회 현상에 의해

14
00:01:32,367 --> 00:01:39,679
설계되는 경우가 있습니다. 같은 API로 많은 작업을 하는 것은,

15
00:01:39,679 --> 00:01:47,019
여러분이 알다시피, 좋은 생각이 아닙니다. 그리고 잠시 후에 예시를 볼 것입니다.

16
00:01:47,019 --> 00:01:53,427
문제는, 실제 문제는 여러분이 그것을 할 때 여러분이 그 성능에 대해 많이 모르거나

17
00:01:53,427 --> 00:02:01,347
여러분이 그 성능에 대해 충분히 추정할 수 없다는 것입니다. 그리고 여러분은 심지어

18
00:02:01,347 --> 00:02:06,949
단순한 클라이언트를 위한 성능에 즉시 도달할 수 있습니다. 그래서 우리가 추천하는

19
00:02:06,949 --> 00:02:12,918
우리의 가장 좋은 연습은 우리가 사용하는 이런 기본적인 데이터 구조가 너무 적고

20
00:02:12,918 --> 00:02:18,467
간단한 것은 어서 가서 우리가 막 언급한 이런 근본적인 데이터 구조의

21
00:02:18,467 --> 00:02:24,233
구현을 사용하는 것입니다. 아마도 나중에, 나중에,

22
00:02:24,813 --> 00:02:30,745
자신이 무엇을 하고 있는지 아는 그 또는 그녀인 경험 많은 프로그래머가 이런 총서 콜렉션을

23
00:02:30,745 --> 00:02:36,767
효과적으로 사용할 수 있을 것입니다. 하지만 경험이 부족한 프로그래머들은 종종

24
00:02:36,767 --> 00:02:43,793
그것에 어려움을 겪습니다. 여리 얼마 전에 있었던 학생 프로그래밍 과제의 전쟁

25
00:02:43,793 --> 00:02:50,211
이야기가 있습니다. 그래서, 우리는 여러분이 무작위 추출 시스템에서 무작위로 오픈된 사이트를 만들어야 하는

26
00:02:50,211 --> 00:02:55,969
과제가 있습니다. 우리는 우리가 말하는 것에 집중하고

27
00:02:55,969 --> 00:03:01,677
배열을 사용하고 그 배열에 색인을 무작위로 골라 넣어 그들이 열리고, 그리고 반복되는지 확인할 수 있는

28
00:03:01,863 --> 00:03:07,737
한 학생이 있습니다. 그래서 배열이 N 곱하기 N으로,

29
00:03:07,737 --> 00:03:13,955
N제곱 값이고 이 어플리케이션에서 실제로 선형 시간이 N제곱 시간

30
00:03:13,955 --> 00:03:20,113
소요됩니다. 하지만 우리는 우리에게 오기 전에 자바를 전공하고 그 스스로 전문가라고 생각했던

31
00:03:20,113 --> 00:03:25,247
또다른 학생이 있는데 말하기를 음, 저는 제가 Java 총서를 사용할 수 있고

32
00:03:25,437 --> 00:03:31,615
저는 여러분의 바보같은 코드를 다운받는데 걱정이 없기 때문에 연결된 리스트를 사용할

33
00:03:31,615 --> 00:03:38,121
것이라고 말했습니다. 그래서, 저는 단지 그것을 이용해서 무작위로 색인을 선택하고 지우고

34
00:03:38,345 --> 00:03:44,094
우리가 요청한 큰 인스턴스에 대해 그의 프로그램이 끝나지 않았다는 것을 알아내기 위해

35
00:03:44,094 --> 00:03:50,806
작동을 시도할 때 그 프로그램은 이차 시간과 가엾은 Kenny가 걸립니다. 그리고

36
00:03:50,806 --> 00:03:59,050
그 이유는 Java 연결된 리스트 실행은 주어진 인덱스로

37
00:03:59,050 --> 00:04:06,456
항목을 찾기 위해 선형 시간이 걸리기 때문입니다. 배열과 같은 일정한 시간이 아닙니다. 그리고

38
00:04:06,456 --> 00:04:12,800
Kenny가 그것에 대해 생각하기에 어렵고 구현에서 그 정보를 이끌어 내기에 어려워서

39
00:04:12,800 --> 00:04:19,055
프로그램은 매우 느립니다. 그리고 꽤 많은 작업에서

40
00:04:19,055 --> 00:04:25,623
스위스 칼을 사용하여 여러분의 클라이언트의 요구인

41
00:04:25,623 --> 00:04:30,682
특정 작업 세트가 효율적으로 구현했는지 아닌지를 알기가 어렵습니다. 그래서

42
00:04:30,953 --> 00:04:38,444
우리가 강의에서 시행할 때까지 학생들은 총서를 이용하지 않아야 한다는 것이

43
00:04:38,444 --> 00:04:44,551
이 과정에서 우리의 주장입니다. 최소한 여러분이 성능 특성을 이해하고

44
00:04:44,551 --> 00:04:50,546
있다는 것이라는 말입니다. 그럼 이제,
스택의 일부 어플리케이션을

45
00:04:50,546 --> 00:04:56,976
살펴보겠습니다. 스택은 정말로 실제로 기본적이고 근본적인

46
00:04:56,976 --> 00:05:03,716
연산입니다 왜냐하면 그들은 상속, 재귀 등을 하는데, 종종 매일 여러분이 글을 쓰고,

47
00:05:03,716 --> 00:05:09,860
여러분이 스택에 저장해 둔 장소인, 웹 브라우저에서 뒤로 가기 버튼을 사용할 때

48
00:05:09,860 --> 00:05:16,496
여러분은 스택을 사용합니다. 바로 지금 우리는 두가지 예시를 보겠습니다. 하나는,

49
00:05:16,496 --> 00:05:22,377
프로그래밍 언어로 편집하거나 실제 계산으로

50
00:05:22,377 --> 00:05:28,544
해석해야 하는 경우이고 다른 하나는 인쇄와 게시용으로

51
00:05:28,544 --> 00:05:35,249
널리 사용되는 포스트스크립트 언어입니다. 그래서, 따라서 편집자가

52
00:05:35,249 --> 00:05:41,524
기능을 구현하는 방법은 스택을 사용하는 것입니다.
기능 호출을 할 때 전체 로컬

53
00:05:41,524 --> 00:05:48,198
환경이 푸시되고 반환 주소와 마찬가지이고 기능

54
00:05:48,198 --> 00:05:53,623
반환이 로컬 환경에서 반환 주소를 나타냅니다. 그래서 모든

55
00:05:53,623 --> 00:05:58,917
정보를 포함하는 스택이 있고 기능이

56
00:05:58,917 --> 00:06:04,119
스스로 호출하는지 아닌지는 의미가 없습니다. 스택은 반복을 포함합니다. 사실, 재귀 프로그램을

57
00:06:04,119 --> 00:06:09,929
그렇지 않게 만들기 위해서 여러분은 항상 명시적 스택을 사용할 수 있습니다. 그래서, 이것은

58
00:06:09,929 --> 00:06:16,011
우리가 GCD기능을 갖고 있을 때, 가장 큰 공통 분모, 가장 큰

59
00:06:16,011 --> 00:06:23,402
공통 분모 p와 q의 계산은 q와 p모드q의 가장 큰 공통 분모이고

60
00:06:23,402 --> 00:06:30,425
그것은 q가 0이 될 때까지 스스로를 단지 호출합니다.
그리고 이 그래픽을 통합함으로써, 그것은 단지

61
00:06:30,425 --> 00:06:37,849
스택에 정보를 정하는 것으로 작업을 합니다. 이제 구체적인 예시인 이를 실제로

62
00:06:38,087 --> 00:06:47,568
보여주고 또한 동일한 코드로 다양한 유형의 데이터를 처리할 수 있는

63
00:06:47,568 --> 00:06:53,472
유용성을 보여 주는 이 예시는 산술 표현 평가를 위한

64
00:06:53,472 --> 00:06:58,576
Dijkstra의 2-스택 알고리즘입니다. 그래서 목적은, 여러분이

65
00:06:58,576 --> 00:07:03,601
산술식을 받은 것입니다 이것은 단지 실제로 프로그램에 대한 단순한 입장을 나타내는 것과 같고

66
00:07:03,601 --> 00:07:08,398
우리는 그것에 대해 곧 이야기 하겠지만, 산술식이라 합시다.

67
00:07:08,398 --> 00:07:13,936
우리는 피연산자와 연산자를 가지고 있고 여러분은 그것을 평가하고자합니다. 그리고

68
00:07:13,936 --> 00:07:19,897
Dijkstra의 알고리즘은 표현하기 매우 쉽습니다. 여러분은

69
00:07:19,897 --> 00:07:25,485
왼쪽에서 오른쪽으로 표현을 통해 처리합니다. 여러분이 값을 보면, 그것을 표시하고, 여러분은 스택 두개를

70
00:07:25,485 --> 00:07:31,232
유지하고 여러분이 값을 보면, 여러분은 값 스택에 표시하고 여러분이 연산자를

71
00:07:31,232 --> 00:07:37,117
보면, 여러분은 연산 스택에 표시합니다.
왼쪽 괄호는 무시합니다. 오른쪽

72
00:07:37,117 --> 00:07:43,584
괄호는, 여러분이 연산자와 두값을 표시하고 결과를 누릅니다. 이제 많은

73
00:07:43,584 --> 00:07:51,334
용어들, 데모를 살펴보겠습니다. 그럼 우리는 빈 값 스택과 연산

74
00:07:51,334 --> 00:07:57,476
스택으로 시작하여 우리는 왼쪽에서 오른쪽으로 이동하겠습니다. 그래서,

75
00:07:57,703 --> 00:08:04,319
위에 있는 그것들은 우리가 마지막으로 끝낼 수 있는 네가지 유형의 것들과

76
00:08:04,319 --> 00:08:09,608
우리가 무시한 왼쪽 괄호, 우리가 값 스택에 넣은 값을 요약한 것입니다. 그러면,

77
00:08:09,608 --> 00:08:14,985
그것은 값 스택으로 오른쪽으로 갑니다.
연산자는, 우리가 연산 스택에 추가합니다.

78
00:08:14,985 --> 00:08:20,066
그리고 그것은 연산 스택에 추가됩니다.
왼쪽 괄호는 무시합니다. 괄호를 무시하는 것은

79
00:08:20,066 --> 00:08:24,568
이상해 보이고 우리는 곧 그것으로 되돌아 갈 것입니다. 값은,

80
00:08:24,568 --> 00:08:29,677
값 스택에 넣으세요. 연산자는, 연산 스택에 넣으세요. 우리가 스택에

81
00:08:29,677 --> 00:08:35,062
일을 놓은 것을 제외하고는 별로 하는 일이 없어 보이는데 이제, 우리가 오른쪽으로

82
00:08:35,062 --> 00:08:40,322
괄호에 올 때, 그것은 흥미로운 일이 될 때입니다.
그것이 말하는 것은 여러분이 상위 연산자와

83
00:08:40,322 --> 00:08:45,573
상위 두가지 값이 있고 그것이 여러분이 하고 싶은 것입니다.

84
00:08:45,573 --> 00:08:52,136
연산자가 그 값으로 제공하고 얻은 결과 값을 여러분이 다시 연산 스택에

85
00:08:52,136 --> 00:08:57,758
추가합니다. 그래서, 우리는 상위 두가지를 떼어내고, 우리는 연산하고 나서 우리는

86
00:08:57,758 --> 00:09:05,024
우리가 얻은 것을 값 스택에 넣습니다. 그리고 그것은 오른쪽 괄호입니다. 그래서

87
00:09:05,024 --> 00:09:14,720
이제 계속 따라서 우리는 별을 추가합니다.
왼쪽 괄호는, 무시합니다. 별, 네개 추가.

88
00:09:14,991 --> 00:09:21,088
오른쪽은 값 스택으로 가고 이제 우리는 스택에 많은 일을 두었고 우리는

89
00:09:21,088 --> 00:09:25,971
오른쪽 괄호를 통해 가서 계산을 끝낼 것이고,

90
00:09:25,971 --> 00:09:30,530
상위 두 항목을 스택에서 떼어내고
연산 스택에서 상위 연산자를 떼어내고,

91
00:09:30,530 --> 00:09:35,400
작업을 수행하고, 값 스택의 결과에 다시 반영합니다. 또다른 오른쪽으로

92
00:09:35,400 --> 00:09:40,392
괄호는, 상위 두 값을 지웁니다.
작업을 수행합니다. 값 스택에 값을

93
00:09:40,392 --> 00:09:45,696
추가하고 마지막으로, 마지막 오른쪽 괄호는, 값 스택의 두 연산자,

94
00:09:45,696 --> 00:09:51,508
값 스택의 연산자, 그리고 연산 스택의 연산자를 갖고,

95
00:09:51,508 --> 00:09:56,874
작업을 수행하고, 값 스택의 결과를 다시 추가합니다. 그리고 우리는 계산의

96
00:09:56,874 --> 00:10:06,352
끝에 있고 그것이 결과입니다.
산술식의 값은 101입니다.

97
00:10:06,352 --> 00:10:19,447
됐나요? 네. 여기 Dijkstra의 2-스택 알고리즘을 구현하는 코드가 있습니다.

98
00:10:19,737 --> 00:10:26,915
우리는 두가지 다른 스택이 있습니다. 피연산자 스택, 연산 스택은 문자열이고,

99
00:10:26,915 --> 00:10:32,962
그건 단지 우리의 연산자인 문자가 될 수 있습니다. 그러면 우리의 값 스택은 두배가

100
00:10:32,962 --> 00:10:39,034
되어서 그것은 같은 스택 코드이지만 포괄적으로, 우리는, 음, 두가지 다른 유형의 데이터를

101
00:10:39,034 --> 00:10:44,492
사용하고 있습니다. 그런 다음 단순히 Dijkstra의 알고리즘을 수행하기만 하면 됩니다. 만약 우리가

102
00:10:44,492 --> 00:10:50,397
왼쪽 괄호가 있다면... 새로운 문자열을 읽습니다. 만약 우리가 왼쪽 괄호를 가지고 있다면, 아무것도 하지 마세요. 만약 우리가

103
00:10:50,397 --> 00:10:57,089
덧셈이나 곱이 있다면, 미세요. 만약 우리가 오른쪽 괄호가 있다면, 그러면 가서 연산을

104
00:10:57,089 --> 00:11:05,216
하세요. 그리고 만약 그것이 플러스라면, 값 스택의 맨 위에 있는 두 값의 결과를 더하고

105
00:11:05,216 --> 00:11:13,757
만약 그것이 별이라면, 스택의 맨 위에 있는 두 값을 곱하고, 그리고

106
00:11:13,757 --> 00:11:20,392
나서 결과를 밀어넣습니다. 그래서 여러분이 작업을 끝내면 여러분은 스택에서

107
00:11:20,392 --> 00:11:26,749
값을 인쇄하면 그것은 모든 산술식에 스택을 사용하여 멋지고

108
00:11:26,749 --> 00:11:33,027
우아하게 구현됩니다. 그리고 다른 종류의 것들을 다루기 위해 이것을 확장하는 것은

109
00:11:33,027 --> 00:11:40,754
쉽습니다 그래서 왜 이것이 작동할까요? 음, 알고리즘이 내부적으로 연산자를 직면하게 될 때,

110
00:11:40,754 --> 00:11:46,910
우리는 (피연산자, 연산자, 피연산자)의

111
00:11:47,125 --> 00:11:53,697
형태를 얻게되고 내부적으로 무엇이든 간에 꼭대기까지

112
00:11:53,697 --> 00:11:59,647
쌓아가는 것과 쌓여진 값의 꼭대기에 두번 세번 쌓아가는 것을

113
00:11:59,647 --> 00:12:05,534
확인하기가 쉽고 (피연산자, 연산자, 피연산자)를 실행했을 때

114
00:12:05,534 --> 00:12:11,089
운용을 실행할 것이고 재배치된 값이 원본인 것처럼

115
00:12:11,089 --> 00:12:17,064
정확히 실행할 것입니다. 그래서, 1, 1+100, 101을 대체하면서

116
00:12:17,064 --> 00:12:23,314
원래의 표현이 마치 (1+5)20과 이것을

117
00:12:23,314 --> 00:12:29,169
되풀이하는 논지를 반복하는 것과 같은 괄호 안의 모든 연산

118
00:12:29,169 --> 00:12:34,981
안팍으로 실행하는 것입니다. 그것이, 그것이

119
00:12:34,981 --> 00:12:41,487
Dijkstra의 알고리즘이 작동하는 이유입니다. 사실
이것이 왜 효과가 있는지 이해하기는 꽤 쉽습니다.

120
00:12:41,487 --> 00:12:48,066
그리고 여러분은 가서 로그와 사인 또는 다른 연산자와

121
00:12:48,066 --> 00:12:54,376
같은 기능을 추가하여 이 알고리즘을 확장하고 연산자들 사이에 우선순위를 지정하여, 그들을

122
00:12:54,376 --> 00:13:01,602
연결하고 다양한 작업 등을 우선 할 수 있습니다. 그리고 실제로 그것은

123
00:13:01,845 --> 00:13:08,720
프로그래밍 언어에서 계산까지의 프로그램을 변환하는 방법이나 컴파일러를 개발하는

124
00:13:08,720 --> 00:13:16,585
과정에 있기 때문에, 그래서 스택을 사용하는 Dijkstra의 알고리즘은

125
00:13:16,948 --> 00:13:25,072
연산의 기초를 입력하고 이해하는 한가지 방법입니다.