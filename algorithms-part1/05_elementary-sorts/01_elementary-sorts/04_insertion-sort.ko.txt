이제 우리는 흥미롭게도 선택 정렬과 성능 특성이 상당히 다른 또다른 기본 방법인 삽입 정렬을 살펴보겠습니다. 삽입 정렬의 데모를 살펴보겠습니다. 삽입 정렬의 경우, 우리가 할 것은 우리는 이전처럼 색인 i를 왼쪽에서 오른쪽으로 이동할 것이지만, 하지만 지금은, i번째 반복문에서, 우리는 a[i]를 그것의 왼쪽에 있는 원소 사이의 위치로 이동할 것입니다. 카드로 우리의 사례가 어떻게 작동하는지 보겠습니다. 그럼, 이제 우리는 첫번째 카드에 i를 초기화하는 것으로 시작하고, 기본적인 아이디어는 i 왼쪽은 정렬될 것이고, 오른쪽에서의 모든 것을 우리는 살펴보지 않을 것입니다. 그래서 i의 왼쪽에 있는 모든것은 오름 차순으로 정리되어 있고, 오른쪽에 있는 모든 것들은, 우리는 아직 전혀 본 적이 없습니다. 그럼 이제 우리가 i를 늘릴 때, 음, 이 경우에는 이미 순서대로 정렬이 되어있어서 우리는 더이상 할 일이 없습니다. 세번째 경우에 이제, i가 배열에서 세번째 항목일 때, 이제 우리는 색인 j에서 시작합니다, 그리고 우리는 i에서 시작하여 왼쪽으로 이동합니다. 그리고 우리가 해야할 일은 단지 5를 왼쪽에 있는 더 큰 원소들과 교환하는 것입니다. 그래서 처음에 우리는 10과 교환했고, 아직 제자리에 없어서, 우리는 7과 교환합니다. 이제 우리는 배열의 시작에 도달하고, 일단 그렇게 하거나 우리가 더 작은 원소에 닿으면, 우리는 i의 왼쪽에 있는 모두를 순서대로 배열하게 된겁니다 그럼 이제 우리는 인덱스 i를 1 증가시켜서, 우린 3으로 넘어가보죠. 다시말해, 우리는 바로 왼쪽에 있는 카드가 더 큰 한 즉시 교환합니다. 그리고 우리가 이렇게 하고나면, 우리는 왼쪽 값 모두를 오름차순으로 정렬합니다 이제, 이 경우에, 우리는 8이 있고, 그리고 우리는 단 1개만 교환해야하고, 이제 7을 왼쪽에 두고 모두를 순서대로 있습니다. 그래서 우리는 이 경우에 일을 덜 하면서 정돈해낼 수 있었습니다. 우리는 항상 처음으로 거슬러 갈 필요는 없습니다. 4는, 우리가 더 작은 원소를 찾을 때까지 그보다 더 큰 왼쪽에서 모두와 교환하고나서, 오름차순으로 정렬합니다. 2는 배열의 처음까지 도달해야 되겠네요. 하지만 바로 다음에, 9는 오직 한번만 이동하면되고, 6은 반 정도만 돌아가야 합니다. 그리고 나서 우리는 전체 배열을 분류했습니다. 다시, 우리는 불변 면에서 삽입정렬을 살보볼 수 있습니다. 우리의 포인터는 여전히 왼쪽에서 오른쪽으로 스캔하지만, 이제 포인터의 왼쪽에 있는 원소들은, 그것을 포함해서, 순서대로지만, 오른쪽 원소들은 아직 전혀 보이지 않았습니다. 그래서 우리는 포인터가 증가함에 따라 불변하는 상태를 유지하는 코드를 살펴보아야 합니다. 포인터를 오른쪽으로 움직이면, 다시 증가합니다. 포인터의 성분이 정렬되지 않아서 이제 불변은 부서졌습니다. 잘 정돈하기 위해서, 우리는 오른쪽에서 왼쪽으로 이동해야하고, 왼쪽값이 클 때마다 항상 왼쪽값과 교환하고, 그것이 밑에 있는 코드가 하는 것입니다. i에서 시작하는 j로 시작하고, j의 감소, 그 왼쪽 요소들과 j를 교환하고, a[j]를 a[j-1]과 교환합니다 a[j]가 a[j-1]보다 작다면 말이죠 그리고 그것은 즉시 삽입 정렬에 이 코드를 주는데, 이것은 우리의 선택정렬 코드와 유사하고 간단합니다. 중첩된 두개의 루프가 있는데, 선택정렬은 두개의 중첩된 루프, 테스트, 비교, 그리고 루프의 내부 교환이 있습니다. 그리고 그것은 기본적인 분류 방법의 좋은 실행입니다. 삽입 정렬의 분석은 어떻게 할까요? 더욱 복잡합니다. 우리의 명제는 무작위로 정돈된 배열을 분류하는 삽입정렬은, 그것은 약 1/4 N제곱을 비교하고, 그리고 거의 같은 숫자로, 평균적으로, 1/4 N제곱을 교환합니다. 이것은 증명하기 더 복잡합니다. 임의로 정돈하는 배열에 따라 다릅니다. 그리고 다시, 여러분은 이 N을 N추적을 살펴봄으로써 나오는 제안이 나오는 느낌의 형태를 얻을 수 있습니다. 다시말해, 우리가 비교하는 것은 블랙 요소들이고, 교환도 검은 값들에서 이루어집니다. 빨간색 위에 있는 것은 마지막으로 자리 잡은 것입니다. 그리고 여러분은 무작위로 정돈된 큰 배열에서는, 평균 절반정도 되돌아 가야합니다. 즉 대각선 아래에 있는 요소의 절반 정도가 평균적으로 검정색이 된다는 의미입니다. 대각선 아래에 N 제곱 나누기 2가 있고, 절반은 N 제곱 나누기 4입니다. 정확한 분석은 그보다 훨씬 더 상세하지는 않습니다. 이것은 더 큰 추적을 보여주고, 다시, 대각선 아래의 절반 정도의 요소들이 이 종류에 속합니다. [기침] 애니메이션을 봐봅시다. N제곱 나누기 2에 비해 N제곱 나누기 4부터, 삽입정렬은 선택정렬보다 두배 정도 빠를 것입니다. 그래서 우리는 추적을 하면 동일한 시간에 두배 정도 되는 항목만큼 할 수 있습니다. 그것은 요소를 잡아서 매번 제자리로 다시 갖다 놓습니다. 그래서 이것은 무작위로 정돈된 항목을 위한 영상이죠. 이제, 삽입정렬은 데이터의 초기 순서에 따라 달라집니다. 확실히 분리된, 가장 좋은 경우와 가장 나쁜 경우를 봅시다. 만약 배열이 이미 정렬되었다면, 모든 삽입정렬은 각 요소들이 그들의 왼쪽에 더 작은 요소가 있음을 실제로 확인하는 것입니다. 그래서 교환하지 않습니다. 정렬 작업 완료는 N 빼기 1에 필적합니다. 반면에, 만약 배열이 내림차순이고 중복이 없다면, 모든 요소들은 되돌아 갑니다. n제곱 나누기 2를 필적하고 n제곱 나누기 2를 교환합니다. 그래서 첫번째 경우에는, 그것은, 이차함수가 선형이기때문에, 선택정렬보다 훨씬, 훨씬 빠릅니다. 두번째 경우에는, 선택정렬보다 느린데, 왜냐하면 같은 수의 비교를 사용하지만, 더 많은 교환을 사용하기 때문입니다. 자 그럼 영상에서 확인해봅시다. 자 여기 항목들이 역순으로 옵니다. 이제, 새로운 항목을 받을 때마다, 그것은 처음으로 되돌아가 교환해야합니다. 선택정렬과 같은 종류의 동적 특성이죠, 단지,모든 단계를, 단순히 비교하는게 아니라, 서로 교환도 하기 때문에 실제로는 더욱 느립니다. 따라서 이것은 우리가 실제 어플리케이션에서 보고 싶지 않은 나쁜 경우입니다. 하지만 실제로 우리는 많은 실제 어플리케이션에서 활용하는 좋은 경우 또한 있습니다. 그리고 배열이 부분적으로 정렬되어 있을 때 해야합니다. 양적인 방법으로 이것에 대해 이야기 하기 위해, 우리는 역위라 불리는 것을 정의합니다. 역위는 단지 배열에서 잘못된 일련의 키입니다. 그래서 이 배열은 6개의 역위가 있고, R이 T보다 먼저 가야하기 때문에, T와 R은 잘못되었습니다. T와 P는 잘못되었습니다. 이 배열은 6개의 역위가 있습니다. 그리고 만약 역외 횟수가 선형이라면, 일정 정수 곱하기 N보다 작다면, 우리는 배열이 부분적으로 정렬되었다고 정의합니다. 그리고 부분적으로 정렬된 배열은 실제로 종종 나타납니다. 예를 들어, 만약 여러분이 큰 배열이 있는데 마지막에 덧붙인 몇개의 정렬되지 않은 요소만 있다면, 그것은 부분적으로 정렬될 것입니다. 또는 다른 경우에는, 만약 여러분이 단지 몇개의 잘못된 항목이 있다면, 배열은 부분적으로 정렬될 것입니다. 이런 종류의 일들은 실제 어플리케이션에서 종종 발생합니다. 그리고 삽입정렬에서 흥미로운 것은 부분적으로 정렬된 배열에 대해 선형으로 실행됩니다. 그리고 그 증거는, 비교의 수와 교환의 수는 교환의 수와 같고 역위의 수와 같고, 첫번째를 제외하고는 모든 요소에 대해 추가적인 비교가 있습니다. 그럼 어떻게 보이는지 영상으로 살펴봅시다. 여기 부분적으로 정렬된 배열이 있고, 여러분은 삽입정렬이 빠르게 완료되는 것을 볼 수 있습니다. 우리는 이 강의에서 조금 더 뒤에 이것을 활용할 것입니다. 여기까지 우리의 두번째 요소 정렬 방법인, 삽입정렬입니다.