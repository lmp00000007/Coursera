1
00:00:02,190 --> 00:00:03,642
现在我们将学习插入排序

2
00:00:03,642 --> 00:00:07,730
这是另外一种基本排序方法
有趣的是

3
00:00:07,730 --> 00:00:10,560
相比选择排序 插入排序具有相当不同的性能

4
00:00:13,190 --> 00:00:15,960
让我们来看看一个插入排序的演示

5
00:00:15,960 --> 00:00:19,860
对于插入排序，我们要做的和之前一样
从左到右移动索引 i

6
00:00:19,860 --> 00:00:23,670
但现在，在第 i个迭代中

7
00:00:23,670 --> 00:00:27,860
我们将会把 a[ i ] 移动到其左侧的位置

8
00:00:27,860 --> 00:00:30,820
让我们用牌的示例来看看这是怎么工作的

9
00:00:33,570 --> 00:00:38,527
现在我们从初始化 i为第一张牌开始

10
00:00:38,527 --> 00:00:44,826
我们的想法是
i的左边的一切将会被排序

11
00:00:44,826 --> 00:00:49,920
右边的一切，我们全部都不去看

12
00:00:51,350 --> 00:00:55,650
所以，i 左侧所有的东西是升序，右侧所有的东西

13
00:00:55,650 --> 00:00:57,680
我们现在还没检查过

14
00:00:57,680 --> 00:01:01,010
现在我们增加 i 
好，在这种情况下它已经排好序了

15
00:01:01,010 --> 00:01:02,280
我们什么也不用做

16
00:01:03,680 --> 00:01:08,200
在第三种情况下，当 i 是数组中的第三项时

17
00:01:08,200 --> 00:01:14,600
此时我们从索引 j 开始
然后，j 从 i 开始向左边移动

18
00:01:14,600 --> 00:01:19,660
我们要做的是将5与它左边

19
00:01:19,660 --> 00:01:20,610
更大的元素交换

20
00:01:20,610 --> 00:01:24,440
那么，首先与10交换，依然没有到最终位置

21
00:01:24,440 --> 00:01:26,390
所以再和7交换

22
00:01:26,390 --> 00:01:30,840
现在已经到数组最前面了，一旦我们检查完左侧所有项或者

23
00:01:30,840 --> 00:01:36,040
找到一个更小的元素，i 左边所有项就排好序了

24
00:01:37,850 --> 00:01:41,500
再将 i 加一，这次的牌是3

25
00:01:41,500 --> 00:01:46,630
一样的，只要左侧相邻的牌更大，就一直交换

26
00:01:49,830 --> 00:01:50,900
一旦完成之后

27
00:01:50,900 --> 00:01:54,160
从 i 开始它左侧的数组就是升序的

28
00:01:55,380 --> 00:02:00,030
这个情况中，牌是8，只需要交换一次

29
00:02:00,030 --> 00:02:03,410
现在左边是7，i 左边就都排好序了

30
00:02:03,410 --> 00:02:07,000
所以这个情形中我们用更少的工作量就完成了排序

31
00:02:07,000 --> 00:02:09,530
并不总是需要一直检查到数组的开头

32
00:02:10,860 --> 00:02:14,943
4，将它和左边所有比它大的牌交换

33
00:02:14,943 --> 00:02:19,271
直到找到更小的元素，然后 i 的左边就是升序了

34
00:02:19,271 --> 00:02:22,006
2，需要一直检查到数组的开头

35
00:02:27,509 --> 00:02:34,902
而紧接着的下一个，9只需要移动一个位置

36
00:02:34,902 --> 00:02:39,290
6差不多需要移动到中间

37
00:02:39,290 --> 00:02:41,320
然后整个数组就排好序了

38
00:02:42,350 --> 00:02:46,440
我们在从不变式的角度来看插入排序

39
00:02:46,440 --> 00:02:49,070
指针依然是从左至右扫描

40
00:02:49,070 --> 00:02:52,930
但是指针左边的所有元素，包括指针指向的元素

41
00:02:52,930 --> 00:02:57,480
都是排好序的，而右边的元素都还完全没有检查过

42
00:02:57,480 --> 00:03:00,990
我们来看随着指针递增维持

43
00:03:00,990 --> 00:03:03,040
不变式的代码

44
00:03:03,040 --> 00:03:05,805
将指针向右侧移动，增加1

45
00:03:05,805 --> 00:03:10,148
因为指针指向的元素没排过序

46
00:03:10,148 --> 00:03:13,650
所以破坏了不变式

47
00:03:13,650 --> 00:03:18,176
要将它排序，需要将它和左边每个

48
00:03:18,176 --> 00:03:22,787
更大的元素交换，下面的代码完成的就是这个

49
00:03:22,787 --> 00:03:26,824
索引 j 从 i 开始，逐渐变小

50
00:03:26,824 --> 00:03:31,804
j 指向的元素与左边的元素交换

51
00:03:31,804 --> 00:03:37,051
a[j] 与左边的元素 a[j-1] 交换

52
00:03:37,051 --> 00:03:43,680
只要a[j]小于a[j-1]并且 j > 0就一直交换

53
00:03:43,680 --> 00:03:48,030
我们就马上得到了插入排序的代码

54
00:03:48,030 --> 00:03:54,290
与选择排序的代码类似，而且一样简单

55
00:03:54,290 --> 00:03:58,707
有两个嵌套的for循环，选择排序也是一样的

56
00:03:58,707 --> 00:04:03,210
循环中需要进行一次检查，一次比较大小，和一次交换

57
00:04:03,210 --> 00:04:07,220
这是基本排序方法的一个良好的实现

58
00:04:08,800 --> 00:04:12,310
插入排序的分析是怎样的呢？

59
00:04:12,310 --> 00:04:13,830
插入排序更复杂一些

60
00:04:13,830 --> 00:04:20,340
我们的命题是对具有不同关键值的随机序列排序

61
00:04:20,340 --> 00:04:25,660
插入排序平均需要使用大约1/4 N^2次比较

62
00:04:25,660 --> 00:04:30,750
与大约相同的交换次数 1/4 N^2

63
00:04:30,750 --> 00:04:33,210
这个要证明的话更复杂一些

64
00:04:33,210 --> 00:04:36,650
和随机顺序的数组有关

65
00:04:36,650 --> 00:04:38,930
和选择排序的证明一样，从这个N×N的算法步骤中

66
00:04:38,930 --> 00:04:44,430
你可以找到命题来源的思路

67
00:04:44,430 --> 00:04:47,750
黑色的元素依然是我们比较的

68
00:04:47,750 --> 00:04:50,330
实际上，也是进行的交换

69
00:04:50,330 --> 00:04:52,940
红色的是到达的最终位置

70
00:04:53,945 --> 00:04:59,129
你可以看到对于随机顺序的大数组

71
00:04:59,129 --> 00:05:03,758
要移动到最终位置平均要移动大约一半的位置

72
00:05:03,758 --> 00:05:07,604
这意味着对角线以下的元素

73
00:05:07,604 --> 00:05:08,930
平均一半是黑色的

74
00:05:08,930 --> 00:05:11,000
对角线以下的元素有1/2 N^2个

75
00:05:11,000 --> 00:05:12,625
一半就是1/4 N^2

76
00:05:14,050 --> 00:05:18,510
精确的分析比这个详细不了多少

77
00:05:20,928 --> 00:05:23,906
这个步骤更多，再次显示

78
00:05:23,906 --> 00:05:28,725
排序过程中涉及到对角线下大约一半的元素

79
00:05:28,725 --> 00:05:35,187
我们来看动画

80
00:05:35,187 --> 00:05:38,120
因为1/4 N^2和1/2 N^2相比小一半

81
00:05:38,120 --> 00:05:42,450
插入排序的速度大约是选择排序的两倍

82
00:05:42,450 --> 00:05:47,326
所以相同时间内演示中我们能够对大约两倍的元素进行排序

83
00:05:50,796 --> 00:05:55,420
每次选取一个元素，将它移动到左边合适的位置

84
00:05:57,580 --> 00:06:01,590
这是随机顺序元素的动画

85
00:06:01,590 --> 00:06:06,650
插入排序运行时间取决于数据开始的顺序

86
00:06:07,890 --> 00:06:12,334
我们来看看最好与最坏的情况，当然这些都是异常情况了

87
00:06:13,440 --> 00:06:18,090
如果数组恰好已经排好序了，插入排序

88
00:06:18,090 --> 00:06:23,080
实际上只需要验证每个元素比它左边的元素大

89
00:06:23,080 --> 00:06:25,190
所以不用进行交换

90
00:06:25,190 --> 00:06:28,480
只需要N - 1次比较就能完成排序工作

91
00:06:29,590 --> 00:06:33,465
另一方面，如果数组是降序排列的并且

92
00:06:33,465 --> 00:06:37,750
不存在重复值，每个元素都移动到数组开头

93
00:06:38,950 --> 00:06:43,170
需要进行1/2 N^2 次比较与1/2 N^2 次交换

94
00:06:44,310 --> 00:06:45,780
所以第一种情况下，插入排序比选择排序快得多

95
00:06:45,780 --> 00:06:50,170
是线性时间的而不是平方时间的

96
00:06:50,170 --> 00:06:53,505
第二种情形中，比选择排序慢

97
00:06:53,505 --> 00:06:59,290
因为需要一样的比较次数，但是多得多的交换次数

98
00:06:59,290 --> 00:07:01,240
我们来看动画

99
00:07:02,880 --> 00:07:05,990
这是元素降序排列的情况

100
00:07:05,990 --> 00:07:10,540
每次得到一个新元素

101
00:07:10,540 --> 00:07:13,290
都必须一直交换到最开头

102
00:07:15,530 --> 00:07:20,460
与选择排序的动态特性相同

103
00:07:20,460 --> 00:07:22,360
不同点在于，每一步中插入排序不仅仅是交换

104
00:07:22,360 --> 00:07:26,390
还要进行交换，所以实际中就慢了很多

105
00:07:28,740 --> 00:07:33,180
这是实际应用中我们不想见到的最坏的情况

106
00:07:34,220 --> 00:07:38,860
但也有好的情况，在很多实际应用中我们

107
00:07:38,860 --> 00:07:41,310
都在利用这一点

108
00:07:41,310 --> 00:07:45,880
就是数组已经部分有序的情况

109
00:07:45,880 --> 00:07:50,900
用定量的方法考虑，我们定义“逆序对”(inversion)

110
00:07:50,900 --> 00:07:54,800
逆序对是数组中乱序的关键值对

111
00:07:56,110 --> 00:07:59,360
比如这个数组中有六个逆序对

112
00:07:59,360 --> 00:08:02,530
 T和R是乱序的，因为R应该在T的前面

113
00:08:02,530 --> 00:08:05,300
T和P是乱序的，等等

114
00:08:05,300 --> 00:08:07,119
这个数组中有六个逆序对

115
00:08:08,260 --> 00:08:12,710
我们这样定义一个数组是部分有序的，如果其逆序对

116
00:08:12,710 --> 00:08:16,650
数量是线性的，或者说比N乘以某个常数小

117
00:08:18,000 --> 00:08:22,510
部分有序的数组在实际应用中经常遇到

118
00:08:22,510 --> 00:08:27,640
例如，有一个大数组是有序的，只有最后加上的

119
00:08:27,640 --> 00:08:31,170
几个元素是无序的

120
00:08:31,170 --> 00:08:34,950
这个数组就是部分有序的

121
00:08:34,950 --> 00:08:38,170
或者另外的情况，只有几个项不在最终位置

122
00:08:38,170 --> 00:08:40,390
数组就是部分有序的

123
00:08:40,390 --> 00:08:44,710
实际应用中经常出现这样的东西

124
00:08:44,710 --> 00:08:50,370
插入排序有意思的地方在于对于部分有序的数组

125
00:08:50,370 --> 00:08:52,630
它的运行时间是线性的

126
00:08:52,630 --> 00:08:56,410
证明就是交换的次数

127
00:08:56,410 --> 00:09:01,170
与逆序对的个数相等

128
00:09:01,170 --> 00:09:05,410
而除过第一个元素外每个元素需要多一次比较

129
00:09:05,410 --> 00:09:08,510
我们来看动画

130
00:09:08,510 --> 00:09:10,800
这是一个部分有序的数组

131
00:09:10,800 --> 00:09:15,060
可以看到插入排序很快完成了工作

132
00:09:15,060 --> 00:09:18,110
这门课稍后我们将利用这个性质

133
00:09:20,310 --> 00:09:23,888
这就是插入排序
我们学习的第二个基本排序方法