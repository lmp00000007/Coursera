Зараз ми розглянемо сортування
включенням, ще один елементарний метод, який,
 що цікаво, відрізняється продуктивністю
від сортування вибором. Давайте подивимося на демо
сортування включенням. У цьому алгоритмі будемо
пересувати індекс 'i' зліва направо, як і до цього, але
тепер на i-тій ітерації ми перемістимо a[i] на позицію між
елементами зліва від нього. Подивимось, як це працює на нашому
прикладі з картами. Починаємо з ініціалізації
'i' на першій карті. Основна ідея в тому, що все, що знаходиться
зліва від 'i', буде відсортовано, а все, що знаходиться справа, ми не будемо
враховувати. Отже, все зліва від 'i', розташовано у
порядку зростання, все справа від 'i' ми ще не бачили. І тепер, при збільшенні 'i', в цьому
випадку, все вже впорядковано, нам не потрібно нічого робити. А от на третьому кроці, коли 'i' стоїть на
третьому елементі в масиві, ми вводимо індекс 'j' і переміщуємо його
наліво, починаючи з 'i'. Все, що потрібно зробити, це поміняти
місцями 5-ку з кожним елементом, що більше за неї. Спершу міняємо її з 10-кою, вона все
ще не на місці, отже міняємо її з 7-ою. Тепер ми дійшли до початку масиву.
Коли це відбувається, або коли ми зустрічаємо менший елемент,
все, що ліворуч від 'i', впорядковано. Тепер ми знову збільшуємо 'i'
та доходимо до 3-ки. Знову міняємо елементи місцями, поки
карта зліва більша. І коли ми закінчили, все, що зліва від 'i', знаходиться
в порядку зростання. У цьому випадку маємо 8-ку, робимо
обмін тільки один раз, тепер зліва від неї 7-ка, тому все
розташовано по порядку. Ми впорядкували все, виконавши
меншу кількість роботи. Отже, не завжди потрібно доходити
до самого початку. 4-ка, міняємо її місцями з усім,
що більше за неї. Коли буде знайдено менший елемент,
карти розміщено у порядку зростання. 2-ка має переміститися у початок. Проте наступний елемент, 9-ка, зміститься
лише на одну позицію, 6-ка має пройти приблизно
півшляху. І ось ми маємо повністю
відсортований масив. Розглянемо сортування включенням
з точки зору інваріантів. Наш укажчик йде
зліва направо, всі елементи зліва від нього,
включаючи його самого, впорядковані, а елементи справа
від нього ще не були перевірені. Давайте подивимося на код,
що відображає інваріант збільшення укажчика. Переміщуємо укажчик направо,
збільшуючи його на 1. Тепер інваріант порушено,
бо елемент над укажчиком не впорядкований. Для того щоб поставити елемент на правильну позицію,
ми маємо переміщувати його справа наліво, роблячи обмін з кожним більшим елементом
зліва, що і робить код в нижній частині. Він вводить 'j' на позиції 'i',
зменшує 'j' на 1, міняючи 'j' з елементами
зліва від нього, a[j] з елементом зліва, a[j - 1], поки a[j] менше за a[j - 1]
або поки 'j' більше за 0. І з цього отримуємо код для
сортування включенням, який схожий на наш код для сортування
вибором, і такий же простий. В ньому є два вкладені цикли for, так само,
як і в сортуванні вибором, перевірка (порівняння) і обмін
всередині циклу for. Це непогана реалізація елементарного
методу сортування. Що можна сказати про аналіз сортування включенням? Він більш складний. Можна стверджувати, що для того, щоб відсортувати
масив випадкових чисел, що не повторюються, буде зроблено близько
N в квадраті поділене на 4 порівнянь, і приблизно таке ж число обмінів, у середньому,
N в квадраті поділене на 4. Але це набагато важче довести. Все залежить від порядку чисел в масиві. І знову ви можете зрозуміти, звідки ми взяли наше твердження, коли подивитеся
на цю покрокову схему. Чорні елементи – ті, що
ми порівнюємо, і вони ж є об'єктами обміну. Червоний елемент це той, який
зайняв свою позицію. Ви можете бачити, що для великого
масиву з довільним порядком
елементів, елемент який досягає своєї позиції
в середньому проходить півшляху. Це означає, що, в середньому, половина
елементів під діагоналлю будуть чорними. N в квадраті поділене на 2 знаходиться
під діагоналлю, половина від цього – це і є N
в квадраті поділене на 4. Насправді, точний аналіз не набагато
детальніший ніж цей. Ось більша схема, що
знову показує те, що приблизно половина елементів
знаходиться під діагоналлю. Давайте подивимося
на анімацію. Оскільки ми порівнюємо N квадрат
поділене на 4 та N квадрат поділене на 2, сортування включенням
буде приблизно в два рази швидше
за сортування вибором. Отже ми можемо відсортувати приблизно
в два рази більше елементів за
однаковий період часу. З кожною ітерацією елемент переміщується
на потрібну позицію. Це була анімація для масиву з випадковим
порядком елементів. Проте сортування включенням залежить
від початкової відсортованості масиву. Давайте розглянемо найкращий
і найгірший випадки. Якщо даний масив повністю відсортований,
все що алгоритм зробить це просто підтвердить те, що кожен
елемент масиву має менші елементи зліва. Отже він не зробить ні одного обміну. Він справиться з сортуванням
лише за N - 1 порівнянь. З іншої сторони, якщо даний масив
відсортовано у порядку зменшення і він не має дублікатів, то кожний елемент
має пройти весь шлях до початку. Алгоритм робить N в квадраті 2 порівняння
і таку ж кількість обмінів. Отже, в першому випадку він набагато швидший за сортування вибором, лінійний,
а не квадратичний. У другому випадку він повільніший 
за сортування вибором, тому що він робить таку ж кількість порівнянь,
проте набагато більше обмінів. Погляньмо на це в анімації. Ось варіант, коли всі елементи розташовані
у зворотному порядку. Тепер, коли він вибирає новий елемент, він має перенести його у самий початок. Така ж динаміка як і в сортуванні
вибором, проте на кожному кроці алгоритм
не тільки порівнює, а й обмінює, що робить його
повільнішим на практиці. Це випадок, який би не хотілося
зустріти на практиці. Але є також і хороший випадок,
який часто зустрічається на практиці, а саме, коли масив частково відсортовано. Щоб поговорити про це "в числах"
ми маємо ввести поняття інверсії. Інверсія – пара елементів що знаходиться
не на своєму місці в масиві. У цьому масиві є шість інверсій: T та R не на місці, тому що R має
бути перед T. T та P не на своїх місцях, і так далі. У цьому масиві є шість інверсій. Ми кажемо, що масив частково
відсортований, якщо кількість інверсій лінійна, якщо вона
менша за константу N. Насправді частково відсортовані масиви часто
зустрічаються на практиці. Наприклад, якщо у вас є масив з усіма
відсортованими елементами, окрім кількох несортованих елементів у кінці, він є частково відсортованим. Або в інших випадках, коли в масиві лише
декілька елементів не на місці, він є частково відсортованим. Такі випадки часто зустрічаються
на практиці. Цікавим у сортуванні включенням,
є те, що він сортує частково відсортовані масиви
за лінійний час. Доказом є те, що кількість
обмінів дорівнює кількості інверсій, і що для кожного елементу відбувається одне додаткове порівняння. Давайте подивимось на те, як
це виглядає в анімації. Ось частково відсортований масив, і ми бачимо, що сортування включенням швидко
справляється зі своїм завданням. Ми скористаємося цим трохи
пізніше в цій лекції. Це було сортування включенням, наш другий
елементарний метод сортування.