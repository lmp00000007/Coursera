1
00:00:01,024 --> 00:00:06,048
우리가 살펴볼 첫번째 기본적인 정렬 방법은 선택 정렬이라고 알려진

2
00:00:06,048 --> 00:00:11,083
쉬운 방법입니다. 선택 정렬의 개념은, 분류되지 않은 배열과

3
00:00:11,083 --> 00:00:17,101
시작하고 우리는 이런 카드의 패를 사용하여 예로 들어 보겠습니다. 그리고 ith 반복으로,

4
00:00:17,101 --> 00:00:22,867
우리는 가장 작게 남아있는 입력을 찾기위해 배열을 살펴보고, 이 경우에,

5
00:00:22,867 --> 00:00:28,693
2는 어떤 입력보다 가장 작습니다. 그리고 나서 우리는 배열에서 첫번째 입력과 교환하고 나면

6
00:00:28,693 --> 00:00:34,199
우리가 한 단계 완료한 것을 압니다. 선택 정렬은 그 개념의 반복에

7
00:00:34,199 --> 00:00:39,376
기초합니다. 좋아요. 그럼, 기본적인 선택 정렬 방법은, ith

8
00:00:39,376 --> 00:00:44,626
반복에서,i의 오른쪽으로 가거나 i보다 더 큰
 인덱스를 가진 값중에서 가장 작거나 가장 큰 값을

9
00:00:44,626 --> 00:00:50,252
찾아서 i 위치와 교환하는 것입니다. 그럼, 우리는 i부터 시작하니깐 i가 왼쪽에 있고

10
00:00:50,252 --> 00:00:55,711
남아있는, 모든 남아있는 입력들은 오른쪽에 있습니다. 우리는 쭉 스캔을 하고

11
00:00:55,711 --> 00:01:02,516
가장 작은 것은 오른쪽에서 2네요. 끝에서 세 번째 위치에 있는 그 놈을 교환합니다. 바로 이것이

12
00:01:02,516 --> 00:01:08,889
첫번째 단계입니다. 이제, i의 왼쪽에 있는 배열은 최종 정렬이 된 것이고

13
00:01:08,889 --> 00:01:15,193
우리는 그저 계속합니다. i와 교환하고,

14
00:01:15,193 --> 00:01:21,511
i 증가합니다. 그럼 이제, 우리는 우리는 2와 3이 순서대로 있고 계속 그렇게 합니다. 가장

15
00:01:21,511 --> 00:01:27,958
작은 4를, 찾으세요. 그것을 i와 바꾸고, i가 증가합니다. 가장 작은 것, 5를 찾고,

16
00:01:27,958 --> 00:01:34,712
i와 교환하면, i가 증가합니다. 가장 작은 것을 찾아, i와 교환하고 i가 증가합니다.

17
00:01:34,712 --> 00:01:40,689
매번 우리는 가장 작은 것을 찾기 위해서 남은 모든 입력을

18
00:01:40,689 --> 00:01:45,788
훑어봐야 합니다. 그러나, 일단 우리가 찾으면, 우리는 단지

19
00:01:45,979 --> 00:01:52,898
선택 정렬의 주요 특성인 두 카드를 교환하면 됩니다. 지금 8이 가장 작고 우리는

20
00:01:52,898 --> 00:01:59,486
교환합니다. 그리고 이제, 우리는 순서대로 인 것을 알지만 프로그램은 아니므로 우리는 보고

21
00:01:59,486 --> 00:02:06,816
i와 n이 동일하다고 결정하고 나서 스스로와 교환하고

22
00:02:06,816 --> 00:02:13,226
마지막에 대해 같은 일을 합니다. 그래서, 이 과정 후에, 우리는 전체

23
00:02:13,226 --> 00:02:19,445
배열이 최종 순서대로 정렬된 것을 알 수 있습니다.
네. 그럼, 알고리즘이 작동하는 방법을 이해하는 한가지 방법은

24
00:02:19,445 --> 00:02:24,768
역위에 관해 생각해 보는겁니다. 그럼, 선택 정렬을

25
00:02:24,768 --> 00:02:30,924
위해, 우리는  왼쪽에서 오른쪽으로 스캔하는 우리의 변수 i인 포인터를 가지고

26
00:02:30,924 --> 00:02:36,345
있습니다. 이제, 이것은 이 묘사에서 작은 빨간 화살표로 표시되어 있습니다.

27
00:02:36,345 --> 00:02:42,235
invariant는 화살표의 왼쪽에 있는 입력들이 절대 바뀌지 않고

28
00:02:42,235 --> 00:02:48,743
오름차순으로 정렬되어 있는 것입니다. 화살표의 오른쪽의 어떤 입력도

29
00:02:48,743 --> 00:02:54,859
왼쪽의 어떤 입력보다 작지 않습니다. 그것이 우리가 설정하는 방법입니다. 그리고 알고리즘은

30
00:02:54,859 --> 00:03:00,837
오른쪽에서 가장 작은 입력을 찾고 다음 것과 교환함으로써

31
00:03:00,837 --> 00:03:06,827
그 불변을 유지합니다. 그래서 그 코드는 불변을 시행합니다. 그래서, 포인터를

32
00:03:06,827 --> 00:03:12,739
오른쪽으로 이동시키기 위해, 우리는 i를 증가시킵니다. 그래서, 이제 불변이 훼손되었을 수도 있으므로

33
00:03:12,739 --> 00:03:18,425
우리가 고쳐야 합니다. 여러분이 포인터의 성분인, 일부보다 작은 포인터의

34
00:03:18,425 --> 00:03:23,812
오른쪽에 요소를 가졌을지도 모르기 때문에 훼손되었을 수 있습니다.

35
00:03:23,812 --> 00:03:29,143
따라서, 우리가 해야 할 일은 색인값이나 최소 입력값을 파악해서

36
00:03:29,143 --> 00:03:34,170
교환하는 것입니다. 그런다음 우리가 그것을 교환하고 나면, 다시, 우리는 우리의 불편을 보존하게 됩니다.

37
00:03:34,170 --> 00:03:38,846
그 포인트 후에, 포인터 왼쪽에 있는 어떤 요소도 변하지 않을 것이고 모든

38
00:03:38,846 --> 00:03:44,536
요소는, 오른쪽에 더 작은 요소는 없습니다. [기침] 그리고 그것은 우리에게

39
00:03:44,768 --> 00:03:52,713
선택 정렬 구현을 위한 우리의 코드를 즉시 줍니다. 우리는 배열의 길이,

40
00:03:52,713 --> 00:03:59,009
n을 확인합니다. 그러면 우리는 배열에서 모든 요소를 통과하는 for 루프를

41
00:03:59,009 --> 00:04:05,112
갖고, 우리는 포인터 i의 오른쪽에 있는 가장 작은 요소의

42
00:04:05,112 --> 00:04:10,045
색인이 될 색인에서 변수 min을 유지합니다. 우리는 j에 대한

43
00:04:10,045 --> 00:04:15,626
내부 for 루프가 있고, 만약 더 작은 것을 찾으면, min을 다시 설정하고

44
00:04:15,626 --> 00:04:21,509
우리가 i의 오른쪽에 있는 모든 요소들을 살펴보고 나면 우리가 가진 가장 작은 요소를 i와 교환할 수 있습니다.

45
00:04:21,509 --> 00:04:27,083
그것은 선택 정렬의 완벽한 구현입니다. 이제 선택 정렬의

46
00:04:27,083 --> 00:04:34,073
비용에 대한 수학적 모델을 개발하는 것은 쉽고 여기

47
00:04:34,073 --> 00:04:42,054
그것을 설명하는 명제가 있습니다. 약 N제곱2/2를 선택하거나 사용하여 

48
00:04:42,056 --> 00:04:48,011
비교하고 정확히 n과 교환합니다. 그리고 선택 정렬과 윤용의

49
00:04:48,011 --> 00:04:55,525
추적을 보는 것 만으로도 실제로 이 제안의 증거이고 시각적 증거입니다. 이 다이어그램에서,

50
00:04:55,525 --> 00:05:00,493
검정색인 항목은, 최소 항목이 빨간색으로 표시되어

51
00:05:00,493 --> 00:05:06,621
매번 최소 항목을 찾기 위한 검사되는 것들입니다. 회색으로 표시된 항목은 만져지지 않고,

52
00:05:06,621 --> 00:05:12,492
그들은 최종 배열 상태에 있습니다. 음, 여러분은 이것이

53
00:05:12,492 --> 00:05:19,709
N 곱하기 N 제곱의 일반적인 값이 아니고 제곱에서의 요소의 약 절반이 검은색 이거나

54
00:05:19,709 --> 00:05:27,029
약 N제곱/2 값을 볼 수 있고 여러분은 또한 정확한 공식 (N - 1) + (N - 2) 등은

55
00:05:27,245 --> 00:05:33,329
사용된 비교의 총 수를 볼 수 있습니다.  그리고 나서 N개의 값 개별 i마다 

56
00:05:33,329 --> 00:05:40,218
교환이 있어서 교환 횟수의 면에서 비용이

57
00:05:40,218 --> 00:05:48,070
발생합니다. 이제, 선택 정렬에 관한 이 제안에서 흥미로운 것은,

58
00:05:48,070 --> 00:05:54,257
입력이 어떤 순서든 상관 없다는 것입니다. 선택 정렬은 항상

59
00:05:54,257 --> 00:06:00,458
최소를 찾기 위해 항상 모든 과정을 거쳐야 하기 때문에 이차 함수 시간을

60
00:06:00,458 --> 00:06:06,752
사용합니다. 그리도 또다른 속성은 선택 정렬은 단지 선형 교환 횟수이기 때문에

61
00:06:06,752 --> 00:06:12,842
데이터 이동을 덜 정렬할 수 없습니다. 모든 항목은 단 한번의

62
00:06:12,842 --> 00:06:19,459
교환으로 최종 자리에 넣습니다. 시행중인 선택 정렬의

63
00:06:19,459 --> 00:06:25,693
영상을 살펴 봅시다. [기침] 여러분은 우리의 포인터가 매번 오른쪽에서

64
00:06:25,693 --> 00:06:31,919
가장 작은 요소를 찾고 오른쪽에서 왼쪽으로 이동하고, 그것을 제자리로 교환하는 것을 볼 수 있습니다.

65
00:06:31,919 --> 00:06:39,637
이제, 만약 배열이 부분적으로 정렬되어 있다면, 선택 정렬에는 상관 없습니다.

66
00:06:39,637 --> 00:06:45,854
완전히 정렬되었다 하더라도, 여전히 통과해야 하고, 여전히 최

67
00:06:45,854 --> 00:06:51,359
소 요소가 있는 곳으로 가야 합니다. 그 선택 정렬은, 우리의 첫번째

68
00:06:51,359 --> 00:06:59,072
근본적인 정렬 방법입니다.