이제, 우리는 표면적으로 약간 초보적인 것이지만 여러분이 보다시피 전혀 초보적이지 않은 쉘정렬을 살펴보겠습니다.
쉘정렬의 개념은 삽입정렬이 비효율적이라는 것입니다 왜냐하면 우리는 그들이 갈 길이 멀다는 것을 알아도 요소가 실제로 한번에 한 위치만 이동하기 때문입니다. 쉘정렬 이면의 개념은 우리가 한번에 몇개의 입력의 위치를 이동하고 우리가 그것을 하는 방식은, 배열에서 h-정렬 불립니다. 그래서, h-정렬 배열은 h로 정렬된 서로 다른 하위 수열을 인터리브하므로 h=4인 이 경우에 우리가 L에서 시작해서 M, P, T 같은 매 네번째 요소를 살펴보면 그것은 정렬되어 있습니다. 우리가 두번째 위치인 E에서 시작해서 매 네번째 요소를 살펴보면, 정렬되어 있습니다. 그래서 이것은 4 인터리브 수열이고, 4-정렬 배열입니다. 그리고 우리가 하려는 것은 h의 값의 수열을 줄이기 위한 h-정렬 분류 법을 구현하는 것입니다. 이것은 1959년 Shell에 의해 발명된 가장 오래된 정렬 방법 중 하나입니다. 그래서, 이 경우, 표시된 입력 예제로 시작하고나서 13-정렬은 몇개의 항목이 이동되고, 4-정렬은 몇개 더 이동되고, 그리고나서 마침내, 1-정렬입니다. 이전 단계를 거쳐왔기 때문에 각 단계는 단지 몇번의 교환을 준 것만으로 구현될 수 있다는 것입니다. 그럼 첫번째는 우리는 어떻게 h-정렬된 배열을 얻을 수 있을까요? 그것은 사실 꽤 쉽습니다. 우리는 단지 삽입정렬을 사용하지만 매번 한번씩 돌아가는 대신에 우리는 새로운 항목을 가져오고, h 크기 만큼 돌아갑니다. 그래서 예를 들어 우리가 삽입 정렬에서 이 A로 오면, 그 다음, 우리가 그 전에 배열을 보고나면 세개 뒤 위치에 M과 E가 있어서 우리는 A를 그 왼쪽에 더 큰 것과 교환하는데, 그것은 M이고 그런 다음 다른 더 큰것과 그 왼쪽은, E이고 그것은 위치에 들어갑니다. 그래서 삽입 정렬로 말하자면, 우리가 배열을 통해 되돌아갈 때 우리는 그냥 하나씩이 아니라 h씩 건너뛰는 것을 제외하고 코드는 삽입과 같습니다.
그것은 우리가 배열을 h-정렬하는 방법입니다. 그리고 그 개념은 삽입 정렬이 어떻게 작용하는지에 대한 우리의 이해에 기초하여 두가지 이유로 우리가 삽입 정렬을 사용할 것입니다.
첫번째는 증분이 크면 정렬할 하위 배열이 매우 작아서 삽입 정렬을 포함한 모든 정렬 방법은 잘 작동할 것입니다. 하지만 다른 하나는 만약 우리가 이전에 큰 값에 대해 h-정렬을 했기 때문에 증분이 작다면, 배열은 부분적으로 정렬어 있고 삽입 정렬은 빠를 것입니다. 배열에 어떤 순서로 있던 상관 없이 그것은 항상 이차시간을 가지기 때문에 여러분은 쉘정렬을 h-정렬의 기초로 사용하지 않을 것입니다. 자 그럼 7, 3, 그리고 1 증분의 쉘정렬의 예시를 살펴봅시다. 그럼, 우리는 이 정렬 예시로 시작하여 7-정렬을 합시다 - 단지 한번에 이동하는 크기가 7인 삽입 정렬 입니다. 이 경우에, 4 서브파일은 그중 단 두 요소를 가진 각 7로 뻗어납니다. 그런 다음 우리는 3-정렬합니다. 이제, 그것은 7-정렬 되있기 때문에, 3-정렬은 이미 순서대로 되어있거나, 뒤로 몇 걸음만 걸으면 되죠. 이 경우, 단 A만 2로 돌아갑니다. 그리고나서 우리는 1-정렬할텐데, 다시 말하지만 그것은 이미 7-정렬과 3-정렬을 거쳤기 때문에, 1-정렬할 때가 오면 배열은 거의 정리되어 있고 대부분의 항목은 하나 또는 두자리만 돌아갑니다. 큰 숫자의 쉘 소팅을  하기 위해서는, 부가되는 과정이 필요하지만, 각 단계에서는 개별 요소들이 단지 몇 번만 움직이기 때문에, 이런 방식으로 쉘 정렬이 효율성을 얻는겁니다. 그래서 실제로 여러분이 1-정렬을 하면, 그것은 삽입 정렬이라서 여러분은 항상 정렬된 결과를 얻게 될 것입니다. 유일한 차이점은 얼마나 효율적인가 입니다. 이제 쉘정렬 뒤의 직관과 실제로 수학적 사실은 만약 여러분이 h-정렬된 배열을 갖고 여러분이 h와는 다른 또다른 k 값으로 소팅을 한다면 그것은 여전히 h-정렬된 상태입니다. 이것은 명백하게 보이는 수학적 사실들 중 하나이지만 만약 여러분이 그것을 증명하려 한다면 아마도 그것은 여러분이 생각하는 것보다 조금 더 미묘해질 수 있습니다. 그래서, 만약 여러분이 이 모든것이 사소하고 쉽다고 생각한다면, h-정렬이 된 후에도 g-정렬된 배열이 여전히 g-정렬이라는 증거를 어서 가서 적어보세요. 하지만 대부분의 사람들은 그것을 받아들일 것이고 그것은 사실이며 그것이 쉘정렬이 효율을 얻는 방법입니다. 이제 또다른 문제는 쉘정렬을 위에 우리가 어떤 증가 수열을 사용하느냐는 것입니다. 그중 첫번째로 여러분이 생각할 만한 것은 이의 제곱들을 이용해 보자는 겁니다. 실제로 이것은 전혀, 전혀 작동하지 않습니다 왜냐하면 1-정렬까지 홀수 위치의 요쇼들과 짝수 위치 요소들을 비교하지 않고 마무리 지었기 때문입니다. 쉘의 원래 개념은 2의 거듭제곱 -1을 시도하는 거였는데, 이건 잘 작동합니다. Knuth가 그의 책을 쓴 60년대에 증가 수열 3x+1을 제안했었습니다. 우리는 1, 4, 13, 40, 121, 364과 같은 수로 시작하는데 이것은 계산하기 쉽기 때문에 좋습니다. 우리가 물론 쉘정렬에서 사용할 때, 우리는 우리의 파일 크기보다 작은 가장 큰 증분을 발견하고나서, 그 값을 줄여가며 정렬합니다. 하지만 가장 좋은 증가 수열을 발견하는 것은 꽤 오랫동안 사람들을 당황하게 만든 연구문제입니다.
여기 제가 1년 정도 일한 후에 찾은 증가 수열이 잘 작동하는데 아무도 그게 최선인지는 모릅니다. 자 여기 Knuth의 3x+1 증가 수열을 위한 쉘정렬의 Java에서의 시행이 있습니다. 우리는 그냥 계산해 볼텐데, n, n/3보다 작은 증가치를 계산하고 나서 그것이 무엇이라 말하는지 상관없이 증가치에서 시작합니다, 우리는 364를 시작했고 다음에 우리는 증가가 필요하면, 우리는 364의 정수 나누기 3은 121, 또 그 다음은 40 등입니다. 따라서, 이 h = h/3은 다음번 증가치를 얻게 합니다. 그리고 나서, 실행은 단지 삽입 정렬입니다. 우리는 i값이  h에서 시작하고 우리가 j루프를
통해 삽입할 때, 우리는 매번 j를 h만큼 줄이는데, 그걸 제외하면코드는 확실히 삽입 정렬과 같습니다. 따라서, h-정렬에 이 추가 루프와 삽입 정렬에서 증가를 계산하기 위해 이 추가 루프를 더하면, 우리는 약간 더 복잡한 코드 조각을 받는데 이것은 매우 매우 효율적입니다. 여기 더 큰 배열처럼 보이는 것이 있습니다. 우리는 무작위로 정렬된 입력으로 시작하고 여러분은 우리가 h를 줄여가며 h-정렬을 할 때마다 점점 더 순서대로 되는 것을 볼 수 있습니다. 여기 영상이 있습니다. 이 영상은 각 부분배열에 대해 모든 h-정렬을 합니다. 무슨 일이 일어나는지에 대해서 조금 더 좋은 느낌이 드네요. 그리고 이제 높은 수준의 작업을 꽤 빠르게 할 수 있고 이제 1-정렬 작업을 하고 다시 배열을 통해 꽤 빠르게 진행됩니다.
만약 그것이 부분적으로 정렬되었다면 그것은 큰 차이가 없었을 것입니다 - 높은 수준의 정렬은 조금 더 빠르게 합니다. 하지만 그것은 구현하기 간단하고 매우 효율적인 정렬 알고리즘입니다. 지금, 쉘정렬의 분석은 여전히 진행중입니다. 이제, 우리가 말할 수 있는 몇가지가 있습니다. 예를 들어 우리는 최악의 경우는 h를 3x + 1로 잡을 경우, O(N3/2)라고 말할 수 있습니다. 하지만 사실상 실제로는 그것보다 훨씬 적습니다. 문제는 쉘정렬에 의한 어떤 흥미로운 h 수열에 대해, 비교의 수를 만들 정확한 모델을 아무도 모릅니다.
이것은 작은 값으로 보이고, nlogn의 아마도 몇 배수인 n의 배수 곱하기 증가량은 사용됐지만 아무도 쉘정렬의 흥미로운 증분 수열 h에 대해 정확한 모델을 찾을 수 없었습니다. 그러면, 왜 우리는 이 알고리즘에 관심이 있을까요? 음, 그것은 성능을 크게 향상시킬 수 있는 단순한 개념입니다. 이것은 아주 큰 배열을 제열하고는 매우 빠르기 때문에 실제로 매우 유용합니다. 이것은 중간 크기의 배열에서 고전적인 정교한 방법조차 능가할 것입니다. 그리고 이것은 많은 코드를 사용하지 않습니다. 
이것은 구현하기 위한 코드가 거의 없기 때문에 임베디드 시스템이나 하드웨어 정렬 유형 시스템에서 종종 사용됩니다. 그리고 그것은 많은 흥미로운 질문으로 이어집니다. 이것은 개발하는 알고리즘의 지적 도전에 이를 것입니다. 만약 여러분이 우리가 지금까지 공부해온 것이 하찮은 것이라고 생각한다면, 어서 가서 
더 나은 증가 수열을 찾으세요. 하나를 발견하기 위해서 몇가지 기술을 시도하고 쉘정렬의 평균-케이스 성능에 대해 말하려고 노력하세요. 많은 성공을 거두지 못한채로 사람들은 50년동안 그렇게 하려고 노력해왔습니다. 따라서, 우리는 코드 없이도 좋은 알고리즘이나 좋은 구현을 개발할 수 있다는 교훈이 있지만
아직 발견되기를 기다리는 것들은 여전히 있습니다. 그것은 우리가 실제 파일 크기에 대해 잘 알고있는 정렬 방법인, 어떤 다른 방법보다 더 효율적인 쉘정렬을 만드는 어떤 증분 수열이 있을 수 있지만, 아무도 그것을 부인할 수 없습니다. 그것이 쉘정렬이자 뻔하지 않은 첫 정렬 방법입니다.