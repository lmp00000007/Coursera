现在我们来讲希尔排序，这种排序方法看起来比较基础 但你会看到它并不基本。希尔排序的出发点是插入排序 之所以效率低下是因为每个元素每次只向前移动一个位置 即使我们大概知道那些元素还需要移动很远。希尔排序 的思想在于每次我们会将数组项移动若干位置 这种操作方式叫做对数组进行 h-排序。所以 h-有序的数组 包含 h 个不同的交叉的有序子序列。例如，这里 h=4 如果从L开始，检查每第四个元素 - M，P，T -
这个子数组是有序的 从第二个位置 E 开始，检查每第四个元素，是有序的 这里一共有4个交叉的序列，这个数组是4-排序后的 我们想用一系列递减h值的h-排序实现一种排序方法 这种排序方法由希尔(Shell)于1959年发明
是最早的排序方法之一 这个例子中，从这里所示的输入开始，首先进行13-排序 移动几个项，然后是4-排序，移动的项多了一些，最后，1-排序 这种算法的思想在于每次排序的实现基于前面进行过的排序 只需要进行少数几次交换。那么首先我们怎样对序列进行 h-排序呢？实际上很简单。直接用插入排序，但是 之前是每次获取新的项往回走一个，现在往回走h个。比如 在插入排序中处理这个A的时候，查看前面的序列时 前面的序列是M和E，每次退3个 我们将A与它左边更大的M交换，它左边还有一个更大的E 最后将它放在最终位置上。所以代码和插入排序是一样的 只不过顺着数组往回查看的时候之前每次只退1个 现在跳h个。这就是对数组进行h-排序的方法 这里我们使用插入排序的原因基于我们对插入排序 原理的理解有两点：首先是如果增量h很大 那么进行排序的子数组长度就很小 包括插入排序在内的任何排序方法都会有很好的性能 另一点是如果增量小，因为我们之前已经用更大的h值进行了 h-排序，数组是部分有序的，插入排序就会很快 用选择排序作为h-排序的基础就不行，因为 无论序列是什么顺序，它总需要平方时间 我们看一个希尔排序的例子，增量是7、3、1 我们从这个SORT EXAMPLE序列开始，先对它进行7-排序 进行的就是插入排序，只不过每次回退7。这个例子中，4个 字序列间隔是7，各只包含2个元素。然后进行3-排序 因为已经进行过7-排序，进行3-排序的元素要么 已经在最终位置，要么只需要移动几步。这个例子中，只有A 移动了两步。然后进行1-排序，因为数组已经 经过7-排序和3-排序，需要进行1-排序时 数组已经基本有序了，大多数的项只移动一两个位置 所以我们只需要进行几次额外的高增量排序，但是每个元素 都只向它们的最终位置移动了几次，这是希尔排序的高效之处 实际上一旦进行了1-排序，就是进行了插入排序，所以最终 总能得到正确排序的结果。唯一的区别就是能有多高效 对希尔排序更直观的理解，实际上也是可以数学证明的事实 是如果序列是经过h-排序的，用另一个值k进行k-排序 序列仍然是h-有序的。这就是那些看起来很显然但是 如果你试着证明它，会比你想的复杂一些的命题之一 如果你觉得这个结论很平凡很简单，试着 写出证明：g-有序的数组经过h-排序后依然是g-有序的 而大多数人将这一点认定为事实，这是希尔排序高效之处 另一个问题就是对于希尔排序我们应当使用哪种增量序列 首先能想到的想法可能是试试2的幂 实际上这个行不通，因为它 在进行1-排序之前不会将偶数位置的元素和奇数位置的元素 进行比较，这意味着性能就会很差。希尔自己的想法是 尝试使用2的幂减1序列，这是行得通的。Knuth在60年代写 他的书的时候提出用 3x+1 的增量序列，如 1、4、13、40、121、364等，这也不错，因为 当然，我们使用希尔排序的时候，我们首先找到小于待排序 数组长度最大的增量值，然后依照递减的增量值进行排序 但是寻找最好的增量序列是一个困扰了人们相当长 时间的研究问题。这是我经过大概一年的研究 得出的增量序列，性能也不错，但是无法得知是否是最好的 这是用Java实现的希尔排序，使用Knuth的 3x+1 增量序列 我们直接计算小于 N/3 的最大增量 然后以那个值开始，比如从364开始 需要计算下一个增量时，直接除以3 364 整数除 3 等于121、121 整数除 3 等于 40 等等 这句 h = h / 3 计算下一轮排序使用的增量值。实现 就是基于插入排序的。进行插入时 i 从 h 开始 然后 j 循环，每次 j 减小 h，不然代码就和插入排序一模一样了 所以，只需要给h-排序加上额外的循环计算 插入排序的增量，代码变得稍微复杂了一些 但是它的效率要比插入排序高得多。对于大数组运行起来 是这样的。开始时输入序列是随机的，可以看到 随着h值递减，每次h-排序后数组越来越有序 这是动画。动画里对每个子数组都进行了h-排序 可以对整个过程有更好的理解 h值很大时很快就完成了，现在进行1-排序 索引相当快地通过了整个数组。如果数组是部分有序的 1-排序就不会慢很多，高h值的排序会稍微快一点 这个算法实现简单但是效率很高。希尔排序的分析 依然是开放问题。我们掌握了一些规律。比如我们知道 对于 3x+1 的增量序列最坏情况下比较的次数是 O(N^3/2) 实际应用中比这个小得多。问题是没有精确的模型 能够描述使用任何一种有效的增量序列的希尔排序需要 进行比较的次数。值看起来不大 N乘以增量的若干倍，即N log N的若干倍 但是没人能够构建精确的模型对使用有效的 增量序列的希尔排序证明这一点。那么，我们为什么 对这个算法感兴趣呢？这个算法的思想很简单，但是 能获得巨大的性能提升。它相当快，所以在实际中非常有用 除了巨大的数组会变得慢。对于中等大小的数组，它甚至可以 胜过经典的复杂方法。代码量也不大，通常应用于嵌入式系统 或者硬件排序类的系统，因为实现它只需要很少的代码 还有就是它引出了很多有趣的问题。这就涉及到了 开发算法的智力挑战。如果你觉得我们已经研究了这么长时间 的东西很平凡，可以去试着找一个更好的增量序列。尝试 一些方法发现一个，并且试着就希尔排序的一般情况的性能 得出一些结论。人们已经尝试了50年，并没有获得多少成果 我们要学到的是我们不需要很多的代码就能开发出 很好的算法和实现，而依然有一些等待被发现 也许存在某个增量序列使得 希尔排序比其他任何适用于实际序列大小的排序方法都快 并不能否认这一点。这就是希尔排序 第一个不平凡的排序方法