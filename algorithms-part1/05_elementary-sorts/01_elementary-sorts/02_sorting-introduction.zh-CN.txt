进行排列我们应该遵循那些规则呢？我们先看看 典型基本排序问题。比如，大学有很多学生档案 对于每个学生有一些信息。可能是班级编号 成绩、电话号码、地址。我们查看一个元素 那个元素有一条记录，我们要排序的信息 准确地说，记录中有一部分叫做关键字，我们要 讲记录根据关键字进行排列。这就是排序问题 将数组中的n个元素根据元素中的定义的关键字升序排列 我们的目标是能够对任何类型的数据进行排序，来看 几个客户端程序。第一个例子是直接将一些随机实数 按升序排序。这个客户端程序调用插入排序方法 它从标准输入中读取数字，放进数组，然后调用 Insertion.sort（插入排序），最后打印输出。在右边能看到 打印输出的数字是从小到大排好序的。这看起来有点像 人为构建的输入，但就在这堂课中我们就会举一个应用的实例 也有很多应用中随机输入就是很好的模型。可能这个 排序客户端看起来更熟悉，对字符串进行排序。这个例子中它 用readString()方法从文件读取字符串
这个方法在我们的In类里，需要一个文件作为参数 将第一个命令行参数作为文件名，从文件中读取 一个字符串数组，字符串以空白字符分隔
接下来又调用Insertion.sort()方法 Insertion.sort这个方法以数组a作为第一个实参 然后将数组中的字符串排序 这个例子中，words3.txt 有一些三个字母的单词 这个客户端输出的结果就是这些单词 重新按照字母表的顺序排序。如果我们达到了能够对任何类型 数据排序的目标的话，这个客户端也能用我们的排序程序 这个例子中，我们要对文件排序，给定目录中的文件名 这次又用到了Java的File文件类。我们用这个类中的listFiles() 方法获得包含给定目录中所有文件名的数组 Insertion.sort()使用这个数组作为第一实参 同样，程序对这些文件名进行了排序，然后依次 将文件名以字母表的顺序打印输出 这是三个不同的客户端，对应三种完全不同类型的数据 任务的第一条规则就是我们要考虑如何才能完成 实现一个排序程序，可以被三个不同的客户端用来对 三种不同数据类型排序。这里采取的方式 是一种叫做回调的机制。我们的基本问题是 在没有元素关键字类型任何信息的情况下 如何比较所有这些数据。答案是我们建立了一个叫做 回调的机制，即使用指向客户端中给排序函数 传入对象数组的那段可执行代码的指针。Java中，有一种 隐含的机制，只要任何这种对象数组具有compareTo()方法 排序函数就会在需要比较两个元素时 回调数组中的对象对应的compareTo()方法 有很多实现回调函数的办法 和具体编程语言有关。不同的语言有不同的机制 核心思想是将函数作为实参传递给其他函数，需要 更深的理论，涉及到函数式编程思想，可以追溯到图灵和彻奇 对于Java，因为要在编译时检查类型，使用了叫做 接口的特殊方法，后面我们会详细介绍 如何用Java接口实现回调。这个比较 偏向编程语言的细节，但是确实值得学习，因为它使我们 能够以类型安全的方式使用为任何类型数据开发的排序算法 我们已经看了一些客户端程序。这是那个对给定目录中的文件 按照文件名进行排序的客户端程序。它直接调用我们的sort() 方法，以某类型对象数组作为第一实参。Java中内置了 一个叫做Comparable（可比较的）的接口。Comparable接口 规范要求实现Comparable的数据类型要有 一个compareTo()方法。这个方法是泛化的，会对特定类型的 元素进行比较。当我们实现要排序的对象时我们就实现 Comparable接口。就在最上方一行代码
class File implements Comparable File 因为排序是在很多情形中要使用的操作，你可能会进行 排序的很多标准Java类型都实现了Comparable 意味着，这些数据类型具有实现 compareTo()方法的实例方法。它将当前对象与 参数表示的对象相比较，根据具体的一些测试，-1表示小于 返回+1表示大于，0表示相等。排序算法的实现就只需要 这么一个compareTo()方法了。在函数声明的时候 它要求参数必须是Comparable类型数组，这意味着 数组中的对象需要实现Comparable接口，或者说 对象必须有compareTo()方法
然后排序代码直接使用compareTo() 对一个对象实例如数组中的一项调用这个方法 另一个对象实例如数组中另一项作为实参 在这个例子中测试第一个是否小于第二个。关键在于 排序实现里与数据类型无关，具体的比较由 Comparable接口处理，不同类型的Comparable数组最终会以 相同的方式排序，依赖于接口机制，回调到实际的 被排序对象类型的compareTo()代码 有几条规则，是很自然的规则，但也值得一提 注意compareTo()方法实现的是全序关系（total order） 全序关系整体来说就是元素在排序中能够按照特定顺序排列 有三个性质，第一个（非对称性）如果v小于等于w 而且w小于等于v，那么这种情况成立的唯一可能是 v和w相等。然后是传递性，如果v小于等于w w小于等于x，那么v必须小于等于x。完全性，就是 要么v小于等于w，要么w小于等于v，要么两者相等
（没有其他情况） 我们一般考虑作为排序关键字的很多数据类型 具有自然的全序关系，如整数、自然数、实数 字符串的字母表顺序、日期或者时间的先后顺序等等 右边的图说明不是所有的有序关系都是全序关系 所以，石头、剪刀、布是不具有传递性的。如果已知 v小于w，w小于v，你不知道v是否小与等于v。抱歉 我讲错了，v小于等于w，w小于等于x，你并不一定知道 v是否小于等于x。好，那么Comparable的API 按照Java中的规定我们需要实现compareTo()方法，使得v和w 的比较是全序关系。而且按照规定，如果是小于，返回负整数 如果相等返回0，如果当前对象大于作为参数传入的对象 返回正整数。如果对象类型不相容或者其中一个是空指针 compareTo()会抛出异常。Java中很多数字、日期和 文件等等标准类型按照规定都实现了compareTo()方法 如果我们自己实现的类型要用于比较，就要 根据这些规则，自己去实现Comparable接口 实现一般是直截了当的。这里有个例子，这是Java中实现的 Date日期类的简化版，我们用来演示实现Comparable接口 在类声明之后，我们写implements Comparable 然后在泛型类型填上类名，因为我们后面只和将 日期和其他日期比较。在这个实现中，Date类有 三个实例变量。月month、日day和年year。你能看到 构造函数通过参数设置这些变量。如果想要比较两个 不同的日期，首先是检查this.year是否小于that.year 当前日期对象和作为参数的日期对象的年份进行对比 如果为“真”那么就是小于，返回-1。如果this.year更大，返回+1 否则，年份就是相同的，那么我们就必须检查月份来进行比较 这样一直比较到日期。只有三个变量完全相同才返回0 好，这个例子实现了Comparable接口 实现了compareTo()方法，可以将日期按照你期望的顺序排列 Java语言为我们提供了Comparable接口的机制，使我们能够对 任何类型数据排序。当我们后续实现排序算法时 我们实际上将这个机制隐藏在我们的实现下面 排序算法的代码可以用于在其他很多语言中实现排序 我们采用的方式是将引用数据的 两个基本操作，比较和交换，封装为 静态方法。方法less()以两个Comparable对象 作为参数，返回v.compareTo(w) < 0 当我们对数组中的元素进行排序时另一个操作是 swap，将给定索引 i 的对象与索引 j 的对象交换 这个操作是每个程序员学习赋值语句的入门 将 a[i] 保存在变量swap中，a[j] 放进 a[i]，然后swap放回到 a[j] 我们的排序方法引用数据时只需要使用这两个静态方法 这么做有个很充分的理由。举个例子，假设我们想检验 数组是否是有序的。这个静态方法中如果数组有序 则返回“真”，无序则返回“假”。这个方法就是 从头至尾过一遍数组，检查每个元素是否小于 前一个元素。如果有一个元素比前一个元素小，那么数组就是 无序的，返回“假”。如果直到数组结尾也没有检测到 那么数组是有序的。非常简单的代码。问题是 如果你的排序算法通过了测试，你确定数组排序正确吗？ 答案是肯定的，如果你只 用less()和swap()两个方法引用数据的话 因为你知道因为你使用了swap()方法，排序后数组中的 数据和排序前的是一样的 如果你有一个排序方法能够在数组中存储任何数值，比如 在每个数组项中存入0，这个方法也会通过测试 但是它并没有对数组正确排序，因为它覆盖了所有的数值 我们使用less()和swap()确保我们能用这样的方法验证 那么为什么这些结论如此重要呢像这样的金融危机的发生