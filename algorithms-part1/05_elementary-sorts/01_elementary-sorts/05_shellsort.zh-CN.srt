1
00:00:01,046 --> 00:00:07,047
现在我们来讲希尔排序，这种排序方法看起来比较基础

2
00:00:07,047 --> 00:00:16,450
但你会看到它并不基本。希尔排序的出发点是插入排序

3
00:00:16,450 --> 00:00:22,363
之所以效率低下是因为每个元素每次只向前移动一个位置

4
00:00:22,363 --> 00:00:27,858
即使我们大概知道那些元素还需要移动很远。希尔排序

5
00:00:27,858 --> 00:00:33,447
的思想在于每次我们会将数组项移动若干位置

6
00:00:33,447 --> 00:00:38,411
这种操作方式叫做对数组进行 h-排序。所以 h-有序的数组

7
00:00:38,411 --> 00:00:43,088
包含 h 个不同的交叉的有序子序列。例如，这里 h=4

8
00:00:43,088 --> 00:00:49,781
如果从L开始，检查每第四个元素 - M，P，T -
这个子数组是有序的

9
00:00:49,781 --> 00:00:55,496
从第二个位置 E 开始，检查每第四个元素，是有序的

10
00:00:55,496 --> 00:01:01,567
这里一共有4个交叉的序列，这个数组是4-排序后的

11
00:01:01,567 --> 00:01:06,912
我们想用一系列递减h值的h-排序实现一种排序方法

12
00:01:06,912 --> 00:01:13,051
这种排序方法由希尔(Shell)于1959年发明
是最早的排序方法之一

13
00:01:13,051 --> 00:01:19,410
这个例子中，从这里所示的输入开始，首先进行13-排序

14
00:01:19,410 --> 00:01:25,319
移动几个项，然后是4-排序，移动的项多了一些，最后，1-排序

15
00:01:25,319 --> 00:01:31,034
这种算法的思想在于每次排序的实现基于前面进行过的排序

16
00:01:31,034 --> 00:01:37,550
只需要进行少数几次交换。那么首先我们怎样对序列进行

17
00:01:37,550 --> 00:01:43,309
h-排序呢？实际上很简单。直接用插入排序，但是

18
00:01:43,309 --> 00:01:49,416
之前是每次获取新的项往回走一个，现在往回走h个。比如

19
00:01:49,416 --> 00:01:57,233
在插入排序中处理这个A的时候，查看前面的序列时

20
00:01:57,233 --> 00:02:02,094
前面的序列是M和E，每次退3个

21
00:02:02,094 --> 00:02:07,149
我们将A与它左边更大的M交换，它左边还有一个更大的E

22
00:02:07,149 --> 00:02:12,241
最后将它放在最终位置上。所以代码和插入排序是一样的

23
00:02:12,241 --> 00:02:17,085
只不过顺着数组往回查看的时候之前每次只退1个

24
00:02:17,085 --> 00:02:23,040
现在跳h个。这就是对数组进行h-排序的方法

25
00:02:23,040 --> 00:02:28,090
这里我们使用插入排序的原因基于我们对插入排序

26
00:02:28,090 --> 00:02:34,090
原理的理解有两点：首先是如果增量h很大

27
00:02:34,090 --> 00:02:40,076
那么进行排序的子数组长度就很小

28
00:02:40,076 --> 00:02:46,640
包括插入排序在内的任何排序方法都会有很好的性能

29
00:02:46,640 --> 00:02:52,278
另一点是如果增量小，因为我们之前已经用更大的h值进行了

30
00:02:52,278 --> 00:02:58,679
h-排序，数组是部分有序的，插入排序就会很快

31
00:02:58,679 --> 00:03:04,408
用选择排序作为h-排序的基础就不行，因为

32
00:03:04,602 --> 00:03:11,188
无论序列是什么顺序，它总需要平方时间

33
00:03:11,188 --> 00:03:16,678
我们看一个希尔排序的例子，增量是7、3、1

34
00:03:16,678 --> 00:03:23,989
我们从这个SORT EXAMPLE序列开始，先对它进行7-排序

35
00:03:23,989 --> 00:03:29,930
进行的就是插入排序，只不过每次回退7。这个例子中，4个

36
00:03:29,930 --> 00:03:36,605
字序列间隔是7，各只包含2个元素。然后进行3-排序

37
00:03:36,605 --> 00:03:43,370
因为已经进行过7-排序，进行3-排序的元素要么

38
00:03:43,370 --> 00:03:49,671
已经在最终位置，要么只需要移动几步。这个例子中，只有A

39
00:03:49,671 --> 00:03:55,110
移动了两步。然后进行1-排序，因为数组已经

40
00:03:55,110 --> 00:04:00,687
经过7-排序和3-排序，需要进行1-排序时

41
00:04:00,687 --> 00:04:05,777
数组已经基本有序了，大多数的项只移动一两个位置

42
00:04:05,974 --> 00:04:11,788
所以我们只需要进行几次额外的高增量排序，但是每个元素

43
00:04:11,788 --> 00:04:17,703
都只向它们的最终位置移动了几次，这是希尔排序的高效之处

44
00:04:17,924 --> 00:04:24,018
实际上一旦进行了1-排序，就是进行了插入排序，所以最终

45
00:04:24,018 --> 00:04:30,201
总能得到正确排序的结果。唯一的区别就是能有多高效

46
00:04:30,201 --> 00:04:36,755
对希尔排序更直观的理解，实际上也是可以数学证明的事实

47
00:04:36,755 --> 00:04:43,038
是如果序列是经过h-排序的，用另一个值k进行k-排序

48
00:04:43,038 --> 00:04:48,086
序列仍然是h-有序的。这就是那些看起来很显然但是

49
00:04:48,086 --> 00:04:54,337
如果你试着证明它，会比你想的复杂一些的命题之一

50
00:04:54,337 --> 00:05:00,165
如果你觉得这个结论很平凡很简单，试着

51
00:05:00,165 --> 00:05:06,326
写出证明：g-有序的数组经过h-排序后依然是g-有序的

52
00:05:06,326 --> 00:05:13,066
而大多数人将这一点认定为事实，这是希尔排序高效之处

53
00:05:13,066 --> 00:05:18,220
另一个问题就是对于希尔排序我们应当使用哪种增量序列

54
00:05:18,220 --> 00:05:23,740
首先能想到的想法可能是试试2的幂

55
00:05:23,740 --> 00:05:30,360
实际上这个行不通，因为它

56
00:05:30,360 --> 00:05:35,906
在进行1-排序之前不会将偶数位置的元素和奇数位置的元素

57
00:05:35,906 --> 00:05:42,156
进行比较，这意味着性能就会很差。希尔自己的想法是

58
00:05:42,156 --> 00:05:49,059
尝试使用2的幂减1序列，这是行得通的。Knuth在60年代写

59
00:05:49,059 --> 00:05:56,656
他的书的时候提出用 3x+1 的增量序列，如

60
00:05:56,656 --> 00:06:01,826
1、4、13、40、121、364等，这也不错，因为

61
00:06:01,826 --> 00:06:07,939
当然，我们使用希尔排序的时候，我们首先找到小于待排序

62
00:06:07,939 --> 00:06:14,261
数组长度最大的增量值，然后依照递减的增量值进行排序

63
00:06:14,261 --> 00:06:20,760
但是寻找最好的增量序列是一个困扰了人们相当长

64
00:06:20,760 --> 00:06:26,228
时间的研究问题。这是我经过大概一年的研究

65
00:06:26,228 --> 00:06:32,261
得出的增量序列，性能也不错，但是无法得知是否是最好的

66
00:06:32,261 --> 00:06:39,585
这是用Java实现的希尔排序，使用Knuth的 3x+1 增量序列

67
00:06:39,585 --> 00:06:46,393
我们直接计算小于 N/3 的最大增量

68
00:06:46,661 --> 00:06:53,535
然后以那个值开始，比如从364开始

69
00:06:53,535 --> 00:06:59,462
需要计算下一个增量时，直接除以3

70
00:06:59,466 --> 00:07:06,180
364 整数除 3 等于121、121 整数除 3 等于 40 等等

71
00:07:06,180 --> 00:07:12,434
这句 h = h / 3 计算下一轮排序使用的增量值。实现

72
00:07:12,434 --> 00:07:18,861
就是基于插入排序的。进行插入时 i 从 h 开始

73
00:07:18,861 --> 00:07:24,732
然后 j 循环，每次 j 减小 h，不然代码就和插入排序一模一样了

74
00:07:24,732 --> 00:07:31,037
所以，只需要给h-排序加上额外的循环计算

75
00:07:31,037 --> 00:07:36,042
插入排序的增量，代码变得稍微复杂了一些

76
00:07:36,042 --> 00:07:42,008
但是它的效率要比插入排序高得多。对于大数组运行起来

77
00:07:42,008 --> 00:07:48,018
是这样的。开始时输入序列是随机的，可以看到

78
00:07:48,018 --> 00:07:53,082
随着h值递减，每次h-排序后数组越来越有序

79
00:07:53,082 --> 00:07:58,575
这是动画。动画里对每个子数组都进行了h-排序

80
00:07:58,575 --> 00:08:04,994
可以对整个过程有更好的理解

81
00:08:04,994 --> 00:08:10,237
h值很大时很快就完成了，现在进行1-排序

82
00:08:10,237 --> 00:08:16,786
索引相当快地通过了整个数组。如果数组是部分有序的

83
00:08:16,786 --> 00:08:23,989
1-排序就不会慢很多，高h值的排序会稍微快一点

84
00:08:23,989 --> 00:08:30,708
这个算法实现简单但是效率很高。希尔排序的分析

85
00:08:30,939 --> 00:08:37,306
依然是开放问题。我们掌握了一些规律。比如我们知道

86
00:08:37,306 --> 00:08:44,366
对于 3x+1 的增量序列最坏情况下比较的次数是 O(N^3/2)

87
00:08:44,366 --> 00:08:52,051
实际应用中比这个小得多。问题是没有精确的模型

88
00:08:52,051 --> 00:08:58,050
能够描述使用任何一种有效的增量序列的希尔排序需要

89
00:08:58,050 --> 00:09:03,424
进行比较的次数。值看起来不大

90
00:09:03,424 --> 00:09:09,201
N乘以增量的若干倍，即N log N的若干倍

91
00:09:09,201 --> 00:09:14,335
但是没人能够构建精确的模型对使用有效的

92
00:09:14,335 --> 00:09:19,139
增量序列的希尔排序证明这一点。那么，我们为什么

93
00:09:19,139 --> 00:09:24,779
对这个算法感兴趣呢？这个算法的思想很简单，但是

94
00:09:24,779 --> 00:09:29,663
能获得巨大的性能提升。它相当快，所以在实际中非常有用

95
00:09:29,663 --> 00:09:35,328
除了巨大的数组会变得慢。对于中等大小的数组，它甚至可以

96
00:09:35,328 --> 00:09:40,716
胜过经典的复杂方法。代码量也不大，通常应用于嵌入式系统

97
00:09:40,716 --> 00:09:45,821
或者硬件排序类的系统，因为实现它只需要很少的代码

98
00:09:45,821 --> 00:09:51,674
还有就是它引出了很多有趣的问题。这就涉及到了

99
00:09:51,674 --> 00:09:56,499
开发算法的智力挑战。如果你觉得我们已经研究了这么长时间

100
00:09:56,499 --> 00:10:01,960
的东西很平凡，可以去试着找一个更好的增量序列。尝试

101
00:10:01,960 --> 00:10:06,567
一些方法发现一个，并且试着就希尔排序的一般情况的性能

102
00:10:06,567 --> 00:10:12,140
得出一些结论。人们已经尝试了50年，并没有获得多少成果

103
00:10:12,140 --> 00:10:17,502
我们要学到的是我们不需要很多的代码就能开发出

104
00:10:17,502 --> 00:10:22,342
很好的算法和实现，而依然有一些等待被发现

105
00:10:22,342 --> 00:10:27,751
也许存在某个增量序列使得

106
00:10:27,751 --> 00:10:33,147
希尔排序比其他任何适用于实际序列大小的排序方法都快

107
00:10:33,147 --> 00:10:38,551
并不能否认这一点。这就是希尔排序

108
00:10:38,551 --> 00:10:41,060
第一个不平凡的排序方法