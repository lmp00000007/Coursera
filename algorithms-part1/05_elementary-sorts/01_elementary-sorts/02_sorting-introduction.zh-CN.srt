1
00:00:00,000 --> 00:00:04,616
进行排列我们应该遵循那些规则呢？我们先看看

2
00:00:04,616 --> 00:00:10,094
典型基本排序问题。比如，大学有很多学生档案

3
00:00:10,094 --> 00:00:16,094
对于每个学生有一些信息。可能是班级编号

4
00:00:16,094 --> 00:00:22,067
成绩、电话号码、地址。我们查看一个元素

5
00:00:22,067 --> 00:00:27,304
那个元素有一条记录，我们要排序的信息

6
00:00:27,304 --> 00:00:32,118
准确地说，记录中有一部分叫做关键字，我们要

7
00:00:32,118 --> 00:00:37,175
讲记录根据关键字进行排列。这就是排序问题

8
00:00:37,175 --> 00:00:43,204
将数组中的n个元素根据元素中的定义的关键字升序排列

9
00:00:43,204 --> 00:00:49,165
我们的目标是能够对任何类型的数据进行排序，来看

10
00:00:49,165 --> 00:00:55,608
几个客户端程序。第一个例子是直接将一些随机实数

11
00:00:55,608 --> 00:01:00,884
按升序排序。这个客户端程序调用插入排序方法

12
00:01:01,070 --> 00:01:07,068
它从标准输入中读取数字，放进数组，然后调用

13
00:01:07,068 --> 00:01:12,515
Insertion.sort（插入排序），最后打印输出。在右边能看到

14
00:01:12,515 --> 00:01:18,581
打印输出的数字是从小到大排好序的。这看起来有点像

15
00:01:18,581 --> 00:01:24,326
人为构建的输入，但就在这堂课中我们就会举一个应用的实例

16
00:01:24,326 --> 00:01:31,300
也有很多应用中随机输入就是很好的模型。可能这个

17
00:01:31,300 --> 00:01:37,934
排序客户端看起来更熟悉，对字符串进行排序。这个例子中它

18
00:01:37,934 --> 00:01:44,232
用readString()方法从文件读取字符串
这个方法在我们的In类里，需要一个文件作为参数

19
00:01:44,232 --> 00:01:50,186
将第一个命令行参数作为文件名，从文件中读取

20
00:01:50,186 --> 00:01:56,389
一个字符串数组，字符串以空白字符分隔
接下来又调用Insertion.sort()方法

21
00:01:56,389 --> 00:02:03,047
Insertion.sort这个方法以数组a作为第一个实参

22
00:02:03,047 --> 00:02:08,817
然后将数组中的字符串排序

23
00:02:08,817 --> 00:02:15,571
这个例子中，words3.txt 有一些三个字母的单词

24
00:02:15,571 --> 00:02:22,014
这个客户端输出的结果就是这些单词

25
00:02:22,014 --> 00:02:27,673
重新按照字母表的顺序排序。如果我们达到了能够对任何类型

26
00:02:27,914 --> 00:02:34,371
数据排序的目标的话，这个客户端也能用我们的排序程序

27
00:02:34,371 --> 00:02:41,249
这个例子中，我们要对文件排序，给定目录中的文件名

28
00:02:41,513 --> 00:02:49,508
这次又用到了Java的File文件类。我们用这个类中的listFiles()

29
00:02:49,508 --> 00:02:56,788
方法获得包含给定目录中所有文件名的数组

30
00:03:00,205 --> 00:03:03,622
Insertion.sort()使用这个数组作为第一实参

31
00:03:03,622 --> 00:03:10,287
同样，程序对这些文件名进行了排序，然后依次

32
00:03:10,287 --> 00:03:15,754
将文件名以字母表的顺序打印输出

33
00:03:15,754 --> 00:03:20,494
这是三个不同的客户端，对应三种完全不同类型的数据

34
00:03:20,494 --> 00:03:25,508
任务的第一条规则就是我们要考虑如何才能完成

35
00:03:25,508 --> 00:03:30,591
实现一个排序程序，可以被三个不同的客户端用来对

36
00:03:30,591 --> 00:03:35,804
三种不同数据类型排序。这里采取的方式

37
00:03:35,804 --> 00:03:41,555
是一种叫做回调的机制。我们的基本问题是

38
00:03:41,555 --> 00:03:46,629
在没有元素关键字类型任何信息的情况下

39
00:03:46,629 --> 00:03:52,692
如何比较所有这些数据。答案是我们建立了一个叫做

40
00:03:52,692 --> 00:03:59,517
回调的机制，即使用指向客户端中给排序函数

41
00:03:59,517 --> 00:04:05,644
传入对象数组的那段可执行代码的指针。Java中，有一种

42
00:04:05,644 --> 00:04:11,724
隐含的机制，只要任何这种对象数组具有compareTo()方法

43
00:04:11,724 --> 00:04:17,604
排序函数就会在需要比较两个元素时

44
00:04:17,604 --> 00:04:22,351
回调数组中的对象对应的compareTo()方法

45
00:04:22,351 --> 00:04:26,645
有很多实现回调函数的办法

46
00:04:26,645 --> 00:04:32,837
和具体编程语言有关。不同的语言有不同的机制

47
00:04:32,837 --> 00:04:38,780
核心思想是将函数作为实参传递给其他函数，需要

48
00:04:38,780 --> 00:04:45,206
更深的理论，涉及到函数式编程思想，可以追溯到图灵和彻奇

49
00:04:45,206 --> 00:04:50,553
对于Java，因为要在编译时检查类型，使用了叫做

50
00:04:50,553 --> 00:04:56,246
接口的特殊方法，后面我们会详细介绍

51
00:04:56,246 --> 00:05:01,040
如何用Java接口实现回调。这个比较

52
00:05:01,040 --> 00:05:06,086
偏向编程语言的细节，但是确实值得学习，因为它使我们

53
00:05:06,086 --> 00:05:12,011
能够以类型安全的方式使用为任何类型数据开发的排序算法

54
00:05:12,011 --> 00:05:18,084
我们已经看了一些客户端程序。这是那个对给定目录中的文件

55
00:05:18,084 --> 00:05:25,001
按照文件名进行排序的客户端程序。它直接调用我们的sort()

56
00:05:25,001 --> 00:05:31,498
方法，以某类型对象数组作为第一实参。Java中内置了

57
00:05:31,498 --> 00:05:37,939
一个叫做Comparable（可比较的）的接口。Comparable接口

58
00:05:37,939 --> 00:05:45,024
规范要求实现Comparable的数据类型要有

59
00:05:45,024 --> 00:05:52,956
一个compareTo()方法。这个方法是泛化的，会对特定类型的

60
00:05:52,956 --> 00:05:59,902
元素进行比较。当我们实现要排序的对象时我们就实现

61
00:05:59,902 --> 00:06:06,370
Comparable接口。就在最上方一行代码
class File implements Comparable File

62
00:06:06,370 --> 00:06:13,351
因为排序是在很多情形中要使用的操作，你可能会进行

63
00:06:13,351 --> 00:06:20,026
排序的很多标准Java类型都实现了Comparable

64
00:06:20,026 --> 00:06:27,040
意味着，这些数据类型具有实现

65
00:06:27,040 --> 00:06:33,068
compareTo()方法的实例方法。它将当前对象与

66
00:06:33,068 --> 00:06:40,296
参数表示的对象相比较，根据具体的一些测试，-1表示小于

67
00:06:40,296 --> 00:06:46,181
返回+1表示大于，0表示相等。排序算法的实现就只需要

68
00:06:46,181 --> 00:06:50,726
这么一个compareTo()方法了。在函数声明的时候

69
00:06:50,726 --> 00:06:55,833
它要求参数必须是Comparable类型数组，这意味着

70
00:06:55,833 --> 00:07:02,023
数组中的对象需要实现Comparable接口，或者说

71
00:07:02,023 --> 00:07:08,000
对象必须有compareTo()方法
然后排序代码直接使用compareTo()

72
00:07:08,000 --> 00:07:13,052
对一个对象实例如数组中的一项调用这个方法

73
00:07:13,052 --> 00:07:19,012
另一个对象实例如数组中另一项作为实参

74
00:07:19,012 --> 00:07:24,092
在这个例子中测试第一个是否小于第二个。关键在于

75
00:07:24,092 --> 00:07:31,010
排序实现里与数据类型无关，具体的比较由

76
00:07:31,010 --> 00:07:38,250
Comparable接口处理，不同类型的Comparable数组最终会以

77
00:07:38,250 --> 00:07:44,862
相同的方式排序，依赖于接口机制，回调到实际的

78
00:07:44,862 --> 00:07:50,944
被排序对象类型的compareTo()代码

79
00:07:50,944 --> 00:07:57,603
有几条规则，是很自然的规则，但也值得一提

80
00:07:57,603 --> 00:08:05,112
注意compareTo()方法实现的是全序关系（total order）

81
00:08:05,112 --> 00:08:13,220
全序关系整体来说就是元素在排序中能够按照特定顺序排列

82
00:08:13,220 --> 00:08:19,133
有三个性质，第一个（非对称性）如果v小于等于w

83
00:08:19,133 --> 00:08:25,857
而且w小于等于v，那么这种情况成立的唯一可能是

84
00:08:25,857 --> 00:08:31,495
v和w相等。然后是传递性，如果v小于等于w

85
00:08:31,495 --> 00:08:36,736
w小于等于x，那么v必须小于等于x。完全性，就是

86
00:08:36,736 --> 00:08:42,785
要么v小于等于w，要么w小于等于v，要么两者相等
（没有其他情况）

87
00:08:43,003 --> 00:08:49,420
我们一般考虑作为排序关键字的很多数据类型

88
00:08:49,420 --> 00:08:55,097
具有自然的全序关系，如整数、自然数、实数

89
00:08:55,097 --> 00:09:01,185
字符串的字母表顺序、日期或者时间的先后顺序等等

90
00:09:01,185 --> 00:09:07,280
右边的图说明不是所有的有序关系都是全序关系

91
00:09:07,280 --> 00:09:12,643
所以，石头、剪刀、布是不具有传递性的。如果已知

92
00:09:12,643 --> 00:09:17,626
v小于w，w小于v，你不知道v是否小与等于v。抱歉

93
00:09:17,626 --> 00:09:22,135
我讲错了，v小于等于w，w小于等于x，你并不一定知道

94
00:09:22,135 --> 00:09:30,219
v是否小于等于x。好，那么Comparable的API

95
00:09:30,219 --> 00:09:39,003
按照Java中的规定我们需要实现compareTo()方法，使得v和w

96
00:09:39,003 --> 00:09:46,852
的比较是全序关系。而且按照规定，如果是小于，返回负整数

97
00:09:46,852 --> 00:09:54,408
如果相等返回0，如果当前对象大于作为参数传入的对象

98
00:09:54,408 --> 00:10:00,754
返回正整数。如果对象类型不相容或者其中一个是空指针

99
00:10:01,011 --> 00:10:07,466
compareTo()会抛出异常。Java中很多数字、日期和

100
00:10:07,713 --> 00:10:15,012
文件等等标准类型按照规定都实现了compareTo()方法

101
00:10:15,207 --> 00:10:20,018
如果我们自己实现的类型要用于比较，就要

102
00:10:20,018 --> 00:10:24,092
根据这些规则，自己去实现Comparable接口

103
00:10:24,092 --> 00:10:30,065
实现一般是直截了当的。这里有个例子，这是Java中实现的

104
00:10:30,065 --> 00:10:37,099
Date日期类的简化版，我们用来演示实现Comparable接口

105
00:10:37,099 --> 00:10:42,029
在类声明之后，我们写implements Comparable

106
00:10:42,029 --> 00:10:48,356
然后在泛型类型填上类名，因为我们后面只和将

107
00:10:48,356 --> 00:10:53,712
日期和其他日期比较。在这个实现中，Date类有

108
00:10:53,712 --> 00:10:58,853
三个实例变量。月month、日day和年year。你能看到

109
00:10:58,853 --> 00:11:04,098
构造函数通过参数设置这些变量。如果想要比较两个

110
00:11:04,098 --> 00:11:10,238
不同的日期，首先是检查this.year是否小于that.year

111
00:11:10,238 --> 00:11:15,696
当前日期对象和作为参数的日期对象的年份进行对比

112
00:11:15,696 --> 00:11:20,291
如果为“真”那么就是小于，返回-1。如果this.year更大，返回+1

113
00:11:20,292 --> 00:11:26,226
否则，年份就是相同的，那么我们就必须检查月份来进行比较

114
00:11:26,226 --> 00:11:31,964
这样一直比较到日期。只有三个变量完全相同才返回0

115
00:11:31,964 --> 00:11:36,054
好，这个例子实现了Comparable接口

116
00:11:36,054 --> 00:11:42,814
实现了compareTo()方法，可以将日期按照你期望的顺序排列

117
00:11:42,814 --> 00:11:49,775
Java语言为我们提供了Comparable接口的机制，使我们能够对

118
00:11:49,775 --> 00:11:55,521
任何类型数据排序。当我们后续实现排序算法时

119
00:11:55,521 --> 00:12:02,245
我们实际上将这个机制隐藏在我们的实现下面

120
00:12:02,245 --> 00:12:08,728
排序算法的代码可以用于在其他很多语言中实现排序

121
00:12:08,728 --> 00:12:14,650
我们采用的方式是将引用数据的

122
00:12:14,650 --> 00:12:20,614
两个基本操作，比较和交换，封装为

123
00:12:20,614 --> 00:12:26,137
静态方法。方法less()以两个Comparable对象

124
00:12:26,137 --> 00:12:31,878
作为参数，返回v.compareTo(w) < 0

125
00:12:31,878 --> 00:12:39,218
当我们对数组中的元素进行排序时另一个操作是

126
00:12:39,218 --> 00:12:45,861
swap，将给定索引 i 的对象与索引 j 的对象交换

127
00:12:45,861 --> 00:12:52,166
这个操作是每个程序员学习赋值语句的入门

128
00:12:52,166 --> 00:12:59,014
将 a[i] 保存在变量swap中，a[j] 放进 a[i]，然后swap放回到 a[j]

129
00:12:59,014 --> 00:13:05,545
我们的排序方法引用数据时只需要使用这两个静态方法

130
00:13:05,545 --> 00:13:10,872
这么做有个很充分的理由。举个例子，假设我们想检验

131
00:13:10,872 --> 00:13:16,285
数组是否是有序的。这个静态方法中如果数组有序

132
00:13:16,285 --> 00:13:21,298
则返回“真”，无序则返回“假”。这个方法就是

133
00:13:21,298 --> 00:13:26,411
从头至尾过一遍数组，检查每个元素是否小于

134
00:13:26,411 --> 00:13:31,440
前一个元素。如果有一个元素比前一个元素小，那么数组就是

135
00:13:31,440 --> 00:13:36,352
无序的，返回“假”。如果直到数组结尾也没有检测到

136
00:13:36,352 --> 00:13:41,482
那么数组是有序的。非常简单的代码。问题是

137
00:13:41,482 --> 00:13:47,415
如果你的排序算法通过了测试，你确定数组排序正确吗？

138
00:13:47,415 --> 00:13:54,124
答案是肯定的，如果你只

139
00:13:54,124 --> 00:14:00,792
用less()和swap()两个方法引用数据的话

140
00:14:00,792 --> 00:14:07,592
因为你知道因为你使用了swap()方法，排序后数组中的

141
00:14:07,592 --> 00:14:13,489
数据和排序前的是一样的

142
00:14:13,489 --> 00:14:18,640
如果你有一个排序方法能够在数组中存储任何数值，比如

143
00:14:18,640 --> 00:14:24,337
在每个数组项中存入0，这个方法也会通过测试

144
00:14:24,337 --> 00:14:29,046
但是它并没有对数组正确排序，因为它覆盖了所有的数值

145
00:14:29,046 --> 00:14:39,306
我们使用less()和swap()确保我们能用这样的方法验证

146
00:14:39,306 --> 00:14:44,056
那么为什么这些结论如此重要呢像这样的金融危机的发生