1
00:00:02,190 --> 00:00:03,642
Зараз ми розглянемо сортування
включенням,

2
00:00:03,642 --> 00:00:07,730
ще один елементарний метод, який,
 що цікаво,

3
00:00:07,730 --> 00:00:10,560
відрізняється продуктивністю
від сортування вибором.

4
00:00:13,190 --> 00:00:15,960
Давайте подивимося на демо
сортування включенням.

5
00:00:15,960 --> 00:00:19,860
У цьому алгоритмі будемо
пересувати індекс 'i'

6
00:00:19,860 --> 00:00:23,670
зліва направо, як і до цього, але
тепер на i-тій ітерації

7
00:00:23,670 --> 00:00:27,860
ми перемістимо a[i] на позицію між
елементами зліва від нього.

8
00:00:27,860 --> 00:00:30,820
Подивимось, як це працює на нашому
прикладі з картами.

9
00:00:33,570 --> 00:00:38,527
Починаємо з ініціалізації
'i' на першій карті.

10
00:00:38,527 --> 00:00:44,826
Основна ідея в тому, що все, що знаходиться
зліва від 'i', буде відсортовано,

11
00:00:44,826 --> 00:00:49,920
а все, що знаходиться справа, ми не будемо
враховувати.

12
00:00:51,350 --> 00:00:55,650
Отже, все зліва від 'i', розташовано у
порядку зростання, все справа від 'i'

13
00:00:55,650 --> 00:00:57,680
ми ще не бачили.

14
00:00:57,680 --> 00:01:01,010
І тепер, при збільшенні 'i', в цьому
випадку, все вже впорядковано,

15
00:01:01,010 --> 00:01:02,280
нам не потрібно нічого робити.

16
00:01:03,680 --> 00:01:08,200
А от на третьому кроці, коли 'i' стоїть на
третьому елементі в масиві,

17
00:01:08,200 --> 00:01:14,600
ми вводимо індекс 'j' і переміщуємо його
наліво, починаючи з 'i'.

18
00:01:14,600 --> 00:01:19,660
Все, що потрібно зробити, це поміняти
місцями 5-ку з кожним елементом,

19
00:01:19,660 --> 00:01:20,610
що більше за неї.

20
00:01:20,610 --> 00:01:24,440
Спершу міняємо її з 10-кою, вона все
ще не на місці, отже

21
00:01:24,440 --> 00:01:26,390
міняємо її з 7-ою.

22
00:01:26,390 --> 00:01:30,840
Тепер ми дійшли до початку масиву.
Коли це відбувається, або

23
00:01:30,840 --> 00:01:36,040
коли ми зустрічаємо менший елемент,
все, що ліворуч від 'i', впорядковано.

24
00:01:37,850 --> 00:01:41,500
Тепер ми знову збільшуємо 'i'
та доходимо до 3-ки.

25
00:01:41,500 --> 00:01:46,630
Знову міняємо елементи місцями, поки
карта зліва більша.

26
00:01:49,830 --> 00:01:50,900
І коли ми закінчили,

27
00:01:50,900 --> 00:01:54,160
все, що зліва від 'i', знаходиться
в порядку зростання.

28
00:01:55,380 --> 00:02:00,030
У цьому випадку маємо 8-ку, робимо
обмін тільки один раз,

29
00:02:00,030 --> 00:02:03,410
тепер зліва від неї 7-ка, тому все
розташовано по порядку.

30
00:02:03,410 --> 00:02:07,000
Ми впорядкували все, виконавши
меншу кількість роботи.

31
00:02:07,000 --> 00:02:09,530
Отже, не завжди потрібно доходити
до самого початку.

32
00:02:10,860 --> 00:02:14,943
4-ка, міняємо її місцями з усім,
що більше за неї.

33
00:02:14,943 --> 00:02:19,271
Коли буде знайдено менший елемент,
карти розміщено у порядку зростання.

34
00:02:19,271 --> 00:02:22,006
2-ка має переміститися у початок.

35
00:02:27,509 --> 00:02:34,902
Проте наступний елемент, 9-ка, зміститься
лише на одну позицію,

36
00:02:34,902 --> 00:02:39,290
6-ка має пройти приблизно
півшляху.

37
00:02:39,290 --> 00:02:41,320
І ось ми маємо повністю
відсортований масив.

38
00:02:42,350 --> 00:02:46,440
Розглянемо сортування включенням
з точки зору інваріантів.

39
00:02:46,440 --> 00:02:49,070
Наш укажчик йде
зліва направо,

40
00:02:49,070 --> 00:02:52,930
всі елементи зліва від нього,
включаючи його самого,

41
00:02:52,930 --> 00:02:57,480
впорядковані, а елементи справа
від нього ще не були перевірені.

42
00:02:57,480 --> 00:03:00,990
Давайте подивимося на код,
що відображає інваріант

43
00:03:00,990 --> 00:03:03,040
збільшення укажчика.

44
00:03:03,040 --> 00:03:05,805
Переміщуємо укажчик направо,
збільшуючи його на 1.

45
00:03:05,805 --> 00:03:10,148
Тепер інваріант порушено,
бо елемент над

46
00:03:10,148 --> 00:03:13,650
укажчиком не впорядкований.

47
00:03:13,650 --> 00:03:18,176
Для того щоб поставити елемент на правильну позицію,
ми маємо переміщувати його справа наліво,

48
00:03:18,176 --> 00:03:22,787
роблячи обмін з кожним більшим елементом
зліва, що і робить код в нижній частині.

49
00:03:22,787 --> 00:03:26,824
Він вводить 'j' на позиції 'i',
зменшує 'j' на 1,

50
00:03:26,824 --> 00:03:31,804
міняючи 'j' з елементами
зліва від нього,

51
00:03:31,804 --> 00:03:37,051
a[j] з елементом зліва, a[j - 1],

52
00:03:37,051 --> 00:03:43,680
поки a[j] менше за a[j - 1]
або поки 'j' більше за 0.

53
00:03:43,680 --> 00:03:48,030
І з цього отримуємо код для
сортування включенням,

54
00:03:48,030 --> 00:03:54,290
який схожий на наш код для сортування
вибором, і такий же простий.

55
00:03:54,290 --> 00:03:58,707
В ньому є два вкладені цикли for, так само,
як і в сортуванні вибором,

56
00:03:58,707 --> 00:04:03,210
перевірка (порівняння) і обмін
всередині циклу for.

57
00:04:03,210 --> 00:04:07,220
Це непогана реалізація елементарного
методу сортування.

58
00:04:08,800 --> 00:04:12,310
Що можна сказати про аналіз сортування включенням?

59
00:04:12,310 --> 00:04:13,830
Він більш складний.

60
00:04:13,830 --> 00:04:20,340
Можна стверджувати, що для того, щоб відсортувати
масив випадкових чисел,

61
00:04:20,340 --> 00:04:25,660
що не повторюються, буде зроблено близько
N в квадраті поділене на 4 порівнянь,

62
00:04:25,660 --> 00:04:30,750
і приблизно таке ж число обмінів, у середньому,
N в квадраті поділене на 4.

63
00:04:30,750 --> 00:04:33,210
Але це набагато важче довести.

64
00:04:33,210 --> 00:04:36,650
Все залежить від порядку чисел в масиві.

65
00:04:36,650 --> 00:04:38,930
І знову ви можете зрозуміти, звідки

66
00:04:38,930 --> 00:04:44,430
ми взяли наше твердження, коли подивитеся
на цю покрокову схему.

67
00:04:44,430 --> 00:04:47,750
Чорні елементи – ті, що
ми порівнюємо, і

68
00:04:47,750 --> 00:04:50,330
вони ж є об'єктами обміну.

69
00:04:50,330 --> 00:04:52,940
Червоний елемент це той, який
зайняв свою позицію.

70
00:04:53,945 --> 00:04:59,129
Ви можете бачити, що для великого
масиву з довільним порядком
елементів,

71
00:04:59,129 --> 00:05:03,758
елемент який досягає своєї позиції
в середньому проходить півшляху.

72
00:05:03,758 --> 00:05:07,604
Це означає, що, в середньому, половина
елементів під діагоналлю

73
00:05:07,604 --> 00:05:08,930
будуть чорними.

74
00:05:08,930 --> 00:05:11,000
N в квадраті поділене на 2 знаходиться
під діагоналлю,

75
00:05:11,000 --> 00:05:12,625
половина від цього – це і є N
в квадраті поділене на 4.

76
00:05:14,050 --> 00:05:18,510
Насправді, точний аналіз не набагато
детальніший ніж цей.

77
00:05:20,928 --> 00:05:23,906
Ось більша схема, що
знову показує те, що

78
00:05:23,906 --> 00:05:28,725
приблизно половина елементів
знаходиться під діагоналлю.

79
00:05:28,725 --> 00:05:35,187
Давайте подивимося
на анімацію.

80
00:05:35,187 --> 00:05:38,120
Оскільки ми порівнюємо N квадрат
поділене на 4 та N квадрат

81
00:05:38,120 --> 00:05:42,450
поділене на 2, сортування включенням
буде приблизно в два рази швидше
за сортування вибором.

82
00:05:42,450 --> 00:05:47,326
Отже ми можемо відсортувати приблизно
в два рази більше елементів за
однаковий період часу.

83
00:05:50,796 --> 00:05:55,420
З кожною ітерацією елемент переміщується
на потрібну позицію.

84
00:05:57,580 --> 00:06:01,590
Це була анімація для масиву з випадковим
порядком елементів.

85
00:06:01,590 --> 00:06:06,650
Проте сортування включенням залежить
від початкової відсортованості масиву.

86
00:06:07,890 --> 00:06:12,334
Давайте розглянемо найкращий
і найгірший випадки.

87
00:06:13,440 --> 00:06:18,090
Якщо даний масив повністю відсортований,
все що алгоритм

88
00:06:18,090 --> 00:06:23,080
зробить це просто підтвердить те, що кожен
елемент масиву має менші елементи зліва.

89
00:06:23,080 --> 00:06:25,190
Отже він не зробить ні одного обміну.

90
00:06:25,190 --> 00:06:28,480
Він справиться з сортуванням
лише за N - 1 порівнянь.

91
00:06:29,590 --> 00:06:33,465
З іншої сторони, якщо даний масив
відсортовано у порядку зменшення

92
00:06:33,465 --> 00:06:37,750
і він не має дублікатів, то кожний елемент
має пройти весь шлях до початку.

93
00:06:38,950 --> 00:06:43,170
Алгоритм робить N в квадраті 2 порівняння
і таку ж кількість обмінів.

94
00:06:44,310 --> 00:06:45,780
Отже, в першому випадку він набагато

95
00:06:45,780 --> 00:06:50,170
швидший за сортування вибором, лінійний,
а не квадратичний.

96
00:06:50,170 --> 00:06:53,505
У другому випадку він повільніший 
за сортування вибором,

97
00:06:53,505 --> 00:06:59,290
тому що він робить таку ж кількість порівнянь,
проте набагато більше обмінів.

98
00:06:59,290 --> 00:07:01,240
Погляньмо на це в анімації.

99
00:07:02,880 --> 00:07:05,990
Ось варіант, коли всі елементи розташовані
у зворотному порядку.

100
00:07:05,990 --> 00:07:10,540
Тепер, коли він вибирає новий елемент,

101
00:07:10,540 --> 00:07:13,290
він має перенести його у самий початок.

102
00:07:15,530 --> 00:07:20,460
Така ж динаміка як і в сортуванні
вибором, проте на

103
00:07:20,460 --> 00:07:22,360
кожному кроці алгоритм
не тільки порівнює,

104
00:07:22,360 --> 00:07:26,390
а й обмінює, що робить його
повільнішим на практиці.

105
00:07:28,740 --> 00:07:33,180
Це випадок, який би не хотілося
зустріти на практиці.

106
00:07:34,220 --> 00:07:38,860
Але є також і хороший випадок,
який часто зустрічається

107
00:07:38,860 --> 00:07:41,310
на практиці,

108
00:07:41,310 --> 00:07:45,880
а саме, коли масив частково відсортовано.

109
00:07:45,880 --> 00:07:50,900
Щоб поговорити про це "в числах"
ми маємо ввести поняття інверсії.

110
00:07:50,900 --> 00:07:54,800
Інверсія – пара елементів що знаходиться
не на своєму місці в масиві.

111
00:07:56,110 --> 00:07:59,360
У цьому масиві є шість інверсій: T та

112
00:07:59,360 --> 00:08:02,530
R не на місці, тому що R має
бути перед T.

113
00:08:02,530 --> 00:08:05,300
T та P не на своїх місцях, і так далі.

114
00:08:05,300 --> 00:08:07,119
У цьому масиві є шість інверсій.

115
00:08:08,260 --> 00:08:12,710
Ми кажемо, що масив частково
відсортований, якщо кількість

116
00:08:12,710 --> 00:08:16,650
інверсій лінійна, якщо вона
менша за константу N.

117
00:08:18,000 --> 00:08:22,510
Насправді частково відсортовані масиви часто
зустрічаються на практиці.

118
00:08:22,510 --> 00:08:27,640
Наприклад, якщо у вас є масив з усіма
відсортованими елементами, окрім

119
00:08:27,640 --> 00:08:31,170
кількох несортованих елементів у кінці,

120
00:08:31,170 --> 00:08:34,950
він є частково відсортованим.

121
00:08:34,950 --> 00:08:38,170
Або в інших випадках, коли в масиві лише
декілька елементів не на місці,

122
00:08:38,170 --> 00:08:40,390
він є частково відсортованим.

123
00:08:40,390 --> 00:08:44,710
Такі випадки часто зустрічаються
на практиці.

124
00:08:44,710 --> 00:08:50,370
Цікавим у сортуванні включенням,
є те, що він сортує

125
00:08:50,370 --> 00:08:52,630
частково відсортовані масиви
за лінійний час.

126
00:08:52,630 --> 00:08:56,410
Доказом є те, що кількість
обмінів дорівнює

127
00:08:56,410 --> 00:09:01,170
кількості інверсій, і що для кожного елементу

128
00:09:01,170 --> 00:09:05,410
відбувається одне додаткове порівняння.

129
00:09:05,410 --> 00:09:08,510
Давайте подивимось на те, як
це виглядає в анімації.

130
00:09:08,510 --> 00:09:10,800
Ось частково відсортований масив, і

131
00:09:10,800 --> 00:09:15,060
ми бачимо, що сортування включенням швидко
справляється зі своїм завданням.

132
00:09:15,060 --> 00:09:18,110
Ми скористаємося цим трохи
пізніше в цій лекції.

133
00:09:20,310 --> 00:09:23,888
Це було сортування включенням, наш другий
елементарний метод сортування.