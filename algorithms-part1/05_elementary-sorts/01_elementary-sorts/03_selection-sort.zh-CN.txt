我们要讲的第一个基本排序方法很简单 叫做选择排序。选择排序的思想如下：从未排序 数组开始，我们用这些扑克牌举例，在第 i 次迭代中 我们在数组剩下的项中找到最小的，这个情况下 2是所有项中最小的，然后，我们将它和数组中的第一项交换 这一步就完成了。选择排序就是基于这样的思想迭代操作 好，基本的选择排序方法是在第 i 次迭代中 在数组中第i项右边剩下的或者索引比i更大的项中找到最小的 一项，然后和第 i 项交换。开始i是0，从最左端开始 扫描所有右边剩下的项 最小的是2，右起第3项，那么我们交换这两项 这是第一步。i左边这部分数组就是排过序的 我们继续。现在最小的是3，与第i项交换 i加1。现在2、3已经就位了，继续如此操作 找最小的，4，和第 i 项交换，i 加1。找最小的 5，和第 i 项交换，i 加1。找最小的，和第 i 项交换，i 加1 为了寻找最小的项都要扫描全部剩下的项 但一旦找到之后，只需要交换两张牌 这是两条是选择排序的关键性质。现在8是最小的，交换 这时，我们知道已经是有序的了，但是程序不知道，所以必须 检查并且做决定。i和min相同，和自己交换，最后一次迭代 也是如此。这个过程结束后，我们知道整个数组 已经是最终状态，是有序的了。理解 算法工作方式的一个办法是考虑不变性 对于选择排序，我们有个指针，变量i，从左到右扫描 在这个图中用红色箭头表示 不变性就是箭头左边的项不会再变了 它们已经是升序了。箭头右边的项都比箭头左边的项大 这是我们确立的机制。算法 通过找到右边最小的项，并和箭头所指的右边下一项交换来 维持不变性。实现不变性的代码如下：向右移动指针 i 加1。现在不变性有可能被破坏了，我们要修复它 有可能因为在指针右边有一个元素比 指针所指的元素小导致不变性被破坏了 我们要做的是找到最小项的索引，然后交换 一旦我们完成了交换，我们又一次保留了不变性 这时指针左边元素不会再变了 右边也没有更小的元素 这也就给出了实现选择排序的代码。我们将 数组的长度记为N，for循环遍历数组中每个元素 变量min用来存储指针i 右边最小元素的索引 内层的j的for循环，如果找到更小的值，则重设min 一旦检查完i右侧所有的元素，将最小的和第i项交换 这就是选择排序的完整实现。为选择排序的开销 建立数学模型非常容易 这个命题描述了选择排序使用大约N^2 / 2个比较以及 整整N次交换。只要看看这个选择排序 运行的跟踪记录，这就是这个命题的图形证明 图中，黑色的项是每次为了寻找最小项检查的项 最小项是红色的。灰色的项是未检查的项 已经在最终位置了。你可以看到这基本就是 N×N的正方形，其中大约一半的元素是黑色的，即大约 N^2 / 2，你也能看出准确的表达式(N - 1) + (N - 2)等等就是 总共比较的次数。然后在变量i的这N个取值各有 一次交换，所以这是交换次数的开销 关于选择排序的这个命题说明了很有意思的一点 就是它和输入的序列本身的顺序无关。选择排序需要 平方时间因为它总要查看所有的项寻找最小项 另一个性质就是要完成排序这已经是移动开销最小的了 选择排序只需要线性次数的交换。每一项都是 仅仅一次交换就放在了最终位置。我们看看 选择排序运行的动画。你可以看到指针由左至右扫描 每次扫描找到右边最小的项，交换到它最终的位置上 如果数组一部分已经排好序了，这对选择排序不影响 依然要一遍一遍扫描，即使是完全有序的，依然要 扫描右边的项来找最小的元素。这就是选择排序 我们第一个基本排序方法